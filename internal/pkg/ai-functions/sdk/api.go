// Copyright (c) 2021 Terminus, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package sdk

import (
	_ "embed"
	"encoding/json"
	"github.com/pkg/errors"
	"github.com/xeipuuv/gojsonschema"
	"sigs.k8s.io/yaml"
	"strings"
)

type CreateCompletionOption[FC string | *FunctionCall] func(options CreateCompletionOptions[FC])

type CreateCompletionOptions[FC string | *FunctionCall] struct {
	Messages         []*ChatMessage        `json:"messages"`
	Functions        []*FunctionDefinition `json:"functions" yaml:"functions"`
	FunctionCall     FC                    `json:"function_call" yaml:"function_call"`
	MaxTokens        int32                 `json:"max_tokens" yaml:"maxTokens"`
	Temperature      json.Number           `json:"temperature" yaml:"temperature"`
	TopP             json.Number           `json:"top_p" yaml:"top_p"`
	LogitBias        map[string]int32      `json:"logit_bias" yaml:"logit_bias"`
	User             string                `json:"user" yaml:"user"`
	N                int32                 `json:"n" yaml:"n"`
	Stop             string                `json:"stop" yaml:"stop"`
	PresencePenalty  json.Number           `json:"presence_penalty" yaml:"presence_penalty"`
	FrequencyPenalty json.Number           `json:"frequency_penalty" yaml:"frequency_penalty"`
	Stream           bool                  `json:"stream" yaml:"stream"`
	Model            string                `json:"model" yaml:"model"`
}

func (c *CreateCompletionOptions[FC]) Validate() error {
	if len(c.Messages) == 0 {
		return errors.New("messages is required")
	}
	return nil
}

type ChatCompletions struct {
	ID                string                `json:"id" yaml:"id"`
	Created           uint64                `json:"created" yaml:"created"`
	Choices           []*ChatChoice         `json:"choices" yaml:"choices"`
	PromptAnnotations []*PromptFilterResult `json:"prompt_annotations" yaml:"prompt_annotations"`
	Usage             *CompletionsUsage     `json:"usage" yaml:"usage"`
}

type ChatMessage struct {
	Role    string `json:"role" yaml:"role"`
	Content string `json:"content" yaml:"content"`
	Name    string `json:"name" yaml:"name"`
	// FunctionCall The name and arguments of a function that should be called, as generated by the model.
	FunctionCall *FunctionCall `json:"function_call" yaml:"function_call"`
}

// FunctionDefinition The definition of a caller-specified function that chat completions may invoke in response to matching user input.
type FunctionDefinition struct {
	Name        string `json:"name" yaml:"name"`
	Description string `json:"description" yaml:"description"`
	// Parameters: The parameters the functions accepts, described as a JSON Schema object.
	Parameters json.RawMessage `json:"parameters" yaml:"parameters"`
}

// VerifyArguments verifies that the given JSON conforms to the JSON Schema FunctionDefinition.Parameters
func (fd *FunctionDefinition) VerifyArguments(data json.RawMessage) error {
	// fd.Parameters and data may be either JSON or Yaml structured, convert to JSON structured uniformly.
	if err := yaml.Unmarshal(fd.Parameters, &fd.Parameters); err != nil {
		return errors.Wrap(err, "failed to unmarshal Parameters to JSON")
	}
	if err := yaml.Unmarshal(data, &data); err != nil {
		return errors.Wrap(err, "failed to unmarshal to JSON")
	}

	ls := gojsonschema.NewBytesLoader(fd.Parameters)
	ld := gojsonschema.NewBytesLoader(data)
	result, err := gojsonschema.Validate(ls, ld)
	if err != nil {
		return errors.Wrap(err, "failed to Validate")
	}
	if result.Valid() {
		return nil
	}
	var ss []string
	for _, item := range result.Errors() {
		ss = append(ss, item.String())
	}
	return errors.New(strings.Join(ss, "; "))
}

type FunctionCall struct {
	Name      string `json:"name" yaml:"name"`
	Arguments string `json:"arguments" yaml:"arguments"`
}

type ChatChoice struct {
	Message              *ChatMessage             `json:"message" yaml:"message"`
	Index                int32                    `json:"index" yaml:"index"`
	FinishReason         *CompletionsFinishReason `json:"finish_reason" yaml:"finish_reason"`
	Delta                *ChatMessage             `json:"delta" yaml:"delta"`
	ContentFilterResults *ContentFilterResults    `json:"content_filter_results" yaml:"content_filter_results"`
}

type PromptFilterResult struct {
	// todo:
}

type CompletionsUsage struct {
	// todo:
}

type CompletionsFinishReason struct {
	// todo:
}

type ContentFilterResults struct {
	// todo:
}
