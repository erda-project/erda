// Copyright (c) 2021 Terminus, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package sdk

import (
	_ "embed"
	"encoding/json"
	"github.com/pkg/errors"
	"github.com/xeipuuv/gojsonschema"
	"sigs.k8s.io/yaml"
	"strings"
)

type CreateCompletionOption[FC string | *FunctionCall] func(options CreateCompletionOptions)

type CreateCompletionOptions struct {
	Messages         []*ChatMessage        `json:"messages"`
	Functions        []*FunctionDefinition `json:"functions,omitempty" yaml:"functions,omitempty"`
	FunctionCall     FunctionCall          `json:"function_call,omitempty" yaml:"function_call,omitempty"`
	MaxTokens        int32                 `json:"max_tokens,omitempty" yaml:"maxTokens,omitempty"`
	Temperature      json.Number           `json:"temperature,omitempty" yaml:"temperature,omitempty"`
	TopP             json.Number           `json:"top_p,omitempty" yaml:"top_p,omitempty"`
	LogitBias        map[string]int32      `json:"logit_bias,omitempty" yaml:"logit_bias,omitempty"`
	User             string                `json:"user,omitempty" yaml:"user,omitempty"`
	N                int32                 `json:"n,omitempty" yaml:"n,omitempty"`
	Stop             string                `json:"stop,omitempty" yaml:"stop,omitempty"`
	PresencePenalty  json.Number           `json:"presence_penalty,omitempty" yaml:"presence_penalty,omitempty"`
	FrequencyPenalty json.Number           `json:"frequency_penalty,omitempty" yaml:"frequency_penalty,omitempty"`
	Stream           bool                  `json:"stream,omitempty" yaml:"stream,omitempty"`
	Model            string                `json:"model,omitempty" yaml:"model,omitempty"`
}

func (c *CreateCompletionOptions) Validate() error {
	if len(c.Messages) == 0 {
		return errors.New("messages is required")
	}
	return nil
}

type ChatCompletions struct {
	ID                string                `json:"id" yaml:"id"`
	Object            string                `json:"object,omitempty" yaml:"object,omitempty"`
	Created           uint64                `json:"created" yaml:"created"`
	Model             string                `json:"model,omitempty" yaml:"model,omitempty"`
	Choices           []*ChatChoice         `json:"choices" yaml:"choices"`
	Usage             *CompletionsUsage     `json:"usage,omitempty" yaml:"usage,omitempty"`
	PromptAnnotations []*PromptFilterResult `json:"prompt_annotations,omitempty" yaml:"prompt_annotations,omitempty"`
}

type ChatMessage struct {
	Role    string `json:"role" yaml:"role"`
	Content string `json:"content" yaml:"content"`
	Name    string `json:"name,omitempty" yaml:"name,omitempty"`
	// FunctionCall The name and arguments of a function that should be called, as generated by the model.
	FunctionCall *FunctionCall `json:"function_call,omitempty" yaml:"function_call,omitempty"`
}

// FunctionDefinition The definition of a caller-specified function that chat completions may invoke in response to matching user input.
type FunctionDefinition struct {
	Name        string `json:"name" yaml:"name"`
	Description string `json:"description" yaml:"description"`
	// Parameters: The parameters the functions accepts, described as a JSON Schema object.
	Parameters json.RawMessage `json:"parameters" yaml:"parameters"`
}

// VerifyArguments verifies that the given JSON conforms to the JSON Schema FunctionDefinition.Parameters
func (fd *FunctionDefinition) VerifyArguments(data json.RawMessage) error {
	// fd.Parameters and data may be either JSON or Yaml structured, convert to JSON structured uniformly.
	if err := yaml.Unmarshal(fd.Parameters, &fd.Parameters); err != nil {
		return errors.Wrap(err, "failed to unmarshal Parameters to JSON")
	}
	if err := yaml.Unmarshal(data, &data); err != nil {
		return errors.Wrap(err, "failed to unmarshal to JSON")
	}

	ls := gojsonschema.NewBytesLoader(fd.Parameters)
	ld := gojsonschema.NewBytesLoader(data)
	result, err := gojsonschema.Validate(ls, ld)
	if err != nil {
		return errors.Wrap(err, "failed to Validate")
	}
	if result.Valid() {
		return nil
	}
	var ss []string
	for _, item := range result.Errors() {
		ss = append(ss, item.String())
	}
	return errors.New(strings.Join(ss, "; "))
}

type FunctionCall struct {
	Name      string `json:"name" yaml:"name"`
	Arguments string `json:"arguments,omitempty" yaml:"arguments,omitempty"`
}

type ChatChoice struct {
	Index                int32                 `json:"index" yaml:"index"`
	Message              *ChatMessage          `json:"message" yaml:"message"`
	FinishReason         string                `json:"finish_reason,omitempty" yaml:"finish_reason,omitempty"`
	Delta                *ChatMessage          `json:"delta,omitempty" yaml:"delta,omitempty"`
	ContentFilterResults *ContentFilterResults `json:"content_filter_results,omitempty" yaml:"content_filter_results,omitempty"`
}

type PromptFilterResult struct {
	PromptIndex          int32                `json:"prompt_index"`
	ContentFilterResults ContentFilterResults `json:"content_filter_results" yaml:"content_filter_results"`
}

type CompletionsUsage struct {
	// todo:
}

type ContentFilterResults struct {
	Sexual   ContentFilterResult `json:"sexual" yaml:"sexual"`
	Violence ContentFilterResult `json:"violence" yaml:"violence"`
	Hate     ContentFilterResult `json:"hate" yaml:"hate"`
	SelfHarm ContentFilterResult `json:"self_harm" yaml:"self_harm"`
	Error    ErrorBase           `json:"error" yaml:"error"`
}

type ContentFilterResult struct {
	Severity string `json:"severity" yaml:"severity"`
	Filtered bool   `json:"filtered" yaml:"filtered"`
}

type ErrorBase struct {
	Code    string `json:"code" yaml:"code"`
	Message string `json:"error" yaml:"error"`
}

type Error struct {
	*ErrorBase
	Code       string
	Message    string
	Param      string
	Type       string
	InnerError InnerError
}

type InnerError struct {
	Code                 InnerErrorCode       `json:"code" yaml:"code"`
	ContentFilterResults ContentFilterResults `json:"contentFilterResults" yaml:"contentFilterResults"`
}

type InnerErrorCode string
