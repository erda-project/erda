// Copyright (c) 2021 Terminus, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package ctxhelper

import (
	"context"
	"sync"

	"github.com/erda-project/erda/internal/apps/ai-proxy/route/filter_define"
)

type ctxKeyRespBodyChunkSplitter struct{}
type ctxKeyResponseContentEncoding struct{}
type ctxKeyResponseModifierError struct{}

// PutRespBodyChunkSplitter puts RespBodyChunkSplitter into ctx for framework to retrieve.
func PutRespBodyChunkSplitter(ctx context.Context, s filter_define.RespBodyChunkSplitter) {
	m := ctx.Value(CtxKeyMap{}).(*sync.Map)
	m.Store(ctxKeyRespBodyChunkSplitter{}, s)
}

// GetRespBodyChunkSplitter retrieves RespBodyChunkSplitter; returns nil if not exists.
func GetRespBodyChunkSplitter(ctx context.Context) filter_define.RespBodyChunkSplitter {
	value, ok := ctx.Value(CtxKeyMap{}).(*sync.Map).Load(ctxKeyRespBodyChunkSplitter{})
	if !ok || value == nil {
		return nil
	}
	s, ok := value.(filter_define.RespBodyChunkSplitter)
	if !ok {
		return nil
	}
	return s
}

// PutResponseContentEncoding puts response Content-Encoding value into ctx for decompression judgment.
func PutResponseContentEncoding(ctx context.Context, contentEncoding string) {
	m := ctx.Value(CtxKeyMap{}).(*sync.Map)
	m.Store(ctxKeyResponseContentEncoding{}, contentEncoding)
}

// GetResponseContentEncoding retrieves response Content-Encoding value; returns empty string if not exists.
func GetResponseContentEncoding(ctx context.Context) string {
	value, ok := ctx.Value(CtxKeyMap{}).(*sync.Map).Load(ctxKeyResponseContentEncoding{})
	if !ok || value == nil {
		return ""
	}
	s, ok := value.(string)
	if !ok {
		return ""
	}
	return s
}

// PutResponseModifierError puts error generated by response modifier into ctx.
func PutResponseModifierError(ctx context.Context, err error) {
	m := ctx.Value(CtxKeyMap{}).(*sync.Map)
	m.Store(ctxKeyResponseModifierError{}, err)
}

// GetResponseModifierError retrieves error generated by response modifier; returns nil if not exists.
func GetResponseModifierError(ctx context.Context) error {
	value, ok := ctx.Value(CtxKeyMap{}).(*sync.Map).Load(ctxKeyResponseModifierError{})
	if !ok || value == nil {
		return nil
	}
	err, ok := value.(error)
	if !ok {
		return nil
	}
	return err
}
