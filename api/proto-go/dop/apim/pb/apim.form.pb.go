// Code generated by protoc-gen-go-form. DO NOT EDIT.
// Source: apim.proto

package pb

import (
	url "net/url"
	strconv "strconv"

	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/urlenc" package it is being compiled against.
var _ urlenc.URLValuesUnmarshaler = (*CreateExportRecordsReq)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateExportRecordsResp)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ExportRecord)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListExportRecordsReq)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListExportRecordsResp)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListExportRecordsData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteExportRecordReq)(nil)
var _ urlenc.URLValuesUnmarshaler = (*Empty)(nil)

// CreateExportRecordsReq implement urlenc.URLValuesUnmarshaler.
func (m *CreateExportRecordsReq) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "versionID":
				val, err := strconv.ParseUint(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.VersionID = uint32(val)
			case "specProtocol":
				m.SpecProtocol = vals[0]
			}
		}
	}
	return nil
}

// CreateExportRecordsResp implement urlenc.URLValuesUnmarshaler.
func (m *CreateExportRecordsResp) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &ExportRecord{}
				}
			case "data.id":
				if m.Data == nil {
					m.Data = &ExportRecord{}
				}
				m.Data.Id = vals[0]
			case "data.createdAt":
				if m.Data == nil {
					m.Data = &ExportRecord{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
			case "data.createdAt.seconds":
				if m.Data == nil {
					m.Data = &ExportRecord{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Seconds = val
			case "data.createdAt.nanos":
				if m.Data == nil {
					m.Data = &ExportRecord{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Nanos = int32(val)
			case "data.updatedAt":
				if m.Data == nil {
					m.Data = &ExportRecord{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "data.updatedAt.seconds":
				if m.Data == nil {
					m.Data = &ExportRecord{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.UpdatedAt.Seconds = val
			case "data.updatedAt.nanos":
				if m.Data == nil {
					m.Data = &ExportRecord{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.UpdatedAt.Nanos = int32(val)
			case "data.orgID":
				if m.Data == nil {
					m.Data = &ExportRecord{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.OrgID = uint32(val)
			case "data.OrgName":
				if m.Data == nil {
					m.Data = &ExportRecord{}
				}
				m.Data.OrgName = vals[0]
			case "data.deletedAt":
				if m.Data == nil {
					m.Data = &ExportRecord{}
				}
				if m.Data.DeletedAt == nil {
					m.Data.DeletedAt = &timestamppb.Timestamp{}
				}
			case "data.deletedAt.seconds":
				if m.Data == nil {
					m.Data = &ExportRecord{}
				}
				if m.Data.DeletedAt == nil {
					m.Data.DeletedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.DeletedAt.Seconds = val
			case "data.deletedAt.nanos":
				if m.Data == nil {
					m.Data = &ExportRecord{}
				}
				if m.Data.DeletedAt == nil {
					m.Data.DeletedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.DeletedAt.Nanos = int32(val)
			case "data.creatorID":
				if m.Data == nil {
					m.Data = &ExportRecord{}
				}
				m.Data.CreatorID = vals[0]
			case "data.updaterID":
				if m.Data == nil {
					m.Data = &ExportRecord{}
				}
				m.Data.UpdaterID = vals[0]
			case "data.assetID":
				if m.Data == nil {
					m.Data = &ExportRecord{}
				}
				m.Data.AssetID = vals[0]
			case "data.assetName":
				if m.Data == nil {
					m.Data = &ExportRecord{}
				}
				m.Data.AssetName = vals[0]
			case "data.versionID":
				if m.Data == nil {
					m.Data = &ExportRecord{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.VersionID = uint32(val)
			case "data.swaggerVersion":
				if m.Data == nil {
					m.Data = &ExportRecord{}
				}
				m.Data.SwaggerVersion = vals[0]
			case "data.major":
				if m.Data == nil {
					m.Data = &ExportRecord{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.Major = uint32(val)
			case "data.minor":
				if m.Data == nil {
					m.Data = &ExportRecord{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.Minor = uint32(val)
			case "data.patch":
				if m.Data == nil {
					m.Data = &ExportRecord{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.Patch = uint32(val)
			case "data.specProtocol":
				if m.Data == nil {
					m.Data = &ExportRecord{}
				}
				m.Data.SpecProtocol = vals[0]
			case "data.valid":
				if m.Data == nil {
					m.Data = &ExportRecord{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Valid = val
			case "userIDs":
				m.UserIDs = vals
			}
		}
	}
	return nil
}

// ExportRecord implement urlenc.URLValuesUnmarshaler.
func (m *ExportRecord) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				m.Id = vals[0]
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.OrgID = uint32(val)
			case "OrgName":
				m.OrgName = vals[0]
			case "deletedAt":
				if m.DeletedAt == nil {
					m.DeletedAt = &timestamppb.Timestamp{}
				}
			case "deletedAt.seconds":
				if m.DeletedAt == nil {
					m.DeletedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.DeletedAt.Seconds = val
			case "deletedAt.nanos":
				if m.DeletedAt == nil {
					m.DeletedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.DeletedAt.Nanos = int32(val)
			case "creatorID":
				m.CreatorID = vals[0]
			case "updaterID":
				m.UpdaterID = vals[0]
			case "assetID":
				m.AssetID = vals[0]
			case "assetName":
				m.AssetName = vals[0]
			case "versionID":
				val, err := strconv.ParseUint(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.VersionID = uint32(val)
			case "swaggerVersion":
				m.SwaggerVersion = vals[0]
			case "major":
				val, err := strconv.ParseUint(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Major = uint32(val)
			case "minor":
				val, err := strconv.ParseUint(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Minor = uint32(val)
			case "patch":
				val, err := strconv.ParseUint(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Patch = uint32(val)
			case "specProtocol":
				m.SpecProtocol = vals[0]
			case "valid":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Valid = val
			}
		}
	}
	return nil
}

// ListExportRecordsReq implement urlenc.URLValuesUnmarshaler.
func (m *ListExportRecordsReq) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.PageNo = int32(val)
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.PageSize = int32(val)
			case "orderBy":
				m.OrderBy = vals[0]
			}
		}
	}
	return nil
}

// ListExportRecordsResp implement urlenc.URLValuesUnmarshaler.
func (m *ListExportRecordsResp) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &ListExportRecordsData{}
				}
			case "data.total":
				if m.Data == nil {
					m.Data = &ListExportRecordsData{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Total = val
			case "userIDs":
				m.UserIDs = vals
			}
		}
	}
	return nil
}

// ListExportRecordsData implement urlenc.URLValuesUnmarshaler.
func (m *ListExportRecordsData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// DeleteExportRecordReq implement urlenc.URLValuesUnmarshaler.
func (m *DeleteExportRecordReq) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				m.Id = vals[0]
			}
		}
	}
	return nil
}

// Empty implement urlenc.URLValuesUnmarshaler.
func (m *Empty) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}
