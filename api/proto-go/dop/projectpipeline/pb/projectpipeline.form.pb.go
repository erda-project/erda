// Code generated by protoc-gen-go-form. DO NOT EDIT.
// Source: projectpipeline.proto

package pb

import (
	json "encoding/json"
	url "net/url"
	strconv "strconv"
	strings "strings"

	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
	structpb "google.golang.org/protobuf/types/known/structpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/urlenc" package it is being compiled against.
var _ urlenc.URLValuesUnmarshaler = (*PipelineRunParam)(nil)
var _ urlenc.URLValuesUnmarshaler = (*RunProjectPipelineRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*RunProjectPipelineResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*RerunProjectPipelineRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*RerunProjectPipelineResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*RerunFailedProjectPipelineRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*RerunFailedProjectPipelineResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CancelProjectPipelineRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CancelProjectPipelineResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateProjectPipelineSourcePreCheckRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateProjectPipelineSourcePreCheckResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateProjectPipelineNamePreCheckRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateProjectPipelineNamePreCheckResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListAppPipelineYmlRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineYmlList)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListAppPipelineYmlResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListAppRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListAppResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*Application)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateProjectPipelineRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateProjectPipelineResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProjectPipeline)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListPipelineCategoryRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListPipelineCategoryResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineCategory)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateProjectPipelineRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateProjectPipelineResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*OneClickCreateProjectPipelineRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*OneClickCreateProjectPipelineResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProjectPipelineSource)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GittarPushPayloadEvent)(nil)
var _ urlenc.URLValuesUnmarshaler = (*Content)(nil)
var _ urlenc.URLValuesUnmarshaler = (*Pusher)(nil)
var _ urlenc.URLValuesUnmarshaler = (*BatchCreateProjectPipelineResponse)(nil)

// PipelineRunParam implement urlenc.URLValuesUnmarshaler.
func (m *PipelineRunParam) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals[0]
			case "value":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Value = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Value = val
					} else {
						m.Value = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// RunProjectPipelineRequest implement urlenc.URLValuesUnmarshaler.
func (m *RunProjectPipelineRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pipelineDefinitionID":
				m.PipelineDefinitionID = vals[0]
			case "projectID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			}
		}
	}
	return nil
}

// RunProjectPipelineResponse implement urlenc.URLValuesUnmarshaler.
func (m *RunProjectPipelineResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pipeline":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Pipeline = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Pipeline = val
					} else {
						m.Pipeline = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// RerunProjectPipelineRequest implement urlenc.URLValuesUnmarshaler.
func (m *RerunProjectPipelineRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pipelineDefinitionID":
				m.PipelineDefinitionID = vals[0]
			case "projectID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			}
		}
	}
	return nil
}

// RerunProjectPipelineResponse implement urlenc.URLValuesUnmarshaler.
func (m *RerunProjectPipelineResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pipeline":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Pipeline = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Pipeline = val
					} else {
						m.Pipeline = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// RerunFailedProjectPipelineRequest implement urlenc.URLValuesUnmarshaler.
func (m *RerunFailedProjectPipelineRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pipelineDefinitionID":
				m.PipelineDefinitionID = vals[0]
			case "projectID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			}
		}
	}
	return nil
}

// RerunFailedProjectPipelineResponse implement urlenc.URLValuesUnmarshaler.
func (m *RerunFailedProjectPipelineResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pipeline":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Pipeline = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Pipeline = val
					} else {
						m.Pipeline = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// CancelProjectPipelineRequest implement urlenc.URLValuesUnmarshaler.
func (m *CancelProjectPipelineRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pipelineDefinitionID":
				m.PipelineDefinitionID = vals[0]
			case "projectID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			}
		}
	}
	return nil
}

// CancelProjectPipelineResponse implement urlenc.URLValuesUnmarshaler.
func (m *CancelProjectPipelineResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// CreateProjectPipelineSourcePreCheckRequest implement urlenc.URLValuesUnmarshaler.
func (m *CreateProjectPipelineSourcePreCheckRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			case "sourceType":
				m.SourceType = vals[0]
			case "ref":
				m.Ref = vals[0]
			case "path":
				m.Path = vals[0]
			case "fileName":
				m.FileName = vals[0]
			}
		}
	}
	return nil
}

// CreateProjectPipelineSourcePreCheckResponse implement urlenc.URLValuesUnmarshaler.
func (m *CreateProjectPipelineSourcePreCheckResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pass":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Pass = val
			case "message":
				m.Message = vals[0]
			}
		}
	}
	return nil
}

// CreateProjectPipelineNamePreCheckRequest implement urlenc.URLValuesUnmarshaler.
func (m *CreateProjectPipelineNamePreCheckRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "name":
				m.Name = vals[0]
			}
		}
	}
	return nil
}

// CreateProjectPipelineNamePreCheckResponse implement urlenc.URLValuesUnmarshaler.
func (m *CreateProjectPipelineNamePreCheckResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pass":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Pass = val
			case "message":
				m.Message = vals[0]
			}
		}
	}
	return nil
}

// ListAppPipelineYmlRequest implement urlenc.URLValuesUnmarshaler.
func (m *ListAppPipelineYmlRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			case "branch":
				m.Branch = vals[0]
			}
		}
	}
	return nil
}

// PipelineYmlList implement urlenc.URLValuesUnmarshaler.
func (m *PipelineYmlList) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ymlName":
				m.YmlName = vals[0]
			case "ymlPath":
				m.YmlPath = vals[0]
			}
		}
	}
	return nil
}

// ListAppPipelineYmlResponse implement urlenc.URLValuesUnmarshaler.
func (m *ListAppPipelineYmlResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// ListAppRequest implement urlenc.URLValuesUnmarshaler.
func (m *ListAppRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "name":
				m.Name = vals[0]
			}
		}
	}
	return nil
}

// ListAppResponse implement urlenc.URLValuesUnmarshaler.
func (m *ListAppResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// Application implement urlenc.URLValuesUnmarshaler.
func (m *Application) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ID = val
			case "name":
				m.Name = vals[0]
			case "displayName":
				m.DisplayName = vals[0]
			case "mode":
				m.Mode = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "logo":
				m.Logo = vals[0]
			case "isPublic":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsPublic = val
			case "creator":
				m.Creator = vals[0]
			case "gitRepo":
				m.GitRepo = vals[0]
			case "orgID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "orgDisplayName":
				m.OrgDisplayName = vals[0]
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "projectName":
				m.ProjectName = vals[0]
			case "isExternalRepo":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsExternalRepo = val
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			case "runningNum":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.RunningNum = val
			case "failedNum":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.FailedNum = val
			case "totalNum":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TotalNum = val
			}
		}
	}
	return nil
}

// CreateProjectPipelineRequest implement urlenc.URLValuesUnmarshaler.
func (m *CreateProjectPipelineRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "name":
				m.Name = vals[0]
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			case "sourceType":
				m.SourceType = vals[0]
			case "ref":
				m.Ref = vals[0]
			case "path":
				m.Path = vals[0]
			case "fileName":
				m.FileName = vals[0]
			}
		}
	}
	return nil
}

// CreateProjectPipelineResponse implement urlenc.URLValuesUnmarshaler.
func (m *CreateProjectPipelineResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ProjectPipeline":
				if m.ProjectPipeline == nil {
					m.ProjectPipeline = &ProjectPipeline{}
				}
			case "ProjectPipeline.ID":
				if m.ProjectPipeline == nil {
					m.ProjectPipeline = &ProjectPipeline{}
				}
				m.ProjectPipeline.ID = vals[0]
			case "ProjectPipeline.name":
				if m.ProjectPipeline == nil {
					m.ProjectPipeline = &ProjectPipeline{}
				}
				m.ProjectPipeline.Name = vals[0]
			case "ProjectPipeline.creator":
				if m.ProjectPipeline == nil {
					m.ProjectPipeline = &ProjectPipeline{}
				}
				m.ProjectPipeline.Creator = vals[0]
			case "ProjectPipeline.category":
				if m.ProjectPipeline == nil {
					m.ProjectPipeline = &ProjectPipeline{}
				}
				m.ProjectPipeline.Category = vals[0]
			case "ProjectPipeline.timeCreated":
				if m.ProjectPipeline == nil {
					m.ProjectPipeline = &ProjectPipeline{}
				}
				if m.ProjectPipeline.TimeCreated == nil {
					m.ProjectPipeline.TimeCreated = &timestamppb.Timestamp{}
				}
			case "ProjectPipeline.timeCreated.seconds":
				if m.ProjectPipeline == nil {
					m.ProjectPipeline = &ProjectPipeline{}
				}
				if m.ProjectPipeline.TimeCreated == nil {
					m.ProjectPipeline.TimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectPipeline.TimeCreated.Seconds = val
			case "ProjectPipeline.timeCreated.nanos":
				if m.ProjectPipeline == nil {
					m.ProjectPipeline = &ProjectPipeline{}
				}
				if m.ProjectPipeline.TimeCreated == nil {
					m.ProjectPipeline.TimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.ProjectPipeline.TimeCreated.Nanos = int32(val)
			case "ProjectPipeline.timeUpdated":
				if m.ProjectPipeline == nil {
					m.ProjectPipeline = &ProjectPipeline{}
				}
				if m.ProjectPipeline.TimeUpdated == nil {
					m.ProjectPipeline.TimeUpdated = &timestamppb.Timestamp{}
				}
			case "ProjectPipeline.timeUpdated.seconds":
				if m.ProjectPipeline == nil {
					m.ProjectPipeline = &ProjectPipeline{}
				}
				if m.ProjectPipeline.TimeUpdated == nil {
					m.ProjectPipeline.TimeUpdated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectPipeline.TimeUpdated.Seconds = val
			case "ProjectPipeline.timeUpdated.nanos":
				if m.ProjectPipeline == nil {
					m.ProjectPipeline = &ProjectPipeline{}
				}
				if m.ProjectPipeline.TimeUpdated == nil {
					m.ProjectPipeline.TimeUpdated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.ProjectPipeline.TimeUpdated.Nanos = int32(val)
			case "ProjectPipeline.sourceType":
				if m.ProjectPipeline == nil {
					m.ProjectPipeline = &ProjectPipeline{}
				}
				m.ProjectPipeline.SourceType = vals[0]
			case "ProjectPipeline.remote":
				if m.ProjectPipeline == nil {
					m.ProjectPipeline = &ProjectPipeline{}
				}
				m.ProjectPipeline.Remote = vals[0]
			case "ProjectPipeline.ref":
				if m.ProjectPipeline == nil {
					m.ProjectPipeline = &ProjectPipeline{}
				}
				m.ProjectPipeline.Ref = vals[0]
			case "ProjectPipeline.path":
				if m.ProjectPipeline == nil {
					m.ProjectPipeline = &ProjectPipeline{}
				}
				m.ProjectPipeline.Path = vals[0]
			case "ProjectPipeline.fileName":
				if m.ProjectPipeline == nil {
					m.ProjectPipeline = &ProjectPipeline{}
				}
				m.ProjectPipeline.FileName = vals[0]
			case "ProjectPipeline.pipelineSourceID":
				if m.ProjectPipeline == nil {
					m.ProjectPipeline = &ProjectPipeline{}
				}
				m.ProjectPipeline.PipelineSourceID = vals[0]
			}
		}
	}
	return nil
}

// ProjectPipeline implement urlenc.URLValuesUnmarshaler.
func (m *ProjectPipeline) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				m.ID = vals[0]
			case "name":
				m.Name = vals[0]
			case "creator":
				m.Creator = vals[0]
			case "category":
				m.Category = vals[0]
			case "timeCreated":
				if m.TimeCreated == nil {
					m.TimeCreated = &timestamppb.Timestamp{}
				}
			case "timeCreated.seconds":
				if m.TimeCreated == nil {
					m.TimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TimeCreated.Seconds = val
			case "timeCreated.nanos":
				if m.TimeCreated == nil {
					m.TimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.TimeCreated.Nanos = int32(val)
			case "timeUpdated":
				if m.TimeUpdated == nil {
					m.TimeUpdated = &timestamppb.Timestamp{}
				}
			case "timeUpdated.seconds":
				if m.TimeUpdated == nil {
					m.TimeUpdated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TimeUpdated.Seconds = val
			case "timeUpdated.nanos":
				if m.TimeUpdated == nil {
					m.TimeUpdated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.TimeUpdated.Nanos = int32(val)
			case "sourceType":
				m.SourceType = vals[0]
			case "remote":
				m.Remote = vals[0]
			case "ref":
				m.Ref = vals[0]
			case "path":
				m.Path = vals[0]
			case "fileName":
				m.FileName = vals[0]
			case "pipelineSourceID":
				m.PipelineSourceID = vals[0]
			}
		}
	}
	return nil
}

// ListPipelineCategoryRequest implement urlenc.URLValuesUnmarshaler.
func (m *ListPipelineCategoryRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			}
		}
	}
	return nil
}

// ListPipelineCategoryResponse implement urlenc.URLValuesUnmarshaler.
func (m *ListPipelineCategoryResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// PipelineCategory implement urlenc.URLValuesUnmarshaler.
func (m *PipelineCategory) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "key":
				m.Key = vals[0]
			case "category":
				m.Category = vals[0]
			case "rules":
				m.Rules = vals
			case "runningNum":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.RunningNum = val
			case "failedNum":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.FailedNum = val
			case "totalNum":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TotalNum = val
			}
		}
	}
	return nil
}

// UpdateProjectPipelineRequest implement urlenc.URLValuesUnmarshaler.
func (m *UpdateProjectPipelineRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pipelineDefinitionID":
				m.PipelineDefinitionID = vals[0]
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "name":
				m.Name = vals[0]
			case "projectPipelineSource":
				if m.ProjectPipelineSource == nil {
					m.ProjectPipelineSource = &ProjectPipelineSource{}
				}
			case "projectPipelineSource.appID":
				if m.ProjectPipelineSource == nil {
					m.ProjectPipelineSource = &ProjectPipelineSource{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectPipelineSource.AppID = val
			case "projectPipelineSource.sourceType":
				if m.ProjectPipelineSource == nil {
					m.ProjectPipelineSource = &ProjectPipelineSource{}
				}
				m.ProjectPipelineSource.SourceType = vals[0]
			case "projectPipelineSource.ref":
				if m.ProjectPipelineSource == nil {
					m.ProjectPipelineSource = &ProjectPipelineSource{}
				}
				m.ProjectPipelineSource.Ref = vals[0]
			case "projectPipelineSource.path":
				if m.ProjectPipelineSource == nil {
					m.ProjectPipelineSource = &ProjectPipelineSource{}
				}
				m.ProjectPipelineSource.Path = vals[0]
			case "projectPipelineSource.fileName":
				if m.ProjectPipelineSource == nil {
					m.ProjectPipelineSource = &ProjectPipelineSource{}
				}
				m.ProjectPipelineSource.FileName = vals[0]
			}
		}
	}
	return nil
}

// UpdateProjectPipelineResponse implement urlenc.URLValuesUnmarshaler.
func (m *UpdateProjectPipelineResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ProjectPipeline":
				if m.ProjectPipeline == nil {
					m.ProjectPipeline = &ProjectPipeline{}
				}
			case "ProjectPipeline.ID":
				if m.ProjectPipeline == nil {
					m.ProjectPipeline = &ProjectPipeline{}
				}
				m.ProjectPipeline.ID = vals[0]
			case "ProjectPipeline.name":
				if m.ProjectPipeline == nil {
					m.ProjectPipeline = &ProjectPipeline{}
				}
				m.ProjectPipeline.Name = vals[0]
			case "ProjectPipeline.creator":
				if m.ProjectPipeline == nil {
					m.ProjectPipeline = &ProjectPipeline{}
				}
				m.ProjectPipeline.Creator = vals[0]
			case "ProjectPipeline.category":
				if m.ProjectPipeline == nil {
					m.ProjectPipeline = &ProjectPipeline{}
				}
				m.ProjectPipeline.Category = vals[0]
			case "ProjectPipeline.timeCreated":
				if m.ProjectPipeline == nil {
					m.ProjectPipeline = &ProjectPipeline{}
				}
				if m.ProjectPipeline.TimeCreated == nil {
					m.ProjectPipeline.TimeCreated = &timestamppb.Timestamp{}
				}
			case "ProjectPipeline.timeCreated.seconds":
				if m.ProjectPipeline == nil {
					m.ProjectPipeline = &ProjectPipeline{}
				}
				if m.ProjectPipeline.TimeCreated == nil {
					m.ProjectPipeline.TimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectPipeline.TimeCreated.Seconds = val
			case "ProjectPipeline.timeCreated.nanos":
				if m.ProjectPipeline == nil {
					m.ProjectPipeline = &ProjectPipeline{}
				}
				if m.ProjectPipeline.TimeCreated == nil {
					m.ProjectPipeline.TimeCreated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.ProjectPipeline.TimeCreated.Nanos = int32(val)
			case "ProjectPipeline.timeUpdated":
				if m.ProjectPipeline == nil {
					m.ProjectPipeline = &ProjectPipeline{}
				}
				if m.ProjectPipeline.TimeUpdated == nil {
					m.ProjectPipeline.TimeUpdated = &timestamppb.Timestamp{}
				}
			case "ProjectPipeline.timeUpdated.seconds":
				if m.ProjectPipeline == nil {
					m.ProjectPipeline = &ProjectPipeline{}
				}
				if m.ProjectPipeline.TimeUpdated == nil {
					m.ProjectPipeline.TimeUpdated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectPipeline.TimeUpdated.Seconds = val
			case "ProjectPipeline.timeUpdated.nanos":
				if m.ProjectPipeline == nil {
					m.ProjectPipeline = &ProjectPipeline{}
				}
				if m.ProjectPipeline.TimeUpdated == nil {
					m.ProjectPipeline.TimeUpdated = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.ProjectPipeline.TimeUpdated.Nanos = int32(val)
			case "ProjectPipeline.sourceType":
				if m.ProjectPipeline == nil {
					m.ProjectPipeline = &ProjectPipeline{}
				}
				m.ProjectPipeline.SourceType = vals[0]
			case "ProjectPipeline.remote":
				if m.ProjectPipeline == nil {
					m.ProjectPipeline = &ProjectPipeline{}
				}
				m.ProjectPipeline.Remote = vals[0]
			case "ProjectPipeline.ref":
				if m.ProjectPipeline == nil {
					m.ProjectPipeline = &ProjectPipeline{}
				}
				m.ProjectPipeline.Ref = vals[0]
			case "ProjectPipeline.path":
				if m.ProjectPipeline == nil {
					m.ProjectPipeline = &ProjectPipeline{}
				}
				m.ProjectPipeline.Path = vals[0]
			case "ProjectPipeline.fileName":
				if m.ProjectPipeline == nil {
					m.ProjectPipeline = &ProjectPipeline{}
				}
				m.ProjectPipeline.FileName = vals[0]
			case "ProjectPipeline.pipelineSourceID":
				if m.ProjectPipeline == nil {
					m.ProjectPipeline = &ProjectPipeline{}
				}
				m.ProjectPipeline.PipelineSourceID = vals[0]
			}
		}
	}
	return nil
}

// OneClickCreateProjectPipelineRequest implement urlenc.URLValuesUnmarshaler.
func (m *OneClickCreateProjectPipelineRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			case "sourceType":
				m.SourceType = vals[0]
			case "ref":
				m.Ref = vals[0]
			case "pipelineYmls":
				m.PipelineYmls = vals
			}
		}
	}
	return nil
}

// OneClickCreateProjectPipelineResponse implement urlenc.URLValuesUnmarshaler.
func (m *OneClickCreateProjectPipelineResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "errMsg":
				m.ErrMsg = vals[0]
			}
		}
	}
	return nil
}

// ProjectPipelineSource implement urlenc.URLValuesUnmarshaler.
func (m *ProjectPipelineSource) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			case "sourceType":
				m.SourceType = vals[0]
			case "ref":
				m.Ref = vals[0]
			case "path":
				m.Path = vals[0]
			case "fileName":
				m.FileName = vals[0]
			}
		}
	}
	return nil
}

// GittarPushPayloadEvent implement urlenc.URLValuesUnmarshaler.
func (m *GittarPushPayloadEvent) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "event":
				m.Event = vals[0]
			case "action":
				m.Action = vals[0]
			case "orgID":
				m.OrgID = vals[0]
			case "projectID":
				m.ProjectID = vals[0]
			case "applicationID":
				m.ApplicationID = vals[0]
			case "env":
				m.Env = vals[0]
			case "timeStamp":
				m.TimeStamp = vals[0]
			case "content":
				if m.Content == nil {
					m.Content = &Content{}
				}
			case "content.ref":
				if m.Content == nil {
					m.Content = &Content{}
				}
				m.Content.Ref = vals[0]
			case "content.after":
				if m.Content == nil {
					m.Content = &Content{}
				}
				m.Content.After = vals[0]
			case "content.before":
				if m.Content == nil {
					m.Content = &Content{}
				}
				m.Content.Before = vals[0]
			case "content.pusher":
				if m.Content == nil {
					m.Content = &Content{}
				}
				if m.Content.Pusher == nil {
					m.Content.Pusher = &Pusher{}
				}
			case "content.pusher.ID":
				if m.Content == nil {
					m.Content = &Content{}
				}
				if m.Content.Pusher == nil {
					m.Content.Pusher = &Pusher{}
				}
				m.Content.Pusher.ID = vals[0]
			case "content.pusher.name":
				if m.Content == nil {
					m.Content = &Content{}
				}
				if m.Content.Pusher == nil {
					m.Content.Pusher = &Pusher{}
				}
				m.Content.Pusher.Name = vals[0]
			case "content.pusher.nickName":
				if m.Content == nil {
					m.Content = &Content{}
				}
				if m.Content.Pusher == nil {
					m.Content.Pusher = &Pusher{}
				}
				m.Content.Pusher.NickName = vals[0]
			case "content.pusher.email":
				if m.Content == nil {
					m.Content = &Content{}
				}
				if m.Content.Pusher == nil {
					m.Content.Pusher = &Pusher{}
				}
				m.Content.Pusher.Email = vals[0]
			}
		}
	}
	return nil
}

// Content implement urlenc.URLValuesUnmarshaler.
func (m *Content) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ref":
				m.Ref = vals[0]
			case "after":
				m.After = vals[0]
			case "before":
				m.Before = vals[0]
			case "pusher":
				if m.Pusher == nil {
					m.Pusher = &Pusher{}
				}
			case "pusher.ID":
				if m.Pusher == nil {
					m.Pusher = &Pusher{}
				}
				m.Pusher.ID = vals[0]
			case "pusher.name":
				if m.Pusher == nil {
					m.Pusher = &Pusher{}
				}
				m.Pusher.Name = vals[0]
			case "pusher.nickName":
				if m.Pusher == nil {
					m.Pusher = &Pusher{}
				}
				m.Pusher.NickName = vals[0]
			case "pusher.email":
				if m.Pusher == nil {
					m.Pusher = &Pusher{}
				}
				m.Pusher.Email = vals[0]
			}
		}
	}
	return nil
}

// Pusher implement urlenc.URLValuesUnmarshaler.
func (m *Pusher) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ID":
				m.ID = vals[0]
			case "name":
				m.Name = vals[0]
			case "nickName":
				m.NickName = vals[0]
			case "email":
				m.Email = vals[0]
			}
		}
	}
	return nil
}

// BatchCreateProjectPipelineResponse implement urlenc.URLValuesUnmarshaler.
func (m *BatchCreateProjectPipelineResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}
