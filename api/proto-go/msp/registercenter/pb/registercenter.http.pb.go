// Code generated by protoc-gen-go-http. DO NOT EDIT.
// Source: registercenter.proto

package pb

import (
	context "context"
	http1 "net/http"
	strings "strings"

	transport "github.com/erda-project/erda-infra/pkg/transport"
	http "github.com/erda-project/erda-infra/pkg/transport/http"
	httprule "github.com/erda-project/erda-infra/pkg/transport/http/httprule"
	runtime "github.com/erda-project/erda-infra/pkg/transport/http/runtime"
	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/transport/http" package it is being compiled against.
const _ = http.SupportPackageIsVersion1

// RegisterCenterServiceHandler is the server API for RegisterCenterService service.
type RegisterCenterServiceHandler interface {
	// GET /api/msp/register/interfaces/{projectID}/{env}
	ListInterface(context.Context, *ListInterfaceRequest) (*ListInterfaceResponse, error)
	// GET /api/msp/register/http-interfaces/{projectID}/{env}
	GetHTTPServices(context.Context, *GetHTTPServicesRequest) (*GetHTTPServicesResponse, error)
	// POST /api/msp/register/http-interfaces/{projectID}/{env}/enable
	EnableHTTPService(context.Context, *EnableHTTPServiceRequest) (*EnableHTTPServiceResponse, error)
	// GET /api/msp/register/service-ip
	GetServiceIpInfo(context.Context, *ServiceIpRequest) (*ServiceIpInfoResponse, error)
	// +depracated
	// GET /api/msp/mesh/interface/route/{interfaceName}/{projectID}/{env}
	GetRouteRule(context.Context, *GetRouteRuleRequest) (*GetRouteRuleResponse, error)
	// +depracated
	// POST /api/msp/mesh/interface/route/{interfaceName}/{projectID}/{env}
	CreateRouteRule(context.Context, *CreateRouteRuleRequest) (*CreateRouteRuleResponse, error)
	// +depracated
	// DELETE /api/msp/mesh/interface/route/{interfaceName}/{projectID}/{env}
	DeleteRouteRule(context.Context, *DeleteRouteRuleRequest) (*DeleteRouteRuleResponse, error)
	// +depracated
	// GET /api/msp/mesh/rule/branch/{projectID}/{env}/{appID}
	GetHostRule(context.Context, *CetHostRuleRequest) (*CetHostRuleResponse, error)
	// +depracated
	// POST /api/msp/mesh/rule/branch/{projectID}/{env}/{appID}
	CreateHostRule(context.Context, *CreateHostRuleRequest) (*CreateHostRuleResponse, error)
	// +depracated
	// DELETE /api/msp/mesh/rule/branch/{projectID}/{env}/{appID}
	DeleteHostRule(context.Context, *DeleteHostRuleRequest) (*DeleteHostRuleResponse, error)
	// +depracated
	// GET /api/msp/mesh/rule/host/{projectID}/{env}/{host}
	GetHostRuntimeRule(context.Context, *GetHostRuntimeRuleRequest) (*GetHostRuntimeRuleResponse, error)
	// +depracated
	// POST /api/msp/mesh/rule/host/{projectID}/{env}/{host}
	CreateHostRuntimeRule(context.Context, *CreateHostRuntimeRuleRequest) (*CreateHostRuntimeRuleResponse, error)
	// +depracated
	// GET /api/msp/mesh/listhostinterface/{projectID}/{env}
	GetAllHostRuntimeRules(context.Context, *GetAllHostRuntimeRulesRequest) (*GetAllHostRuntimeRulesResponse, error)
	// +depracated
	// GET /api/msp/mesh/timestamp/{interfaceName}/{projectID}/{env}
	GetDubboInterfaceTime(context.Context, *GetDubboInterfaceTimeRequest) (*GetDubboInterfaceTimeResponse, error)
	// +depracated
	// GET /api/msp/mesh/qps/{interfaceName}/{projectID}/{env}
	GetDubboInterfaceQPS(context.Context, *GetDubboInterfaceQPSRequest) (*GetDubboInterfaceQPSResponse, error)
	// +depracated
	// GET /api/msp/mesh/failed/{interfaceName}/{projectID}/{env}
	GetDubboInterfaceFailed(context.Context, *GetDubboInterfaceFailedRequest) (*GetDubboInterfaceFailedResponse, error)
	// +depracated
	// GET /api/msp/mesh/avgtime/{interfaceName}/{projectID}/{env}
	GetDubboInterfaceAvgTime(context.Context, *GetDubboInterfaceAvgTimeRequest) (*GetDubboInterfaceAvgTimeResponse, error)
}

// RegisterRegisterCenterServiceHandler register RegisterCenterServiceHandler to http.Router.
func RegisterRegisterCenterServiceHandler(r http.Router, srv RegisterCenterServiceHandler, opts ...http.HandleOption) {
	h := http.DefaultHandleOptions()
	for _, op := range opts {
		op(h)
	}
	encodeFunc := func(fn func(http1.ResponseWriter, *http1.Request) (interface{}, error)) http.HandlerFunc {
		handler := func(w http1.ResponseWriter, r *http1.Request) {
			out, err := fn(w, r)
			if err != nil {
				h.Error(w, r, err)
				return
			}
			if err := h.Encode(w, r, out); err != nil {
				h.Error(w, r, err)
			}
		}
		if h.HTTPInterceptor != nil {
			handler = h.HTTPInterceptor(handler)
		}
		return handler
	}

	add_ListInterface := func(method, path string, fn func(context.Context, *ListInterfaceRequest) (*ListInterfaceResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ListInterfaceRequest))
		}
		var ListInterface_info transport.ServiceInfo
		if h.Interceptor != nil {
			ListInterface_info = transport.NewServiceInfo("erda.msp.registercenter.RegisterCenterService", "ListInterface", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ListInterface_info)
				}
				r = r.WithContext(ctx)
				var in ListInterfaceRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				params := r.URL.Query()
				if vals := params["appid"]; len(vals) > 0 {
					in.AppID = vals[0]
				}
				if vals := params["az"]; len(vals) > 0 {
					in.ClusterName = vals[0]
				}
				if vals := params["runtimeId"]; len(vals) > 0 {
					in.RuntimeID = vals[0]
				}
				if vals := params["tenantId"]; len(vals) > 0 {
					in.TenantID = vals[0]
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "projectID":
							in.ProjectID = val
						case "env":
							in.Env = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetHTTPServices := func(method, path string, fn func(context.Context, *GetHTTPServicesRequest) (*GetHTTPServicesResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetHTTPServicesRequest))
		}
		var GetHTTPServices_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetHTTPServices_info = transport.NewServiceInfo("erda.msp.registercenter.RegisterCenterService", "GetHTTPServices", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetHTTPServices_info)
				}
				r = r.WithContext(ctx)
				var in GetHTTPServicesRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				params := r.URL.Query()
				if vals := params["appid"]; len(vals) > 0 {
					in.AppID = vals[0]
				}
				if vals := params["az"]; len(vals) > 0 {
					in.ClusterName = vals[0]
				}
				if vals := params["nacosId"]; len(vals) > 0 {
					in.NacosID = vals[0]
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "projectID":
							in.ProjectID = val
						case "env":
							in.Env = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_EnableHTTPService := func(method, path string, fn func(context.Context, *EnableHTTPServiceRequest) (*EnableHTTPServiceResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*EnableHTTPServiceRequest))
		}
		var EnableHTTPService_info transport.ServiceInfo
		if h.Interceptor != nil {
			EnableHTTPService_info = transport.NewServiceInfo("erda.msp.registercenter.RegisterCenterService", "EnableHTTPService", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, EnableHTTPService_info)
				}
				r = r.WithContext(ctx)
				var in EnableHTTPServiceRequest
				if err := h.Decode(r, &in.Service); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				params := r.URL.Query()
				if vals := params["az"]; len(vals) > 0 {
					in.ClusterName = vals[0]
				}
				if vals := params["nacosId"]; len(vals) > 0 {
					in.NacosID = vals[0]
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "projectID":
							in.ProjectID = val
						case "env":
							in.Env = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetServiceIpInfo := func(method, path string, fn func(context.Context, *ServiceIpRequest) (*ServiceIpInfoResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ServiceIpRequest))
		}
		var GetServiceIpInfo_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetServiceIpInfo_info = transport.NewServiceInfo("erda.msp.registercenter.RegisterCenterService", "GetServiceIpInfo", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetServiceIpInfo_info)
				}
				r = r.WithContext(ctx)
				var in ServiceIpRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetRouteRule := func(method, path string, fn func(context.Context, *GetRouteRuleRequest) (*GetRouteRuleResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetRouteRuleRequest))
		}
		var GetRouteRule_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetRouteRule_info = transport.NewServiceInfo("erda.msp.registercenter.RegisterCenterService", "GetRouteRule", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetRouteRule_info)
				}
				r = r.WithContext(ctx)
				var in GetRouteRuleRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				params := r.URL.Query()
				if vals := params["appid"]; len(vals) > 0 {
					in.AppID = vals[0]
				}
				if vals := params["az"]; len(vals) > 0 {
					in.ClusterName = vals[0]
				}
				if vals := params["runtimeId"]; len(vals) > 0 {
					in.RuntimeID = vals[0]
				}
				if vals := params["tenantId"]; len(vals) > 0 {
					in.TenantID = vals[0]
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "interfaceName":
							in.InterfaceName = val
						case "projectID":
							in.ProjectID = val
						case "env":
							in.Env = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CreateRouteRule := func(method, path string, fn func(context.Context, *CreateRouteRuleRequest) (*CreateRouteRuleResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateRouteRuleRequest))
		}
		var CreateRouteRule_info transport.ServiceInfo
		if h.Interceptor != nil {
			CreateRouteRule_info = transport.NewServiceInfo("erda.msp.registercenter.RegisterCenterService", "CreateRouteRule", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CreateRouteRule_info)
				}
				r = r.WithContext(ctx)
				var in CreateRouteRuleRequest
				if err := h.Decode(r, &in.Rule); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				params := r.URL.Query()
				if vals := params["appid"]; len(vals) > 0 {
					in.AppID = vals[0]
				}
				if vals := params["az"]; len(vals) > 0 {
					in.ClusterName = vals[0]
				}
				if vals := params["runtimeId"]; len(vals) > 0 {
					in.RuntimeID = vals[0]
				}
				if vals := params["tenantId"]; len(vals) > 0 {
					in.TenantID = vals[0]
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "interfaceName":
							in.InterfaceName = val
						case "projectID":
							in.ProjectID = val
						case "env":
							in.Env = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_DeleteRouteRule := func(method, path string, fn func(context.Context, *DeleteRouteRuleRequest) (*DeleteRouteRuleResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DeleteRouteRuleRequest))
		}
		var DeleteRouteRule_info transport.ServiceInfo
		if h.Interceptor != nil {
			DeleteRouteRule_info = transport.NewServiceInfo("erda.msp.registercenter.RegisterCenterService", "DeleteRouteRule", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, DeleteRouteRule_info)
				}
				r = r.WithContext(ctx)
				var in DeleteRouteRuleRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				params := r.URL.Query()
				if vals := params["appid"]; len(vals) > 0 {
					in.AppID = vals[0]
				}
				if vals := params["az"]; len(vals) > 0 {
					in.ClusterName = vals[0]
				}
				if vals := params["runtimeId"]; len(vals) > 0 {
					in.RuntimeID = vals[0]
				}
				if vals := params["tenantId"]; len(vals) > 0 {
					in.TenantID = vals[0]
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "interfaceName":
							in.InterfaceName = val
						case "projectID":
							in.ProjectID = val
						case "env":
							in.Env = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetHostRule := func(method, path string, fn func(context.Context, *CetHostRuleRequest) (*CetHostRuleResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CetHostRuleRequest))
		}
		var GetHostRule_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetHostRule_info = transport.NewServiceInfo("erda.msp.registercenter.RegisterCenterService", "GetHostRule", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetHostRule_info)
				}
				r = r.WithContext(ctx)
				var in CetHostRuleRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				params := r.URL.Query()
				if vals := params["az"]; len(vals) > 0 {
					in.ClusterName = vals[0]
				}
				if vals := params["runtimeId"]; len(vals) > 0 {
					in.RuntimeID = vals[0]
				}
				if vals := params["tenantId"]; len(vals) > 0 {
					in.TenantID = vals[0]
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "projectID":
							in.ProjectID = val
						case "env":
							in.Env = val
						case "appID":
							in.AppID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CreateHostRule := func(method, path string, fn func(context.Context, *CreateHostRuleRequest) (*CreateHostRuleResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateHostRuleRequest))
		}
		var CreateHostRule_info transport.ServiceInfo
		if h.Interceptor != nil {
			CreateHostRule_info = transport.NewServiceInfo("erda.msp.registercenter.RegisterCenterService", "CreateHostRule", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CreateHostRule_info)
				}
				r = r.WithContext(ctx)
				var in CreateHostRuleRequest
				if err := h.Decode(r, &in.Rules); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				params := r.URL.Query()
				if vals := params["az"]; len(vals) > 0 {
					in.ClusterName = vals[0]
				}
				if vals := params["runtimeId"]; len(vals) > 0 {
					in.RuntimeID = vals[0]
				}
				if vals := params["tenantId"]; len(vals) > 0 {
					in.TenantID = vals[0]
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "projectID":
							in.ProjectID = val
						case "env":
							in.Env = val
						case "appID":
							in.AppID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_DeleteHostRule := func(method, path string, fn func(context.Context, *DeleteHostRuleRequest) (*DeleteHostRuleResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DeleteHostRuleRequest))
		}
		var DeleteHostRule_info transport.ServiceInfo
		if h.Interceptor != nil {
			DeleteHostRule_info = transport.NewServiceInfo("erda.msp.registercenter.RegisterCenterService", "DeleteHostRule", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, DeleteHostRule_info)
				}
				r = r.WithContext(ctx)
				var in DeleteHostRuleRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				params := r.URL.Query()
				if vals := params["az"]; len(vals) > 0 {
					in.ClusterName = vals[0]
				}
				if vals := params["runtimeId"]; len(vals) > 0 {
					in.RuntimeID = vals[0]
				}
				if vals := params["tenantId"]; len(vals) > 0 {
					in.TenantID = vals[0]
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "projectID":
							in.ProjectID = val
						case "env":
							in.Env = val
						case "appID":
							in.AppID = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetHostRuntimeRule := func(method, path string, fn func(context.Context, *GetHostRuntimeRuleRequest) (*GetHostRuntimeRuleResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetHostRuntimeRuleRequest))
		}
		var GetHostRuntimeRule_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetHostRuntimeRule_info = transport.NewServiceInfo("erda.msp.registercenter.RegisterCenterService", "GetHostRuntimeRule", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetHostRuntimeRule_info)
				}
				r = r.WithContext(ctx)
				var in GetHostRuntimeRuleRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				params := r.URL.Query()
				if vals := params["az"]; len(vals) > 0 {
					in.ClusterName = vals[0]
				}
				if vals := params["runtimeId"]; len(vals) > 0 {
					in.RuntimeID = vals[0]
				}
				if vals := params["tenantId"]; len(vals) > 0 {
					in.TenantID = vals[0]
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "projectID":
							in.ProjectID = val
						case "env":
							in.Env = val
						case "host":
							in.Host = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CreateHostRuntimeRule := func(method, path string, fn func(context.Context, *CreateHostRuntimeRuleRequest) (*CreateHostRuntimeRuleResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateHostRuntimeRuleRequest))
		}
		var CreateHostRuntimeRule_info transport.ServiceInfo
		if h.Interceptor != nil {
			CreateHostRuntimeRule_info = transport.NewServiceInfo("erda.msp.registercenter.RegisterCenterService", "CreateHostRuntimeRule", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CreateHostRuntimeRule_info)
				}
				r = r.WithContext(ctx)
				var in CreateHostRuntimeRuleRequest
				if err := h.Decode(r, &in.Rules); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				params := r.URL.Query()
				if vals := params["az"]; len(vals) > 0 {
					in.ClusterName = vals[0]
				}
				if vals := params["runtimeId"]; len(vals) > 0 {
					in.RuntimeID = vals[0]
				}
				if vals := params["tenantId"]; len(vals) > 0 {
					in.TenantID = vals[0]
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "projectID":
							in.ProjectID = val
						case "env":
							in.Env = val
						case "host":
							in.Host = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetAllHostRuntimeRules := func(method, path string, fn func(context.Context, *GetAllHostRuntimeRulesRequest) (*GetAllHostRuntimeRulesResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetAllHostRuntimeRulesRequest))
		}
		var GetAllHostRuntimeRules_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetAllHostRuntimeRules_info = transport.NewServiceInfo("erda.msp.registercenter.RegisterCenterService", "GetAllHostRuntimeRules", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetAllHostRuntimeRules_info)
				}
				r = r.WithContext(ctx)
				var in GetAllHostRuntimeRulesRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				params := r.URL.Query()
				if vals := params["appid"]; len(vals) > 0 {
					in.AppID = vals[0]
				}
				if vals := params["az"]; len(vals) > 0 {
					in.ClusterName = vals[0]
				}
				if vals := params["runtimeId"]; len(vals) > 0 {
					in.RuntimeID = vals[0]
				}
				if vals := params["tenantId"]; len(vals) > 0 {
					in.TenantID = vals[0]
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "projectID":
							in.ProjectID = val
						case "env":
							in.Env = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetDubboInterfaceTime := func(method, path string, fn func(context.Context, *GetDubboInterfaceTimeRequest) (*GetDubboInterfaceTimeResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetDubboInterfaceTimeRequest))
		}
		var GetDubboInterfaceTime_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetDubboInterfaceTime_info = transport.NewServiceInfo("erda.msp.registercenter.RegisterCenterService", "GetDubboInterfaceTime", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetDubboInterfaceTime_info)
				}
				r = r.WithContext(ctx)
				var in GetDubboInterfaceTimeRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				params := r.URL.Query()
				if vals := params["appid"]; len(vals) > 0 {
					in.AppID = vals[0]
				}
				if vals := params["az"]; len(vals) > 0 {
					in.ClusterName = vals[0]
				}
				if vals := params["tenantId"]; len(vals) > 0 {
					in.TenantID = vals[0]
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "interfaceName":
							in.InterfaceName = val
						case "projectID":
							in.ProjectID = val
						case "env":
							in.Env = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetDubboInterfaceQPS := func(method, path string, fn func(context.Context, *GetDubboInterfaceQPSRequest) (*GetDubboInterfaceQPSResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetDubboInterfaceQPSRequest))
		}
		var GetDubboInterfaceQPS_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetDubboInterfaceQPS_info = transport.NewServiceInfo("erda.msp.registercenter.RegisterCenterService", "GetDubboInterfaceQPS", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetDubboInterfaceQPS_info)
				}
				r = r.WithContext(ctx)
				var in GetDubboInterfaceQPSRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				params := r.URL.Query()
				if vals := params["appid"]; len(vals) > 0 {
					in.AppID = vals[0]
				}
				if vals := params["az"]; len(vals) > 0 {
					in.ClusterName = vals[0]
				}
				if vals := params["tenantId"]; len(vals) > 0 {
					in.TenantID = vals[0]
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "interfaceName":
							in.InterfaceName = val
						case "projectID":
							in.ProjectID = val
						case "env":
							in.Env = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetDubboInterfaceFailed := func(method, path string, fn func(context.Context, *GetDubboInterfaceFailedRequest) (*GetDubboInterfaceFailedResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetDubboInterfaceFailedRequest))
		}
		var GetDubboInterfaceFailed_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetDubboInterfaceFailed_info = transport.NewServiceInfo("erda.msp.registercenter.RegisterCenterService", "GetDubboInterfaceFailed", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetDubboInterfaceFailed_info)
				}
				r = r.WithContext(ctx)
				var in GetDubboInterfaceFailedRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				params := r.URL.Query()
				if vals := params["appid"]; len(vals) > 0 {
					in.AppID = vals[0]
				}
				if vals := params["az"]; len(vals) > 0 {
					in.ClusterName = vals[0]
				}
				if vals := params["tenantId"]; len(vals) > 0 {
					in.TenantID = vals[0]
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "interfaceName":
							in.InterfaceName = val
						case "projectID":
							in.ProjectID = val
						case "env":
							in.Env = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetDubboInterfaceAvgTime := func(method, path string, fn func(context.Context, *GetDubboInterfaceAvgTimeRequest) (*GetDubboInterfaceAvgTimeResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetDubboInterfaceAvgTimeRequest))
		}
		var GetDubboInterfaceAvgTime_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetDubboInterfaceAvgTime_info = transport.NewServiceInfo("erda.msp.registercenter.RegisterCenterService", "GetDubboInterfaceAvgTime", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetDubboInterfaceAvgTime_info)
				}
				r = r.WithContext(ctx)
				var in GetDubboInterfaceAvgTimeRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				params := r.URL.Query()
				if vals := params["appid"]; len(vals) > 0 {
					in.AppID = vals[0]
				}
				if vals := params["az"]; len(vals) > 0 {
					in.ClusterName = vals[0]
				}
				if vals := params["tenantId"]; len(vals) > 0 {
					in.TenantID = vals[0]
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "interfaceName":
							in.InterfaceName = val
						case "projectID":
							in.ProjectID = val
						case "env":
							in.Env = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ListInterface("GET", "/api/msp/register/interfaces/{projectID}/{env}", srv.ListInterface)
	add_GetHTTPServices("GET", "/api/msp/register/http-interfaces/{projectID}/{env}", srv.GetHTTPServices)
	add_EnableHTTPService("POST", "/api/msp/register/http-interfaces/{projectID}/{env}/enable", srv.EnableHTTPService)
	add_GetServiceIpInfo("GET", "/api/msp/register/service-ip", srv.GetServiceIpInfo)
	add_GetRouteRule("GET", "/api/msp/mesh/interface/route/{interfaceName}/{projectID}/{env}", srv.GetRouteRule)
	add_CreateRouteRule("POST", "/api/msp/mesh/interface/route/{interfaceName}/{projectID}/{env}", srv.CreateRouteRule)
	add_DeleteRouteRule("DELETE", "/api/msp/mesh/interface/route/{interfaceName}/{projectID}/{env}", srv.DeleteRouteRule)
	add_GetHostRule("GET", "/api/msp/mesh/rule/branch/{projectID}/{env}/{appID}", srv.GetHostRule)
	add_CreateHostRule("POST", "/api/msp/mesh/rule/branch/{projectID}/{env}/{appID}", srv.CreateHostRule)
	add_DeleteHostRule("DELETE", "/api/msp/mesh/rule/branch/{projectID}/{env}/{appID}", srv.DeleteHostRule)
	add_GetHostRuntimeRule("GET", "/api/msp/mesh/rule/host/{projectID}/{env}/{host}", srv.GetHostRuntimeRule)
	add_CreateHostRuntimeRule("POST", "/api/msp/mesh/rule/host/{projectID}/{env}/{host}", srv.CreateHostRuntimeRule)
	add_GetAllHostRuntimeRules("GET", "/api/msp/mesh/listhostinterface/{projectID}/{env}", srv.GetAllHostRuntimeRules)
	add_GetDubboInterfaceTime("GET", "/api/msp/mesh/timestamp/{interfaceName}/{projectID}/{env}", srv.GetDubboInterfaceTime)
	add_GetDubboInterfaceQPS("GET", "/api/msp/mesh/qps/{interfaceName}/{projectID}/{env}", srv.GetDubboInterfaceQPS)
	add_GetDubboInterfaceFailed("GET", "/api/msp/mesh/failed/{interfaceName}/{projectID}/{env}", srv.GetDubboInterfaceFailed)
	add_GetDubboInterfaceAvgTime("GET", "/api/msp/mesh/avgtime/{interfaceName}/{projectID}/{env}", srv.GetDubboInterfaceAvgTime)
}
