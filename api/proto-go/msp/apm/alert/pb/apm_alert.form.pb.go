// Code generated by protoc-gen-go-form. DO NOT EDIT.
// Source: apm_alert.proto

package pb

import (
	json "encoding/json"
	url "net/url"
	strconv "strconv"
	strings "strings"

	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
	pb "github.com/erda-project/erda-proto-go/core/monitor/alert/pb"
	structpb "google.golang.org/protobuf/types/known/structpb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/urlenc" package it is being compiled against.
var _ urlenc.URLValuesUnmarshaler = (*QueryAlertRuleRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryAlertRuleResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryAlertRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryAlertResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryAlertData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAlertRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAlertResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ApmAlertData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateAlertRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateAlertResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateAlertData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateAlertRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateAlertResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateAlertEnableRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateAlertEnableResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteAlertRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteAlertResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteAlertData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryCustomizeMetricRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryCustomizeMetricResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryCustomizeNotifyTargetRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryCustomizeNotifyTargetResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryCustomizeAlertsRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryCustomizeAlertsResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetCustomizeAlertRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetCustomizeAlertResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateCustomizeAlertRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateCustomizeAlertResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateCustomizeAlertData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateCustomizeAlertRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateCustomizeAlertResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateCustomizeAlertEnableRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateCustomizeAlertEnableResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteCustomizeAlertRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteCustomizeAlertResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteCustomizeAlertData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAlertRecordAttrsRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAlertRecordAttrsResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAlertRecordsRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAlertRecordsResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAlertRecordsData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAlertRecordRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAlertRecordResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAlertHistoriesRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAlertHistoriesResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateAlertRecordIssueRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateAlertRecordIssueResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateAlertRecordIssueRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateAlertRecordIssueResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DashboardPreviewRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DashboardPreviewResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAlertConditionsRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAlertConditionsResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAlertConditionsValueRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAlertConditionsValueResponse)(nil)

// QueryAlertRuleRequest implement urlenc.URLValuesUnmarshaler.
func (m *QueryAlertRuleRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "tenantGroup":
				m.TenantGroup = vals[0]
			}
		}
	}
	return nil
}

// QueryAlertRuleResponse implement urlenc.URLValuesUnmarshaler.
func (m *QueryAlertRuleResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &pb.AlertTypeRuleResp{}
				}
			case "data.windows":
				if m.Data == nil {
					m.Data = &pb.AlertTypeRuleResp{}
				}
				list := make([]int64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseInt(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.Data.Windows = list
			}
		}
	}
	return nil
}

// QueryAlertRequest implement urlenc.URLValuesUnmarshaler.
func (m *QueryAlertRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "tenantGroup":
				m.TenantGroup = vals[0]
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			case "name":
				m.Name = vals[0]
			}
		}
	}
	return nil
}

// QueryAlertResponse implement urlenc.URLValuesUnmarshaler.
func (m *QueryAlertResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &QueryAlertData{}
				}
			case "data.total":
				if m.Data == nil {
					m.Data = &QueryAlertData{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Total = val
			case "userIDs":
				m.UserIDs = vals
			}
		}
	}
	return nil
}

// QueryAlertData implement urlenc.URLValuesUnmarshaler.
func (m *QueryAlertData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// GetAlertRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetAlertRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "tenantGroup":
				m.TenantGroup = vals[0]
			case "id":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			}
		}
	}
	return nil
}

// GetAlertResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetAlertResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &ApmAlertData{}
				}
			case "data.id":
				if m.Data == nil {
					m.Data = &ApmAlertData{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Id = val
			case "data.name":
				if m.Data == nil {
					m.Data = &ApmAlertData{}
				}
				m.Data.Name = vals[0]
			case "data.alertScope":
				if m.Data == nil {
					m.Data = &ApmAlertData{}
				}
				m.Data.AlertScope = vals[0]
			case "data.alertScopeId":
				if m.Data == nil {
					m.Data = &ApmAlertData{}
				}
				m.Data.AlertScopeId = vals[0]
			case "data.enable":
				if m.Data == nil {
					m.Data = &ApmAlertData{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Enable = val
			case "data.appIds":
				if m.Data == nil {
					m.Data = &ApmAlertData{}
				}
				m.Data.AppIds = vals
			case "data.domain":
				if m.Data == nil {
					m.Data = &ApmAlertData{}
				}
				m.Data.Domain = vals[0]
			case "data.createTime":
				if m.Data == nil {
					m.Data = &ApmAlertData{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CreateTime = val
			case "data.updateTime":
				if m.Data == nil {
					m.Data = &ApmAlertData{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.UpdateTime = val
			case "data.creator":
				if m.Data == nil {
					m.Data = &ApmAlertData{}
				}
				m.Data.Creator = vals[0]
			case "data.ruleCount":
				if m.Data == nil {
					m.Data = &ApmAlertData{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.RuleCount = val
			}
		}
	}
	return nil
}

// ApmAlertData implement urlenc.URLValuesUnmarshaler.
func (m *ApmAlertData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "name":
				m.Name = vals[0]
			case "alertScope":
				m.AlertScope = vals[0]
			case "alertScopeId":
				m.AlertScopeId = vals[0]
			case "enable":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Enable = val
			case "appIds":
				m.AppIds = vals
			case "domain":
				m.Domain = vals[0]
			case "createTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreateTime = val
			case "updateTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdateTime = val
			case "creator":
				m.Creator = vals[0]
			case "ruleCount":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.RuleCount = val
			}
		}
	}
	return nil
}

// CreateAlertRequest implement urlenc.URLValuesUnmarshaler.
func (m *CreateAlertRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "tenantGroup":
				m.TenantGroup = vals[0]
			case "name":
				m.Name = vals[0]
			case "appIds":
				m.AppIds = vals
			case "domain":
				m.Domain = vals[0]
			case "createTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreateTime = val
			case "updateTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdateTime = val
			case "alertScope":
				m.AlertScope = vals[0]
			case "alertScopeId":
				m.AlertScopeId = vals[0]
			case "enable":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Enable = val
			}
		}
	}
	return nil
}

// CreateAlertResponse implement urlenc.URLValuesUnmarshaler.
func (m *CreateAlertResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &CreateAlertData{}
				}
			case "data.id":
				if m.Data == nil {
					m.Data = &CreateAlertData{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Id = val
			case "data.projectId":
				if m.Data == nil {
					m.Data = &CreateAlertData{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ProjectId = val
			}
		}
	}
	return nil
}

// CreateAlertData implement urlenc.URLValuesUnmarshaler.
func (m *CreateAlertData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "projectId":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectId = val
			}
		}
	}
	return nil
}

// UpdateAlertRequest implement urlenc.URLValuesUnmarshaler.
func (m *UpdateAlertRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "tenantGroup":
				m.TenantGroup = vals[0]
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "name":
				m.Name = vals[0]
			case "alertScope":
				m.AlertScope = vals[0]
			case "alertScopeId":
				m.AlertScopeId = vals[0]
			case "enable":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Enable = val
			case "appIds":
				m.AppIds = vals
			case "domain":
				m.Domain = vals[0]
			case "createTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreateTime = val
			case "updateTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdateTime = val
			}
		}
	}
	return nil
}

// UpdateAlertResponse implement urlenc.URLValuesUnmarshaler.
func (m *UpdateAlertResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// UpdateAlertEnableRequest implement urlenc.URLValuesUnmarshaler.
func (m *UpdateAlertEnableRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "tenantGroup":
				m.TenantGroup = vals[0]
			case "enable":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Enable = val
			}
		}
	}
	return nil
}

// UpdateAlertEnableResponse implement urlenc.URLValuesUnmarshaler.
func (m *UpdateAlertEnableResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// DeleteAlertRequest implement urlenc.URLValuesUnmarshaler.
func (m *DeleteAlertRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "tenantGroup":
				m.TenantGroup = vals[0]
			}
		}
	}
	return nil
}

// DeleteAlertResponse implement urlenc.URLValuesUnmarshaler.
func (m *DeleteAlertResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &DeleteAlertData{}
				}
			case "data.Name":
				if m.Data == nil {
					m.Data = &DeleteAlertData{}
				}
				m.Data.Name = vals[0]
			case "data.projectId":
				if m.Data == nil {
					m.Data = &DeleteAlertData{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ProjectId = val
			}
		}
	}
	return nil
}

// DeleteAlertData implement urlenc.URLValuesUnmarshaler.
func (m *DeleteAlertData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "Name":
				m.Name = vals[0]
			case "projectId":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectId = val
			}
		}
	}
	return nil
}

// QueryCustomizeMetricRequest implement urlenc.URLValuesUnmarshaler.
func (m *QueryCustomizeMetricRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "tenantGroup":
				m.TenantGroup = vals[0]
			}
		}
	}
	return nil
}

// QueryCustomizeMetricResponse implement urlenc.URLValuesUnmarshaler.
func (m *QueryCustomizeMetricResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &pb.CustomizeMetrics{}
				}
			case "data.notifySample":
				if m.Data == nil {
					m.Data = &pb.CustomizeMetrics{}
				}
				m.Data.NotifySample = vals[0]
			}
		}
	}
	return nil
}

// QueryCustomizeNotifyTargetRequest implement urlenc.URLValuesUnmarshaler.
func (m *QueryCustomizeNotifyTargetRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "tenantGroup":
				m.TenantGroup = vals[0]
			}
		}
	}
	return nil
}

// QueryCustomizeNotifyTargetResponse implement urlenc.URLValuesUnmarshaler.
func (m *QueryCustomizeNotifyTargetResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &pb.QueryCustomizeNotifyTargetData{}
				}
			}
		}
	}
	return nil
}

// QueryCustomizeAlertsRequest implement urlenc.URLValuesUnmarshaler.
func (m *QueryCustomizeAlertsRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "tenantGroup":
				m.TenantGroup = vals[0]
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			case "name":
				m.Name = vals[0]
			}
		}
	}
	return nil
}

// QueryCustomizeAlertsResponse implement urlenc.URLValuesUnmarshaler.
func (m *QueryCustomizeAlertsResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &pb.QueryCustomizeAlertData{}
				}
			case "data.total":
				if m.Data == nil {
					m.Data = &pb.QueryCustomizeAlertData{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Total = val
			case "userIDs":
				m.UserIDs = vals
			}
		}
	}
	return nil
}

// GetCustomizeAlertRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetCustomizeAlertRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "tenantGroup":
				m.TenantGroup = vals[0]
			}
		}
	}
	return nil
}

// GetCustomizeAlertResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetCustomizeAlertResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &pb.CustomizeAlertDetail{}
				}
			case "data.id":
				if m.Data == nil {
					m.Data = &pb.CustomizeAlertDetail{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Id = val
			case "data.clusterName":
				if m.Data == nil {
					m.Data = &pb.CustomizeAlertDetail{}
				}
				m.Data.ClusterName = vals[0]
			case "data.name":
				if m.Data == nil {
					m.Data = &pb.CustomizeAlertDetail{}
				}
				m.Data.Name = vals[0]
			case "data.alertType":
				if m.Data == nil {
					m.Data = &pb.CustomizeAlertDetail{}
				}
				m.Data.AlertType = vals[0]
			case "data.alertScope":
				if m.Data == nil {
					m.Data = &pb.CustomizeAlertDetail{}
				}
				m.Data.AlertScope = vals[0]
			case "data.alertScopeId":
				if m.Data == nil {
					m.Data = &pb.CustomizeAlertDetail{}
				}
				m.Data.AlertScopeId = vals[0]
			case "data.enable":
				if m.Data == nil {
					m.Data = &pb.CustomizeAlertDetail{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Enable = val
			case "data.createTime":
				if m.Data == nil {
					m.Data = &pb.CustomizeAlertDetail{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CreateTime = val
			case "data.updateTime":
				if m.Data == nil {
					m.Data = &pb.CustomizeAlertDetail{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.UpdateTime = val
			}
		}
	}
	return nil
}

// CreateCustomizeAlertRequest implement urlenc.URLValuesUnmarshaler.
func (m *CreateCustomizeAlertRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "tenantGroup":
				m.TenantGroup = vals[0]
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "clusterName":
				m.ClusterName = vals[0]
			case "name":
				m.Name = vals[0]
			case "alertType":
				m.AlertType = vals[0]
			case "alertScope":
				m.AlertScope = vals[0]
			case "alertScopeId":
				m.AlertScopeId = vals[0]
			case "enable":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Enable = val
			case "createTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreateTime = val
			case "updateTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdateTime = val
			}
		}
	}
	return nil
}

// CreateCustomizeAlertResponse implement urlenc.URLValuesUnmarshaler.
func (m *CreateCustomizeAlertResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &CreateCustomizeAlertData{}
				}
			case "data.id":
				if m.Data == nil {
					m.Data = &CreateCustomizeAlertData{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Id = val
			case "data.projectId":
				if m.Data == nil {
					m.Data = &CreateCustomizeAlertData{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ProjectId = val
			}
		}
	}
	return nil
}

// CreateCustomizeAlertData implement urlenc.URLValuesUnmarshaler.
func (m *CreateCustomizeAlertData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "projectId":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectId = val
			}
		}
	}
	return nil
}

// UpdateCustomizeAlertRequest implement urlenc.URLValuesUnmarshaler.
func (m *UpdateCustomizeAlertRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "tenantGroup":
				m.TenantGroup = vals[0]
			case "clusterName":
				m.ClusterName = vals[0]
			case "name":
				m.Name = vals[0]
			case "alertType":
				m.AlertType = vals[0]
			case "alertScope":
				m.AlertScope = vals[0]
			case "alertScopeId":
				m.AlertScopeId = vals[0]
			case "enable":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Enable = val
			case "createTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreateTime = val
			case "updateTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdateTime = val
			}
		}
	}
	return nil
}

// UpdateCustomizeAlertResponse implement urlenc.URLValuesUnmarshaler.
func (m *UpdateCustomizeAlertResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// UpdateCustomizeAlertEnableRequest implement urlenc.URLValuesUnmarshaler.
func (m *UpdateCustomizeAlertEnableRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "tenantGroup":
				m.TenantGroup = vals[0]
			case "enable":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Enable = val
			}
		}
	}
	return nil
}

// UpdateCustomizeAlertEnableResponse implement urlenc.URLValuesUnmarshaler.
func (m *UpdateCustomizeAlertEnableResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// DeleteCustomizeAlertRequest implement urlenc.URLValuesUnmarshaler.
func (m *DeleteCustomizeAlertRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "tenantGroup":
				m.TenantGroup = vals[0]
			}
		}
	}
	return nil
}

// DeleteCustomizeAlertResponse implement urlenc.URLValuesUnmarshaler.
func (m *DeleteCustomizeAlertResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &DeleteCustomizeAlertData{}
				}
			case "data.name":
				if m.Data == nil {
					m.Data = &DeleteCustomizeAlertData{}
				}
				m.Data.Name = vals[0]
			case "data.projectId":
				if m.Data == nil {
					m.Data = &DeleteCustomizeAlertData{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ProjectId = val
			}
		}
	}
	return nil
}

// DeleteCustomizeAlertData implement urlenc.URLValuesUnmarshaler.
func (m *DeleteCustomizeAlertData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals[0]
			case "projectId":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectId = val
			}
		}
	}
	return nil
}

// GetAlertRecordAttrsRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetAlertRecordAttrsRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "tenantGroup":
				m.TenantGroup = vals[0]
			}
		}
	}
	return nil
}

// GetAlertRecordAttrsResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetAlertRecordAttrsResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &pb.AlertRecordAttr{}
				}
			}
		}
	}
	return nil
}

// GetAlertRecordsRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetAlertRecordsRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "tenantGroup":
				m.TenantGroup = vals[0]
			case "alertGroup":
				m.AlertGroup = vals
			case "alertState":
				m.AlertState = vals
			case "alertType":
				m.AlertType = vals
			case "handleState":
				m.HandleState = vals
			case "handlerId":
				m.HandlerId = vals
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			}
		}
	}
	return nil
}

// GetAlertRecordsResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetAlertRecordsResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &GetAlertRecordsData{}
				}
			case "data.total":
				if m.Data == nil {
					m.Data = &GetAlertRecordsData{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Total = val
			}
		}
	}
	return nil
}

// GetAlertRecordsData implement urlenc.URLValuesUnmarshaler.
func (m *GetAlertRecordsData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// GetAlertRecordRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetAlertRecordRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "groupId":
				m.GroupId = vals[0]
			case "tenantGroup":
				m.TenantGroup = vals[0]
			}
		}
	}
	return nil
}

// GetAlertRecordResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetAlertRecordResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &pb.AlertRecord{}
				}
			case "data.groupId":
				if m.Data == nil {
					m.Data = &pb.AlertRecord{}
				}
				m.Data.GroupId = vals[0]
			case "data.scope":
				if m.Data == nil {
					m.Data = &pb.AlertRecord{}
				}
				m.Data.Scope = vals[0]
			case "data.scopeKey":
				if m.Data == nil {
					m.Data = &pb.AlertRecord{}
				}
				m.Data.ScopeKey = vals[0]
			case "data.alertGroup":
				if m.Data == nil {
					m.Data = &pb.AlertRecord{}
				}
				m.Data.AlertGroup = vals[0]
			case "data.title":
				if m.Data == nil {
					m.Data = &pb.AlertRecord{}
				}
				m.Data.Title = vals[0]
			case "data.alertState":
				if m.Data == nil {
					m.Data = &pb.AlertRecord{}
				}
				m.Data.AlertState = vals[0]
			case "data.alertType":
				if m.Data == nil {
					m.Data = &pb.AlertRecord{}
				}
				m.Data.AlertType = vals[0]
			case "data.alertIndex":
				if m.Data == nil {
					m.Data = &pb.AlertRecord{}
				}
				m.Data.AlertIndex = vals[0]
			case "data.expressionKey":
				if m.Data == nil {
					m.Data = &pb.AlertRecord{}
				}
				m.Data.ExpressionKey = vals[0]
			case "data.alertId":
				if m.Data == nil {
					m.Data = &pb.AlertRecord{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.AlertId = val
			case "data.alertName":
				if m.Data == nil {
					m.Data = &pb.AlertRecord{}
				}
				m.Data.AlertName = vals[0]
			case "data.ruleId":
				if m.Data == nil {
					m.Data = &pb.AlertRecord{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.RuleId = val
			case "data.projectId":
				if m.Data == nil {
					m.Data = &pb.AlertRecord{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ProjectId = val
			case "data.issueId":
				if m.Data == nil {
					m.Data = &pb.AlertRecord{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.IssueId = val
			case "data.handleState":
				if m.Data == nil {
					m.Data = &pb.AlertRecord{}
				}
				m.Data.HandleState = vals[0]
			case "data.handlerId":
				if m.Data == nil {
					m.Data = &pb.AlertRecord{}
				}
				m.Data.HandlerId = vals[0]
			case "data.alertTime":
				if m.Data == nil {
					m.Data = &pb.AlertRecord{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.AlertTime = val
			case "data.handleTime":
				if m.Data == nil {
					m.Data = &pb.AlertRecord{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.HandleTime = val
			case "data.createTime":
				if m.Data == nil {
					m.Data = &pb.AlertRecord{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CreateTime = val
			case "data.updateTime":
				if m.Data == nil {
					m.Data = &pb.AlertRecord{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.UpdateTime = val
			}
		}
	}
	return nil
}

// GetAlertHistoriesRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetAlertHistoriesRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "groupId":
				m.GroupId = vals[0]
			case "tenantGroup":
				m.TenantGroup = vals[0]
			case "start":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Start = val
			case "end":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.End = val
			case "limit":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Limit = val
			}
		}
	}
	return nil
}

// GetAlertHistoriesResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetAlertHistoriesResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// CreateAlertRecordIssueRequest implement urlenc.URLValuesUnmarshaler.
func (m *CreateAlertRecordIssueRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "groupId":
				m.GroupId = vals[0]
			case "tenantGroup":
				m.TenantGroup = vals[0]
			}
		}
	}
	return nil
}

// CreateAlertRecordIssueResponse implement urlenc.URLValuesUnmarshaler.
func (m *CreateAlertRecordIssueResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// UpdateAlertRecordIssueRequest implement urlenc.URLValuesUnmarshaler.
func (m *UpdateAlertRecordIssueRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "groupId":
				m.GroupId = vals[0]
			case "tenantGroup":
				m.TenantGroup = vals[0]
			}
		}
	}
	return nil
}

// UpdateAlertRecordIssueResponse implement urlenc.URLValuesUnmarshaler.
func (m *UpdateAlertRecordIssueResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// DashboardPreviewRequest implement urlenc.URLValuesUnmarshaler.
func (m *DashboardPreviewRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "tenantGroup":
				m.TenantGroup = vals[0]
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "clusterName":
				m.ClusterName = vals[0]
			case "name":
				m.Name = vals[0]
			case "alertType":
				m.AlertType = vals[0]
			case "alertScope":
				m.AlertScope = vals[0]
			case "alertScopeId":
				m.AlertScopeId = vals[0]
			case "enable":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Enable = val
			case "createTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreateTime = val
			case "updateTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdateTime = val
			}
		}
	}
	return nil
}

// DashboardPreviewResponse implement urlenc.URLValuesUnmarshaler.
func (m *DashboardPreviewResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
			case "data.title":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
				m.Data.Title = vals[0]
			case "data.description":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
				m.Data.Description = vals[0]
			case "data.chartType":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
				m.Data.ChartType = vals[0]
			case "data.dataSourceType":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
				m.Data.DataSourceType = vals[0]
			case "data.staticData":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.StaticData = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.StaticData = val
					} else {
						m.Data.StaticData = structpb.NewStringValue(vals[0])
					}
				}
			case "data.staticData.null_value":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.StaticData = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.StaticData = val
					} else {
						m.Data.StaticData = structpb.NewStringValue(vals[0])
					}
				}
			case "data.staticData.number_value":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.StaticData = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.StaticData = val
					} else {
						m.Data.StaticData = structpb.NewStringValue(vals[0])
					}
				}
			case "data.staticData.string_value":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.StaticData = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.StaticData = val
					} else {
						m.Data.StaticData = structpb.NewStringValue(vals[0])
					}
				}
			case "data.staticData.bool_value":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.StaticData = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.StaticData = val
					} else {
						m.Data.StaticData = structpb.NewStringValue(vals[0])
					}
				}
			case "data.staticData.struct_value":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.StaticData = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.StaticData = val
					} else {
						m.Data.StaticData = structpb.NewStringValue(vals[0])
					}
				}
			case "data.staticData.list_value":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.StaticData = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.StaticData = val
					} else {
						m.Data.StaticData = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &pb.Config{}
				}
			case "data.config.dataSourceConfig":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &pb.Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.DataSourceConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.DataSourceConfig = val
					} else {
						m.Data.Config.DataSourceConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.dataSourceConfig.null_value":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &pb.Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.DataSourceConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.DataSourceConfig = val
					} else {
						m.Data.Config.DataSourceConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.dataSourceConfig.number_value":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &pb.Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.DataSourceConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.DataSourceConfig = val
					} else {
						m.Data.Config.DataSourceConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.dataSourceConfig.string_value":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &pb.Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.DataSourceConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.DataSourceConfig = val
					} else {
						m.Data.Config.DataSourceConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.dataSourceConfig.bool_value":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &pb.Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.DataSourceConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.DataSourceConfig = val
					} else {
						m.Data.Config.DataSourceConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.dataSourceConfig.struct_value":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &pb.Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.DataSourceConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.DataSourceConfig = val
					} else {
						m.Data.Config.DataSourceConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.dataSourceConfig.list_value":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &pb.Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.DataSourceConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.DataSourceConfig = val
					} else {
						m.Data.Config.DataSourceConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.option":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &pb.Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.Option = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.Option = val
					} else {
						m.Data.Config.Option = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.option.null_value":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &pb.Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.Option = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.Option = val
					} else {
						m.Data.Config.Option = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.option.number_value":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &pb.Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.Option = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.Option = val
					} else {
						m.Data.Config.Option = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.option.string_value":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &pb.Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.Option = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.Option = val
					} else {
						m.Data.Config.Option = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.option.bool_value":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &pb.Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.Option = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.Option = val
					} else {
						m.Data.Config.Option = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.option.struct_value":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &pb.Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.Option = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.Option = val
					} else {
						m.Data.Config.Option = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.option.list_value":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &pb.Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.Option = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.Option = val
					} else {
						m.Data.Config.Option = structpb.NewStringValue(vals[0])
					}
				}
			case "data.api":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
				if m.Data.Api == nil {
					m.Data.Api = &pb.API{}
				}
			case "data.api.url":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
				if m.Data.Api == nil {
					m.Data.Api = &pb.API{}
				}
				m.Data.Api.Url = vals[0]
			case "data.api.method":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
				if m.Data.Api == nil {
					m.Data.Api = &pb.API{}
				}
				m.Data.Api.Method = vals[0]
			case "data.controls":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Controls = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Controls = val
					} else {
						m.Data.Controls = structpb.NewStringValue(vals[0])
					}
				}
			case "data.controls.null_value":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Controls = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Controls = val
					} else {
						m.Data.Controls = structpb.NewStringValue(vals[0])
					}
				}
			case "data.controls.number_value":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Controls = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Controls = val
					} else {
						m.Data.Controls = structpb.NewStringValue(vals[0])
					}
				}
			case "data.controls.string_value":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Controls = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Controls = val
					} else {
						m.Data.Controls = structpb.NewStringValue(vals[0])
					}
				}
			case "data.controls.bool_value":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Controls = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Controls = val
					} else {
						m.Data.Controls = structpb.NewStringValue(vals[0])
					}
				}
			case "data.controls.struct_value":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Controls = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Controls = val
					} else {
						m.Data.Controls = structpb.NewStringValue(vals[0])
					}
				}
			case "data.controls.list_value":
				if m.Data == nil {
					m.Data = &pb.View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Controls = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Controls = val
					} else {
						m.Data.Controls = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// GetAlertConditionsRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetAlertConditionsRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "scopeType":
				m.ScopeType = vals[0]
			}
		}
	}
	return nil
}

// GetAlertConditionsResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetAlertConditionsResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// GetAlertConditionsValueRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetAlertConditionsValueRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// GetAlertConditionsValueResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetAlertConditionsValueResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}
