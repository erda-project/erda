// Code generated by protoc-gen-go-http. DO NOT EDIT.
// Source: apm_alert.proto

package pb

import (
	context "context"
	http1 "net/http"
	strconv "strconv"
	strings "strings"

	transport "github.com/erda-project/erda-infra/pkg/transport"
	http "github.com/erda-project/erda-infra/pkg/transport/http"
	httprule "github.com/erda-project/erda-infra/pkg/transport/http/httprule"
	runtime "github.com/erda-project/erda-infra/pkg/transport/http/runtime"
	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/transport/http" package it is being compiled against.
const _ = http.SupportPackageIsVersion1

// AlertServiceHandler is the server API for AlertService service.
type AlertServiceHandler interface {
	// GET /api/msp/apm/{tenantGroup}/alert-rules
	QueryAlertRule(context.Context, *QueryAlertRuleRequest) (*QueryAlertRuleResponse, error)
	// GET /api/msp/apm/{tenantGroup}/alerts
	QueryAlert(context.Context, *QueryAlertRequest) (*QueryAlertResponse, error)
	// GET /api/msp/apm/{tenantGroup}/alerts/{id}
	GetAlert(context.Context, *GetAlertRequest) (*GetAlertResponse, error)
	// POST /api/msp/apm/{tenantGroup}/alerts
	CreateAlert(context.Context, *CreateAlertRequest) (*CreateAlertResponse, error)
	// PUT /api/msp/apm/{tenantGroup}/alerts/{id}
	UpdateAlert(context.Context, *UpdateAlertRequest) (*UpdateAlertResponse, error)
	// PUT /api/msp/apm/{tenantGroup}/alerts/{id}/switch
	UpdateAlertEnable(context.Context, *UpdateAlertEnableRequest) (*UpdateAlertEnableResponse, error)
	// DELETE /api/msp/apm/{tenantGroup}/alerts/{id}
	DeleteAlert(context.Context, *DeleteAlertRequest) (*DeleteAlertResponse, error)
	// GET /api/msp/apm/{tenantGroup}/custom-alerts/metrics
	QueryCustomizeMetric(context.Context, *QueryCustomizeMetricRequest) (*QueryCustomizeMetricResponse, error)
	// GET /api/msp/apm/{tenantGroup}/custom-alerts/notifies/targets
	QueryCustomizeNotifyTarget(context.Context, *QueryCustomizeNotifyTargetRequest) (*QueryCustomizeNotifyTargetResponse, error)
	// GET /api/msp/apm/{tenantGroup}/custom-alerts
	QueryCustomizeAlerts(context.Context, *QueryCustomizeAlertsRequest) (*QueryCustomizeAlertsResponse, error)
	// GET /api/msp/apm/{tenantGroup}/custom-alerts/{id}
	GetCustomizeAlert(context.Context, *GetCustomizeAlertRequest) (*GetCustomizeAlertResponse, error)
	// POST /api/msp/apm/{tenantGroup}/custom-alerts
	CreateCustomizeAlert(context.Context, *CreateCustomizeAlertRequest) (*CreateCustomizeAlertResponse, error)
	// PUT /api/msp/apm/{tenantGroup}/custom-alerts/{id}
	UpdateCustomizeAlert(context.Context, *UpdateCustomizeAlertRequest) (*UpdateCustomizeAlertResponse, error)
	// PUT /api/msp/apm/{tenantGroup}/custom-alerts/{id}/switch
	UpdateCustomizeAlertEnable(context.Context, *UpdateCustomizeAlertEnableRequest) (*UpdateCustomizeAlertEnableResponse, error)
	// DELETE /api/msp/apm/{tenantGroup}/custom-alerts/{id}
	DeleteCustomizeAlert(context.Context, *DeleteCustomizeAlertRequest) (*DeleteCustomizeAlertResponse, error)
	// GET /api/msp/apm/{tenantGroup}/alert-record-attrs
	GetAlertRecordAttrs(context.Context, *GetAlertRecordAttrsRequest) (*GetAlertRecordAttrsResponse, error)
	// GET /api/msp/apm/{tenantGroup}/alert-records
	GetAlertRecords(context.Context, *GetAlertRecordsRequest) (*GetAlertRecordsResponse, error)
	// GET /api/msp/apm/{tenantGroup}/alert-records/{groupId}
	GetAlertRecord(context.Context, *GetAlertRecordRequest) (*GetAlertRecordResponse, error)
	// GET /api/msp/apm/{tenantGroup}/alert-records/{groupId}/histories
	GetAlertHistories(context.Context, *GetAlertHistoriesRequest) (*GetAlertHistoriesResponse, error)
	// POST /api/msp/apm/{tenantGroup}/alert-records/{groupId}/issues
	CreateAlertRecordIssue(context.Context, *CreateAlertRecordIssueRequest) (*CreateAlertRecordIssueResponse, error)
	// PUT /api/msp/apm/{tenantGroup}/alert-records/{groupId}/issues
	UpdateAlertRecordIssue(context.Context, *UpdateAlertRecordIssueRequest) (*UpdateAlertRecordIssueResponse, error)
	// POST /api/msp/apm/{tenantGroup}/alert-records/custom-alerts/dash-preview/query
	DashboardPreview(context.Context, *DashboardPreviewRequest) (*DashboardPreviewResponse, error)
	// GET /api/msp/apm/conditions
	GetAlertConditions(context.Context, *GetAlertConditionsRequest) (*GetAlertConditionsResponse, error)
	// POST /api/msp/apm/conditions/value
	GetAlertConditionsValue(context.Context, *GetAlertConditionsValueRequest) (*GetAlertConditionsValueResponse, error)
}

// RegisterAlertServiceHandler register AlertServiceHandler to http.Router.
func RegisterAlertServiceHandler(r http.Router, srv AlertServiceHandler, opts ...http.HandleOption) {
	h := http.DefaultHandleOptions()
	for _, op := range opts {
		op(h)
	}
	encodeFunc := func(fn func(http1.ResponseWriter, *http1.Request) (interface{}, error)) http.HandlerFunc {
		handler := func(w http1.ResponseWriter, r *http1.Request) {
			out, err := fn(w, r)
			if err != nil {
				h.Error(w, r, err)
				return
			}
			if err := h.Encode(w, r, out); err != nil {
				h.Error(w, r, err)
			}
		}
		if h.HTTPInterceptor != nil {
			handler = h.HTTPInterceptor(handler)
		}
		return handler
	}

	add_QueryAlertRule := func(method, path string, fn func(context.Context, *QueryAlertRuleRequest) (*QueryAlertRuleResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QueryAlertRuleRequest))
		}
		var QueryAlertRule_info transport.ServiceInfo
		if h.Interceptor != nil {
			QueryAlertRule_info = transport.NewServiceInfo("erda.msp.apm.alert.AlertService", "QueryAlertRule", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QueryAlertRule_info)
				}
				r = r.WithContext(ctx)
				var in QueryAlertRuleRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "tenantGroup":
							in.TenantGroup = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QueryAlert := func(method, path string, fn func(context.Context, *QueryAlertRequest) (*QueryAlertResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QueryAlertRequest))
		}
		var QueryAlert_info transport.ServiceInfo
		if h.Interceptor != nil {
			QueryAlert_info = transport.NewServiceInfo("erda.msp.apm.alert.AlertService", "QueryAlert", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QueryAlert_info)
				}
				r = r.WithContext(ctx)
				var in QueryAlertRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "tenantGroup":
							in.TenantGroup = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetAlert := func(method, path string, fn func(context.Context, *GetAlertRequest) (*GetAlertResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetAlertRequest))
		}
		var GetAlert_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetAlert_info = transport.NewServiceInfo("erda.msp.apm.alert.AlertService", "GetAlert", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetAlert_info)
				}
				r = r.WithContext(ctx)
				var in GetAlertRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "tenantGroup":
							in.TenantGroup = val
						case "id":
							val, err := strconv.ParseInt(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CreateAlert := func(method, path string, fn func(context.Context, *CreateAlertRequest) (*CreateAlertResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateAlertRequest))
		}
		var CreateAlert_info transport.ServiceInfo
		if h.Interceptor != nil {
			CreateAlert_info = transport.NewServiceInfo("erda.msp.apm.alert.AlertService", "CreateAlert", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CreateAlert_info)
				}
				r = r.WithContext(ctx)
				var in CreateAlertRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "tenantGroup":
							in.TenantGroup = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_UpdateAlert := func(method, path string, fn func(context.Context, *UpdateAlertRequest) (*UpdateAlertResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpdateAlertRequest))
		}
		var UpdateAlert_info transport.ServiceInfo
		if h.Interceptor != nil {
			UpdateAlert_info = transport.NewServiceInfo("erda.msp.apm.alert.AlertService", "UpdateAlert", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, UpdateAlert_info)
				}
				r = r.WithContext(ctx)
				var in UpdateAlertRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "tenantGroup":
							in.TenantGroup = val
						case "id":
							val, err := strconv.ParseUint(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_UpdateAlertEnable := func(method, path string, fn func(context.Context, *UpdateAlertEnableRequest) (*UpdateAlertEnableResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpdateAlertEnableRequest))
		}
		var UpdateAlertEnable_info transport.ServiceInfo
		if h.Interceptor != nil {
			UpdateAlertEnable_info = transport.NewServiceInfo("erda.msp.apm.alert.AlertService", "UpdateAlertEnable", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, UpdateAlertEnable_info)
				}
				r = r.WithContext(ctx)
				var in UpdateAlertEnableRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "tenantGroup":
							in.TenantGroup = val
						case "id":
							val, err := strconv.ParseInt(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_DeleteAlert := func(method, path string, fn func(context.Context, *DeleteAlertRequest) (*DeleteAlertResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DeleteAlertRequest))
		}
		var DeleteAlert_info transport.ServiceInfo
		if h.Interceptor != nil {
			DeleteAlert_info = transport.NewServiceInfo("erda.msp.apm.alert.AlertService", "DeleteAlert", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, DeleteAlert_info)
				}
				r = r.WithContext(ctx)
				var in DeleteAlertRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "tenantGroup":
							in.TenantGroup = val
						case "id":
							val, err := strconv.ParseInt(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QueryCustomizeMetric := func(method, path string, fn func(context.Context, *QueryCustomizeMetricRequest) (*QueryCustomizeMetricResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QueryCustomizeMetricRequest))
		}
		var QueryCustomizeMetric_info transport.ServiceInfo
		if h.Interceptor != nil {
			QueryCustomizeMetric_info = transport.NewServiceInfo("erda.msp.apm.alert.AlertService", "QueryCustomizeMetric", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QueryCustomizeMetric_info)
				}
				r = r.WithContext(ctx)
				var in QueryCustomizeMetricRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "tenantGroup":
							in.TenantGroup = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QueryCustomizeNotifyTarget := func(method, path string, fn func(context.Context, *QueryCustomizeNotifyTargetRequest) (*QueryCustomizeNotifyTargetResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QueryCustomizeNotifyTargetRequest))
		}
		var QueryCustomizeNotifyTarget_info transport.ServiceInfo
		if h.Interceptor != nil {
			QueryCustomizeNotifyTarget_info = transport.NewServiceInfo("erda.msp.apm.alert.AlertService", "QueryCustomizeNotifyTarget", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QueryCustomizeNotifyTarget_info)
				}
				r = r.WithContext(ctx)
				var in QueryCustomizeNotifyTargetRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "tenantGroup":
							in.TenantGroup = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QueryCustomizeAlerts := func(method, path string, fn func(context.Context, *QueryCustomizeAlertsRequest) (*QueryCustomizeAlertsResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QueryCustomizeAlertsRequest))
		}
		var QueryCustomizeAlerts_info transport.ServiceInfo
		if h.Interceptor != nil {
			QueryCustomizeAlerts_info = transport.NewServiceInfo("erda.msp.apm.alert.AlertService", "QueryCustomizeAlerts", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QueryCustomizeAlerts_info)
				}
				r = r.WithContext(ctx)
				var in QueryCustomizeAlertsRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "tenantGroup":
							in.TenantGroup = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetCustomizeAlert := func(method, path string, fn func(context.Context, *GetCustomizeAlertRequest) (*GetCustomizeAlertResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetCustomizeAlertRequest))
		}
		var GetCustomizeAlert_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetCustomizeAlert_info = transport.NewServiceInfo("erda.msp.apm.alert.AlertService", "GetCustomizeAlert", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetCustomizeAlert_info)
				}
				r = r.WithContext(ctx)
				var in GetCustomizeAlertRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "tenantGroup":
							in.TenantGroup = val
						case "id":
							val, err := strconv.ParseUint(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CreateCustomizeAlert := func(method, path string, fn func(context.Context, *CreateCustomizeAlertRequest) (*CreateCustomizeAlertResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateCustomizeAlertRequest))
		}
		var CreateCustomizeAlert_info transport.ServiceInfo
		if h.Interceptor != nil {
			CreateCustomizeAlert_info = transport.NewServiceInfo("erda.msp.apm.alert.AlertService", "CreateCustomizeAlert", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CreateCustomizeAlert_info)
				}
				r = r.WithContext(ctx)
				var in CreateCustomizeAlertRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "tenantGroup":
							in.TenantGroup = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_UpdateCustomizeAlert := func(method, path string, fn func(context.Context, *UpdateCustomizeAlertRequest) (*UpdateCustomizeAlertResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpdateCustomizeAlertRequest))
		}
		var UpdateCustomizeAlert_info transport.ServiceInfo
		if h.Interceptor != nil {
			UpdateCustomizeAlert_info = transport.NewServiceInfo("erda.msp.apm.alert.AlertService", "UpdateCustomizeAlert", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, UpdateCustomizeAlert_info)
				}
				r = r.WithContext(ctx)
				var in UpdateCustomizeAlertRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "tenantGroup":
							in.TenantGroup = val
						case "id":
							val, err := strconv.ParseUint(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_UpdateCustomizeAlertEnable := func(method, path string, fn func(context.Context, *UpdateCustomizeAlertEnableRequest) (*UpdateCustomizeAlertEnableResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpdateCustomizeAlertEnableRequest))
		}
		var UpdateCustomizeAlertEnable_info transport.ServiceInfo
		if h.Interceptor != nil {
			UpdateCustomizeAlertEnable_info = transport.NewServiceInfo("erda.msp.apm.alert.AlertService", "UpdateCustomizeAlertEnable", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, UpdateCustomizeAlertEnable_info)
				}
				r = r.WithContext(ctx)
				var in UpdateCustomizeAlertEnableRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "tenantGroup":
							in.TenantGroup = val
						case "id":
							val, err := strconv.ParseUint(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_DeleteCustomizeAlert := func(method, path string, fn func(context.Context, *DeleteCustomizeAlertRequest) (*DeleteCustomizeAlertResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DeleteCustomizeAlertRequest))
		}
		var DeleteCustomizeAlert_info transport.ServiceInfo
		if h.Interceptor != nil {
			DeleteCustomizeAlert_info = transport.NewServiceInfo("erda.msp.apm.alert.AlertService", "DeleteCustomizeAlert", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, DeleteCustomizeAlert_info)
				}
				r = r.WithContext(ctx)
				var in DeleteCustomizeAlertRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "tenantGroup":
							in.TenantGroup = val
						case "id":
							val, err := strconv.ParseUint(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetAlertRecordAttrs := func(method, path string, fn func(context.Context, *GetAlertRecordAttrsRequest) (*GetAlertRecordAttrsResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetAlertRecordAttrsRequest))
		}
		var GetAlertRecordAttrs_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetAlertRecordAttrs_info = transport.NewServiceInfo("erda.msp.apm.alert.AlertService", "GetAlertRecordAttrs", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetAlertRecordAttrs_info)
				}
				r = r.WithContext(ctx)
				var in GetAlertRecordAttrsRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "tenantGroup":
							in.TenantGroup = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetAlertRecords := func(method, path string, fn func(context.Context, *GetAlertRecordsRequest) (*GetAlertRecordsResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetAlertRecordsRequest))
		}
		var GetAlertRecords_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetAlertRecords_info = transport.NewServiceInfo("erda.msp.apm.alert.AlertService", "GetAlertRecords", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetAlertRecords_info)
				}
				r = r.WithContext(ctx)
				var in GetAlertRecordsRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "tenantGroup":
							in.TenantGroup = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetAlertRecord := func(method, path string, fn func(context.Context, *GetAlertRecordRequest) (*GetAlertRecordResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetAlertRecordRequest))
		}
		var GetAlertRecord_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetAlertRecord_info = transport.NewServiceInfo("erda.msp.apm.alert.AlertService", "GetAlertRecord", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetAlertRecord_info)
				}
				r = r.WithContext(ctx)
				var in GetAlertRecordRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "tenantGroup":
							in.TenantGroup = val
						case "groupId":
							in.GroupId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetAlertHistories := func(method, path string, fn func(context.Context, *GetAlertHistoriesRequest) (*GetAlertHistoriesResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetAlertHistoriesRequest))
		}
		var GetAlertHistories_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetAlertHistories_info = transport.NewServiceInfo("erda.msp.apm.alert.AlertService", "GetAlertHistories", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetAlertHistories_info)
				}
				r = r.WithContext(ctx)
				var in GetAlertHistoriesRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "tenantGroup":
							in.TenantGroup = val
						case "groupId":
							in.GroupId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CreateAlertRecordIssue := func(method, path string, fn func(context.Context, *CreateAlertRecordIssueRequest) (*CreateAlertRecordIssueResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateAlertRecordIssueRequest))
		}
		var CreateAlertRecordIssue_info transport.ServiceInfo
		if h.Interceptor != nil {
			CreateAlertRecordIssue_info = transport.NewServiceInfo("erda.msp.apm.alert.AlertService", "CreateAlertRecordIssue", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CreateAlertRecordIssue_info)
				}
				r = r.WithContext(ctx)
				var in CreateAlertRecordIssueRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "tenantGroup":
							in.TenantGroup = val
						case "groupId":
							in.GroupId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_UpdateAlertRecordIssue := func(method, path string, fn func(context.Context, *UpdateAlertRecordIssueRequest) (*UpdateAlertRecordIssueResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpdateAlertRecordIssueRequest))
		}
		var UpdateAlertRecordIssue_info transport.ServiceInfo
		if h.Interceptor != nil {
			UpdateAlertRecordIssue_info = transport.NewServiceInfo("erda.msp.apm.alert.AlertService", "UpdateAlertRecordIssue", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, UpdateAlertRecordIssue_info)
				}
				r = r.WithContext(ctx)
				var in UpdateAlertRecordIssueRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "tenantGroup":
							in.TenantGroup = val
						case "groupId":
							in.GroupId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_DashboardPreview := func(method, path string, fn func(context.Context, *DashboardPreviewRequest) (*DashboardPreviewResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DashboardPreviewRequest))
		}
		var DashboardPreview_info transport.ServiceInfo
		if h.Interceptor != nil {
			DashboardPreview_info = transport.NewServiceInfo("erda.msp.apm.alert.AlertService", "DashboardPreview", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, DashboardPreview_info)
				}
				r = r.WithContext(ctx)
				var in DashboardPreviewRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "tenantGroup":
							in.TenantGroup = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetAlertConditions := func(method, path string, fn func(context.Context, *GetAlertConditionsRequest) (*GetAlertConditionsResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetAlertConditionsRequest))
		}
		var GetAlertConditions_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetAlertConditions_info = transport.NewServiceInfo("erda.msp.apm.alert.AlertService", "GetAlertConditions", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetAlertConditions_info)
				}
				r = r.WithContext(ctx)
				var in GetAlertConditionsRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetAlertConditionsValue := func(method, path string, fn func(context.Context, *GetAlertConditionsValueRequest) (*GetAlertConditionsValueResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetAlertConditionsValueRequest))
		}
		var GetAlertConditionsValue_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetAlertConditionsValue_info = transport.NewServiceInfo("erda.msp.apm.alert.AlertService", "GetAlertConditionsValue", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetAlertConditionsValue_info)
				}
				r = r.WithContext(ctx)
				var in GetAlertConditionsValueRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QueryAlertRule("GET", "/api/msp/apm/{tenantGroup}/alert-rules", srv.QueryAlertRule)
	add_QueryAlert("GET", "/api/msp/apm/{tenantGroup}/alerts", srv.QueryAlert)
	add_GetAlert("GET", "/api/msp/apm/{tenantGroup}/alerts/{id}", srv.GetAlert)
	add_CreateAlert("POST", "/api/msp/apm/{tenantGroup}/alerts", srv.CreateAlert)
	add_UpdateAlert("PUT", "/api/msp/apm/{tenantGroup}/alerts/{id}", srv.UpdateAlert)
	add_UpdateAlertEnable("PUT", "/api/msp/apm/{tenantGroup}/alerts/{id}/switch", srv.UpdateAlertEnable)
	add_DeleteAlert("DELETE", "/api/msp/apm/{tenantGroup}/alerts/{id}", srv.DeleteAlert)
	add_QueryCustomizeMetric("GET", "/api/msp/apm/{tenantGroup}/custom-alerts/metrics", srv.QueryCustomizeMetric)
	add_QueryCustomizeNotifyTarget("GET", "/api/msp/apm/{tenantGroup}/custom-alerts/notifies/targets", srv.QueryCustomizeNotifyTarget)
	add_QueryCustomizeAlerts("GET", "/api/msp/apm/{tenantGroup}/custom-alerts", srv.QueryCustomizeAlerts)
	add_GetCustomizeAlert("GET", "/api/msp/apm/{tenantGroup}/custom-alerts/{id}", srv.GetCustomizeAlert)
	add_CreateCustomizeAlert("POST", "/api/msp/apm/{tenantGroup}/custom-alerts", srv.CreateCustomizeAlert)
	add_UpdateCustomizeAlert("PUT", "/api/msp/apm/{tenantGroup}/custom-alerts/{id}", srv.UpdateCustomizeAlert)
	add_UpdateCustomizeAlertEnable("PUT", "/api/msp/apm/{tenantGroup}/custom-alerts/{id}/switch", srv.UpdateCustomizeAlertEnable)
	add_DeleteCustomizeAlert("DELETE", "/api/msp/apm/{tenantGroup}/custom-alerts/{id}", srv.DeleteCustomizeAlert)
	add_GetAlertRecordAttrs("GET", "/api/msp/apm/{tenantGroup}/alert-record-attrs", srv.GetAlertRecordAttrs)
	add_GetAlertRecords("GET", "/api/msp/apm/{tenantGroup}/alert-records", srv.GetAlertRecords)
	add_GetAlertRecord("GET", "/api/msp/apm/{tenantGroup}/alert-records/{groupId}", srv.GetAlertRecord)
	add_GetAlertHistories("GET", "/api/msp/apm/{tenantGroup}/alert-records/{groupId}/histories", srv.GetAlertHistories)
	add_CreateAlertRecordIssue("POST", "/api/msp/apm/{tenantGroup}/alert-records/{groupId}/issues", srv.CreateAlertRecordIssue)
	add_UpdateAlertRecordIssue("PUT", "/api/msp/apm/{tenantGroup}/alert-records/{groupId}/issues", srv.UpdateAlertRecordIssue)
	add_DashboardPreview("POST", "/api/msp/apm/{tenantGroup}/alert-records/custom-alerts/dash-preview/query", srv.DashboardPreview)
	add_GetAlertConditions("GET", "/api/msp/apm/conditions", srv.GetAlertConditions)
	add_GetAlertConditionsValue("POST", "/api/msp/apm/conditions/value", srv.GetAlertConditionsValue)
}
