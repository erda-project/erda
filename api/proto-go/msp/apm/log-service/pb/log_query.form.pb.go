// Copyright (c) 2021 Terminus, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go-form. DO NOT EDIT.
// Source: log_query.proto

package pb

import (
	url "net/url"
	strconv "strconv"

	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/urlenc" package it is being compiled against.
var _ urlenc.URLValuesUnmarshaler = (*GetFieldSettingsRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetFieldSettingsResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*LogField)(nil)
var _ urlenc.URLValuesUnmarshaler = (*SequentialSearchRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*SequentialSearchResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PagedSearchRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PagedSearchResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*LogQueryResult)(nil)
var _ urlenc.URLValuesUnmarshaler = (*HighlightLog)(nil)
var _ urlenc.URLValuesUnmarshaler = (*LogItem)(nil)
var _ urlenc.URLValuesUnmarshaler = (*BucketAggregationRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*BucketAggregationResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*LogFieldsAggregationResult)(nil)
var _ urlenc.URLValuesUnmarshaler = (*LogFieldBucket)(nil)
var _ urlenc.URLValuesUnmarshaler = (*BucketAgg)(nil)
var _ urlenc.URLValuesUnmarshaler = (*HistogramAggregationRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*HistogramAggregationResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*HistogramAggregationResult)(nil)
var _ urlenc.URLValuesUnmarshaler = (*LogStatisticResult)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CountHistogram)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ArrayAgg)(nil)

// GetFieldSettingsRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetFieldSettingsRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "addon":
				m.Addon = vals[0]
			}
		}
	}
	return nil
}

// GetFieldSettingsResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetFieldSettingsResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// LogField implement urlenc.URLValuesUnmarshaler.
func (m *LogField) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "fieldName":
				m.FieldName = vals[0]
			case "supportAggregation":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.SupportAggregation = val
			case "display":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Display = val
			case "allowEdit":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.AllowEdit = val
			case "group":
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Group = int32(val)
			}
		}
	}
	return nil
}

// SequentialSearchRequest implement urlenc.URLValuesUnmarshaler.
func (m *SequentialSearchRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "start":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Start = val
			case "end":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.End = val
			case "clusterName":
				m.ClusterName = vals[0]
			case "addon":
				m.Addon = vals[0]
			case "query":
				m.Query = vals[0]
			case "debug":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Debug = val
			case "sort":
				m.Sort = vals[0]
			case "id":
				m.Id = vals[0]
			case "timestampNanos":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TimestampNanos = val
			case "offset":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Offset = val
			case "count":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Count = val
			}
		}
	}
	return nil
}

// SequentialSearchResponse implement urlenc.URLValuesUnmarshaler.
func (m *SequentialSearchResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &LogQueryResult{}
				}
			case "data.total":
				if m.Data == nil {
					m.Data = &LogQueryResult{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Total = val
			}
		}
	}
	return nil
}

// PagedSearchRequest implement urlenc.URLValuesUnmarshaler.
func (m *PagedSearchRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "start":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Start = val
			case "end":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.End = val
			case "clusterName":
				m.ClusterName = vals[0]
			case "addon":
				m.Addon = vals[0]
			case "query":
				m.Query = vals[0]
			case "debug":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Debug = val
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			case "sort":
				m.Sort = vals
			case "highlight":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Highlight = val
			}
		}
	}
	return nil
}

// PagedSearchResponse implement urlenc.URLValuesUnmarshaler.
func (m *PagedSearchResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &LogQueryResult{}
				}
			case "data.total":
				if m.Data == nil {
					m.Data = &LogQueryResult{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Total = val
			}
		}
	}
	return nil
}

// LogQueryResult implement urlenc.URLValuesUnmarshaler.
func (m *LogQueryResult) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// HighlightLog implement urlenc.URLValuesUnmarshaler.
func (m *HighlightLog) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "source":
				if m.Source == nil {
					m.Source = &LogItem{}
				}
			case "source.docId":
				if m.Source == nil {
					m.Source = &LogItem{}
				}
				m.Source.DocId = vals[0]
			case "source.id":
				if m.Source == nil {
					m.Source = &LogItem{}
				}
				m.Source.Id = vals[0]
			case "source.source":
				if m.Source == nil {
					m.Source = &LogItem{}
				}
				m.Source.Source = vals[0]
			case "source.stream":
				if m.Source == nil {
					m.Source = &LogItem{}
				}
				m.Source.Stream = vals[0]
			case "source.content":
				if m.Source == nil {
					m.Source = &LogItem{}
				}
				m.Source.Content = vals[0]
			case "source.offset":
				if m.Source == nil {
					m.Source = &LogItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Source.Offset = val
			case "source.timestamp":
				if m.Source == nil {
					m.Source = &LogItem{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Source.Timestamp = val
			case "source.timestampNanos":
				if m.Source == nil {
					m.Source = &LogItem{}
				}
				m.Source.TimestampNanos = vals[0]
			}
		}
	}
	return nil
}

// LogItem implement urlenc.URLValuesUnmarshaler.
func (m *LogItem) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "docId":
				m.DocId = vals[0]
			case "id":
				m.Id = vals[0]
			case "source":
				m.Source = vals[0]
			case "stream":
				m.Stream = vals[0]
			case "content":
				m.Content = vals[0]
			case "offset":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Offset = val
			case "timestamp":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Timestamp = val
			case "timestampNanos":
				m.TimestampNanos = vals[0]
			}
		}
	}
	return nil
}

// BucketAggregationRequest implement urlenc.URLValuesUnmarshaler.
func (m *BucketAggregationRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "start":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Start = val
			case "end":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.End = val
			case "clusterName":
				m.ClusterName = vals[0]
			case "addon":
				m.Addon = vals[0]
			case "query":
				m.Query = vals[0]
			case "debug":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Debug = val
			case "aggFields":
				m.AggFields = vals
			case "termsSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TermsSize = val
			}
		}
	}
	return nil
}

// BucketAggregationResponse implement urlenc.URLValuesUnmarshaler.
func (m *BucketAggregationResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &LogFieldsAggregationResult{}
				}
			case "data.total":
				if m.Data == nil {
					m.Data = &LogFieldsAggregationResult{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Total = val
			}
		}
	}
	return nil
}

// LogFieldsAggregationResult implement urlenc.URLValuesUnmarshaler.
func (m *LogFieldsAggregationResult) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// LogFieldBucket implement urlenc.URLValuesUnmarshaler.
func (m *LogFieldBucket) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// BucketAgg implement urlenc.URLValuesUnmarshaler.
func (m *BucketAgg) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "key":
				m.Key = vals[0]
			case "count":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Count = val
			}
		}
	}
	return nil
}

// HistogramAggregationRequest implement urlenc.URLValuesUnmarshaler.
func (m *HistogramAggregationRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "start":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Start = val
			case "end":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.End = val
			case "clusterName":
				m.ClusterName = vals[0]
			case "addon":
				m.Addon = vals[0]
			case "query":
				m.Query = vals[0]
			case "debug":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Debug = val
			}
		}
	}
	return nil
}

// HistogramAggregationResponse implement urlenc.URLValuesUnmarshaler.
func (m *HistogramAggregationResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &HistogramAggregationResult{}
				}
			case "data.title":
				if m.Data == nil {
					m.Data = &HistogramAggregationResult{}
				}
				m.Data.Title = vals[0]
			case "data.total":
				if m.Data == nil {
					m.Data = &HistogramAggregationResult{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Total = val
			case "data.interval":
				if m.Data == nil {
					m.Data = &HistogramAggregationResult{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Interval = val
			case "data.time":
				if m.Data == nil {
					m.Data = &HistogramAggregationResult{}
				}
				list := make([]int64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseInt(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.Data.Time = list
			}
		}
	}
	return nil
}

// HistogramAggregationResult implement urlenc.URLValuesUnmarshaler.
func (m *HistogramAggregationResult) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "title":
				m.Title = vals[0]
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			case "interval":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Interval = val
			case "time":
				list := make([]int64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseInt(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.Time = list
			}
		}
	}
	return nil
}

// LogStatisticResult implement urlenc.URLValuesUnmarshaler.
func (m *LogStatisticResult) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals[0]
			}
		}
	}
	return nil
}

// CountHistogram implement urlenc.URLValuesUnmarshaler.
func (m *CountHistogram) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "count":
				if m.Count == nil {
					m.Count = &ArrayAgg{}
				}
			case "count.unitType":
				if m.Count == nil {
					m.Count = &ArrayAgg{}
				}
				m.Count.UnitType = vals[0]
			case "count.unit":
				if m.Count == nil {
					m.Count = &ArrayAgg{}
				}
				m.Count.Unit = vals[0]
			case "count.chartType":
				if m.Count == nil {
					m.Count = &ArrayAgg{}
				}
				m.Count.ChartType = vals[0]
			case "count.axisIndex":
				if m.Count == nil {
					m.Count = &ArrayAgg{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Count.AxisIndex = val
			case "count.name":
				if m.Count == nil {
					m.Count = &ArrayAgg{}
				}
				m.Count.Name = vals[0]
			case "count.tag":
				if m.Count == nil {
					m.Count = &ArrayAgg{}
				}
				m.Count.Tag = vals[0]
			case "count.data":
				if m.Count == nil {
					m.Count = &ArrayAgg{}
				}
				list := make([]float64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseFloat(text, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.Count.Data = list
			}
		}
	}
	return nil
}

// ArrayAgg implement urlenc.URLValuesUnmarshaler.
func (m *ArrayAgg) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "unitType":
				m.UnitType = vals[0]
			case "unit":
				m.Unit = vals[0]
			case "chartType":
				m.ChartType = vals[0]
			case "axisIndex":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AxisIndex = val
			case "name":
				m.Name = vals[0]
			case "tag":
				m.Tag = vals[0]
			case "data":
				list := make([]float64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseFloat(text, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.Data = list
			}
		}
	}
	return nil
}
