// Code generated by protoc-gen-go-form. DO NOT EDIT.
// Source: flow.proto

package pb

import (
	url "net/url"
	strconv "strconv"

	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/urlenc" package it is being compiled against.
var _ urlenc.URLValuesUnmarshaler = (*IssueRelationExtra)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DevFlowNode)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateFlowNodeRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateFlowNodeResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*OperationDeployRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*OperationDeployResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteFlowNodeRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteFlowNodeResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ReconstructionRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ReconstructionResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineStepInfo)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetDevFlowInfoRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ChangeBranch)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DevFlowInfo)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetDevFlowInfoResponse)(nil)

// IssueRelationExtra implement urlenc.URLValuesUnmarshaler.
func (m *IssueRelationExtra) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			case "repoMergeID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.RepoMergeID = val
			}
		}
	}
	return nil
}

// DevFlowNode implement urlenc.URLValuesUnmarshaler.
func (m *DevFlowNode) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "repoMergeID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.RepoMergeID = val
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			case "targetBranch":
				m.TargetBranch = vals[0]
			case "sourceBranch":
				m.SourceBranch = vals[0]
			case "isJoinTempBranch":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsJoinTempBranch = val
			case "joinTempBranchStatus":
				m.JoinTempBranchStatus = vals[0]
			case "tempBranch":
				m.TempBranch = vals[0]
			case "issueID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueID = val
			case "mergeID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeID = val
			}
		}
	}
	return nil
}

// CreateFlowNodeRequest implement urlenc.URLValuesUnmarshaler.
func (m *CreateFlowNodeRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "issueID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueID = val
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			case "sourceBranch":
				m.SourceBranch = vals[0]
			case "targetBranch":
				m.TargetBranch = vals[0]
			}
		}
	}
	return nil
}

// CreateFlowNodeResponse implement urlenc.URLValuesUnmarshaler.
func (m *CreateFlowNodeResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "repoMergeID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.RepoMergeID = val
			case "mergeID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeID = val
			}
		}
	}
	return nil
}

// OperationDeployRequest implement urlenc.URLValuesUnmarshaler.
func (m *OperationDeployRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "mergeID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeID = val
			case "enable":
				if m.Enable == nil {
					m.Enable = &wrapperspb.BoolValue{}
				}
			case "enable.value":
				if m.Enable == nil {
					m.Enable = &wrapperspb.BoolValue{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Enable.Value = val
			}
		}
	}
	return nil
}

// OperationDeployResponse implement urlenc.URLValuesUnmarshaler.
func (m *OperationDeployResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// DeleteFlowNodeRequest implement urlenc.URLValuesUnmarshaler.
func (m *DeleteFlowNodeRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "mergeID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeID = val
			case "issueID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueID = val
			}
		}
	}
	return nil
}

// DeleteFlowNodeResponse implement urlenc.URLValuesUnmarshaler.
func (m *DeleteFlowNodeResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// ReconstructionRequest implement urlenc.URLValuesUnmarshaler.
func (m *ReconstructionRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "mergeID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeID = val
			}
		}
	}
	return nil
}

// ReconstructionResponse implement urlenc.URLValuesUnmarshaler.
func (m *ReconstructionResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// PipelineStepInfo implement urlenc.URLValuesUnmarshaler.
func (m *PipelineStepInfo) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "status":
				m.Status = vals[0]
			case "pipelineID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PipelineID = val
			case "ymlName":
				m.YmlName = vals[0]
			}
		}
	}
	return nil
}

// GetDevFlowInfoRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetDevFlowInfoRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "issueID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueID = val
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "mergeID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MergeID = val
			}
		}
	}
	return nil
}

// ChangeBranch implement urlenc.URLValuesUnmarshaler.
func (m *ChangeBranch) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "commit":
				m.Commit = vals[0]
			case "branchName":
				m.BranchName = vals[0]
			case "status":
				m.Status = vals[0]
			case "repoMergeID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.RepoMergeID = val
			}
		}
	}
	return nil
}

// DevFlowInfo implement urlenc.URLValuesUnmarshaler.
func (m *DevFlowInfo) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "devFlowNode":
				if m.DevFlowNode == nil {
					m.DevFlowNode = &DevFlowNode{}
				}
			case "devFlowNode.repoMergeID":
				if m.DevFlowNode == nil {
					m.DevFlowNode = &DevFlowNode{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.DevFlowNode.RepoMergeID = val
			case "devFlowNode.appID":
				if m.DevFlowNode == nil {
					m.DevFlowNode = &DevFlowNode{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.DevFlowNode.AppID = val
			case "devFlowNode.targetBranch":
				if m.DevFlowNode == nil {
					m.DevFlowNode = &DevFlowNode{}
				}
				m.DevFlowNode.TargetBranch = vals[0]
			case "devFlowNode.sourceBranch":
				if m.DevFlowNode == nil {
					m.DevFlowNode = &DevFlowNode{}
				}
				m.DevFlowNode.SourceBranch = vals[0]
			case "devFlowNode.isJoinTempBranch":
				if m.DevFlowNode == nil {
					m.DevFlowNode = &DevFlowNode{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.DevFlowNode.IsJoinTempBranch = val
			case "devFlowNode.joinTempBranchStatus":
				if m.DevFlowNode == nil {
					m.DevFlowNode = &DevFlowNode{}
				}
				m.DevFlowNode.JoinTempBranchStatus = vals[0]
			case "devFlowNode.tempBranch":
				if m.DevFlowNode == nil {
					m.DevFlowNode = &DevFlowNode{}
				}
				m.DevFlowNode.TempBranch = vals[0]
			case "devFlowNode.issueID":
				if m.DevFlowNode == nil {
					m.DevFlowNode = &DevFlowNode{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.DevFlowNode.IssueID = val
			case "devFlowNode.mergeID":
				if m.DevFlowNode == nil {
					m.DevFlowNode = &DevFlowNode{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.DevFlowNode.MergeID = val
			case "commit":
				m.Commit = vals[0]
			}
		}
	}
	return nil
}

// GetDevFlowInfoResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetDevFlowInfoResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "status":
				m.Status = vals[0]
			}
		}
	}
	return nil
}
