// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// Source: cron.proto

package pb

import (
	context "context"

	transport "github.com/erda-project/erda-infra/pkg/transport"
	grpc1 "github.com/erda-project/erda-infra/pkg/transport/grpc"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion5

// CronServiceClient is the client API for CronService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CronServiceClient interface {
	CronCreate(ctx context.Context, in *CronCreateRequest, opts ...grpc.CallOption) (*CronCreateResponse, error)
	CronPaging(ctx context.Context, in *CronPagingRequest, opts ...grpc.CallOption) (*CronPagingResponse, error)
	CronStart(ctx context.Context, in *CronStartRequest, opts ...grpc.CallOption) (*CronStartResponse, error)
	CronStop(ctx context.Context, in *CronStopRequest, opts ...grpc.CallOption) (*CronStopResponse, error)
	CronDelete(ctx context.Context, in *CronDeleteRequest, opts ...grpc.CallOption) (*CronDeleteResponse, error)
	CronGet(ctx context.Context, in *CronGetRequest, opts ...grpc.CallOption) (*CronGetResponse, error)
	CronUpdate(ctx context.Context, in *CronUpdateRequest, opts ...grpc.CallOption) (*CronUpdateResponse, error)
}

type cronServiceClient struct {
	cc grpc1.ClientConnInterface
}

func NewCronServiceClient(cc grpc1.ClientConnInterface) CronServiceClient {
	return &cronServiceClient{cc}
}

func (c *cronServiceClient) CronCreate(ctx context.Context, in *CronCreateRequest, opts ...grpc.CallOption) (*CronCreateResponse, error) {
	out := new(CronCreateResponse)
	err := c.cc.Invoke(ctx, "/erda.core.pipeline.cron.CronService/CronCreate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cronServiceClient) CronPaging(ctx context.Context, in *CronPagingRequest, opts ...grpc.CallOption) (*CronPagingResponse, error) {
	out := new(CronPagingResponse)
	err := c.cc.Invoke(ctx, "/erda.core.pipeline.cron.CronService/CronPaging", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cronServiceClient) CronStart(ctx context.Context, in *CronStartRequest, opts ...grpc.CallOption) (*CronStartResponse, error) {
	out := new(CronStartResponse)
	err := c.cc.Invoke(ctx, "/erda.core.pipeline.cron.CronService/CronStart", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cronServiceClient) CronStop(ctx context.Context, in *CronStopRequest, opts ...grpc.CallOption) (*CronStopResponse, error) {
	out := new(CronStopResponse)
	err := c.cc.Invoke(ctx, "/erda.core.pipeline.cron.CronService/CronStop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cronServiceClient) CronDelete(ctx context.Context, in *CronDeleteRequest, opts ...grpc.CallOption) (*CronDeleteResponse, error) {
	out := new(CronDeleteResponse)
	err := c.cc.Invoke(ctx, "/erda.core.pipeline.cron.CronService/CronDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cronServiceClient) CronGet(ctx context.Context, in *CronGetRequest, opts ...grpc.CallOption) (*CronGetResponse, error) {
	out := new(CronGetResponse)
	err := c.cc.Invoke(ctx, "/erda.core.pipeline.cron.CronService/CronGet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cronServiceClient) CronUpdate(ctx context.Context, in *CronUpdateRequest, opts ...grpc.CallOption) (*CronUpdateResponse, error) {
	out := new(CronUpdateResponse)
	err := c.cc.Invoke(ctx, "/erda.core.pipeline.cron.CronService/CronUpdate", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CronServiceServer is the server API for CronService service.
// All implementations should embed UnimplementedCronServiceServer
// for forward compatibility
type CronServiceServer interface {
	CronCreate(context.Context, *CronCreateRequest) (*CronCreateResponse, error)
	CronPaging(context.Context, *CronPagingRequest) (*CronPagingResponse, error)
	CronStart(context.Context, *CronStartRequest) (*CronStartResponse, error)
	CronStop(context.Context, *CronStopRequest) (*CronStopResponse, error)
	CronDelete(context.Context, *CronDeleteRequest) (*CronDeleteResponse, error)
	CronGet(context.Context, *CronGetRequest) (*CronGetResponse, error)
	CronUpdate(context.Context, *CronUpdateRequest) (*CronUpdateResponse, error)
}

// UnimplementedCronServiceServer should be embedded to have forward compatible implementations.
type UnimplementedCronServiceServer struct {
}

func (*UnimplementedCronServiceServer) CronCreate(context.Context, *CronCreateRequest) (*CronCreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CronCreate not implemented")
}
func (*UnimplementedCronServiceServer) CronPaging(context.Context, *CronPagingRequest) (*CronPagingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CronPaging not implemented")
}
func (*UnimplementedCronServiceServer) CronStart(context.Context, *CronStartRequest) (*CronStartResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CronStart not implemented")
}
func (*UnimplementedCronServiceServer) CronStop(context.Context, *CronStopRequest) (*CronStopResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CronStop not implemented")
}
func (*UnimplementedCronServiceServer) CronDelete(context.Context, *CronDeleteRequest) (*CronDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CronDelete not implemented")
}
func (*UnimplementedCronServiceServer) CronGet(context.Context, *CronGetRequest) (*CronGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CronGet not implemented")
}
func (*UnimplementedCronServiceServer) CronUpdate(context.Context, *CronUpdateRequest) (*CronUpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CronUpdate not implemented")
}

func RegisterCronServiceServer(s grpc1.ServiceRegistrar, srv CronServiceServer, opts ...grpc1.HandleOption) {
	s.RegisterService(_get_CronService_serviceDesc(srv, opts...), srv)
}

var _CronService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "erda.core.pipeline.cron.CronService",
	HandlerType: (*CronServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams:     []grpc.StreamDesc{},
	Metadata:    "cron.proto",
}

func _get_CronService_serviceDesc(srv CronServiceServer, opts ...grpc1.HandleOption) *grpc.ServiceDesc {
	h := grpc1.DefaultHandleOptions()
	for _, op := range opts {
		op(h)
	}

	_CronService_CronCreate_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.CronCreate(ctx, req.(*CronCreateRequest))
	}
	var _CronService_CronCreate_info transport.ServiceInfo
	if h.Interceptor != nil {
		_CronService_CronCreate_info = transport.NewServiceInfo("erda.core.pipeline.cron.CronService", "CronCreate", srv)
		_CronService_CronCreate_Handler = h.Interceptor(_CronService_CronCreate_Handler)
	}

	_CronService_CronPaging_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.CronPaging(ctx, req.(*CronPagingRequest))
	}
	var _CronService_CronPaging_info transport.ServiceInfo
	if h.Interceptor != nil {
		_CronService_CronPaging_info = transport.NewServiceInfo("erda.core.pipeline.cron.CronService", "CronPaging", srv)
		_CronService_CronPaging_Handler = h.Interceptor(_CronService_CronPaging_Handler)
	}

	_CronService_CronStart_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.CronStart(ctx, req.(*CronStartRequest))
	}
	var _CronService_CronStart_info transport.ServiceInfo
	if h.Interceptor != nil {
		_CronService_CronStart_info = transport.NewServiceInfo("erda.core.pipeline.cron.CronService", "CronStart", srv)
		_CronService_CronStart_Handler = h.Interceptor(_CronService_CronStart_Handler)
	}

	_CronService_CronStop_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.CronStop(ctx, req.(*CronStopRequest))
	}
	var _CronService_CronStop_info transport.ServiceInfo
	if h.Interceptor != nil {
		_CronService_CronStop_info = transport.NewServiceInfo("erda.core.pipeline.cron.CronService", "CronStop", srv)
		_CronService_CronStop_Handler = h.Interceptor(_CronService_CronStop_Handler)
	}

	_CronService_CronDelete_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.CronDelete(ctx, req.(*CronDeleteRequest))
	}
	var _CronService_CronDelete_info transport.ServiceInfo
	if h.Interceptor != nil {
		_CronService_CronDelete_info = transport.NewServiceInfo("erda.core.pipeline.cron.CronService", "CronDelete", srv)
		_CronService_CronDelete_Handler = h.Interceptor(_CronService_CronDelete_Handler)
	}

	_CronService_CronGet_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.CronGet(ctx, req.(*CronGetRequest))
	}
	var _CronService_CronGet_info transport.ServiceInfo
	if h.Interceptor != nil {
		_CronService_CronGet_info = transport.NewServiceInfo("erda.core.pipeline.cron.CronService", "CronGet", srv)
		_CronService_CronGet_Handler = h.Interceptor(_CronService_CronGet_Handler)
	}

	_CronService_CronUpdate_Handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.CronUpdate(ctx, req.(*CronUpdateRequest))
	}
	var _CronService_CronUpdate_info transport.ServiceInfo
	if h.Interceptor != nil {
		_CronService_CronUpdate_info = transport.NewServiceInfo("erda.core.pipeline.cron.CronService", "CronUpdate", srv)
		_CronService_CronUpdate_Handler = h.Interceptor(_CronService_CronUpdate_Handler)
	}

	var serviceDesc = _CronService_serviceDesc
	serviceDesc.Methods = []grpc.MethodDesc{
		{
			MethodName: "CronCreate",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(CronCreateRequest)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(CronServiceServer).CronCreate(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _CronService_CronCreate_info)
				}
				if interceptor == nil {
					return _CronService_CronCreate_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.core.pipeline.cron.CronService/CronCreate",
				}
				return interceptor(ctx, in, info, _CronService_CronCreate_Handler)
			},
		},
		{
			MethodName: "CronPaging",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(CronPagingRequest)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(CronServiceServer).CronPaging(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _CronService_CronPaging_info)
				}
				if interceptor == nil {
					return _CronService_CronPaging_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.core.pipeline.cron.CronService/CronPaging",
				}
				return interceptor(ctx, in, info, _CronService_CronPaging_Handler)
			},
		},
		{
			MethodName: "CronStart",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(CronStartRequest)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(CronServiceServer).CronStart(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _CronService_CronStart_info)
				}
				if interceptor == nil {
					return _CronService_CronStart_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.core.pipeline.cron.CronService/CronStart",
				}
				return interceptor(ctx, in, info, _CronService_CronStart_Handler)
			},
		},
		{
			MethodName: "CronStop",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(CronStopRequest)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(CronServiceServer).CronStop(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _CronService_CronStop_info)
				}
				if interceptor == nil {
					return _CronService_CronStop_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.core.pipeline.cron.CronService/CronStop",
				}
				return interceptor(ctx, in, info, _CronService_CronStop_Handler)
			},
		},
		{
			MethodName: "CronDelete",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(CronDeleteRequest)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(CronServiceServer).CronDelete(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _CronService_CronDelete_info)
				}
				if interceptor == nil {
					return _CronService_CronDelete_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.core.pipeline.cron.CronService/CronDelete",
				}
				return interceptor(ctx, in, info, _CronService_CronDelete_Handler)
			},
		},
		{
			MethodName: "CronGet",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(CronGetRequest)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(CronServiceServer).CronGet(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _CronService_CronGet_info)
				}
				if interceptor == nil {
					return _CronService_CronGet_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.core.pipeline.cron.CronService/CronGet",
				}
				return interceptor(ctx, in, info, _CronService_CronGet_Handler)
			},
		},
		{
			MethodName: "CronUpdate",
			Handler: func(_ interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
				in := new(CronUpdateRequest)
				if err := dec(in); err != nil {
					return nil, err
				}
				if interceptor == nil && h.Interceptor == nil {
					return srv.(CronServiceServer).CronUpdate(ctx, in)
				}
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, _CronService_CronUpdate_info)
				}
				if interceptor == nil {
					return _CronService_CronUpdate_Handler(ctx, in)
				}
				info := &grpc.UnaryServerInfo{
					Server:     srv,
					FullMethod: "/erda.core.pipeline.cron.CronService/CronUpdate",
				}
				return interceptor(ctx, in, info, _CronService_CronUpdate_Handler)
			},
		},
	}
	return &serviceDesc
}
