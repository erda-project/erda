// Code generated by protoc-gen-go-form. DO NOT EDIT.
// Source: release.proto

package pb

import (
	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	url "net/url"
	strconv "strconv"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/urlenc" package it is being compiled against.
var _ urlenc.URLValuesUnmarshaler = (*ReleaseCreateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ReleaseResource)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ReleaseCreateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ReleaseCreateResponseData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ReleaseUpdateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ReleaseDataResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ReleaseUserDataResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ReleaseUpdateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ReleaseReferenceUpdateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetIosPlistRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetIosPlistResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ReleaseDeleteRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ReleaseDeleteResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ReleaseGetRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ReleaseGetResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ReleaseGetResponseData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ReleaseListRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ReleaseListResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListReleaseNameRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListReleaseNameResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ReleaseListResponseData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ReleaseNameListRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ReleaseNameListResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetLatestReleasesRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetLatestReleasesResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetLatestReleasesResponseData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ReleaseGCRequest)(nil)

// ReleaseCreateRequest implement urlenc.URLValuesUnmarshaler.
func (m *ReleaseCreateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "releaseName":
				m.ReleaseName = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "dice":
				m.Dice = vals[0]
			case "addon":
				m.Addon = vals[0]
			case "version":
				m.Version = vals[0]
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "projectID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "applicationID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ApplicationID = val
			case "projectName":
				m.ProjectName = vals[0]
			case "applicationName":
				m.ApplicationName = vals[0]
			case "userID":
				m.UserID = vals[0]
			case "clusterName":
				m.ClusterName = vals[0]
			case "crossCluster":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.CrossCluster = val
			}
		}
	}
	return nil
}

// ReleaseResource implement urlenc.URLValuesUnmarshaler.
func (m *ReleaseResource) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "type":
				m.Type = vals[0]
			case "name":
				m.Name = vals[0]
			case "URL":
				m.URL = vals[0]
			}
		}
	}
	return nil
}

// ReleaseCreateResponse implement urlenc.URLValuesUnmarshaler.
func (m *ReleaseCreateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &ReleaseCreateResponseData{}
				}
			case "data.releaseID":
				if m.Data == nil {
					m.Data = &ReleaseCreateResponseData{}
				}
				m.Data.ReleaseID = vals[0]
			}
		}
	}
	return nil
}

// ReleaseCreateResponseData implement urlenc.URLValuesUnmarshaler.
func (m *ReleaseCreateResponseData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "releaseID":
				m.ReleaseID = vals[0]
			}
		}
	}
	return nil
}

// ReleaseUpdateRequest implement urlenc.URLValuesUnmarshaler.
func (m *ReleaseUpdateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "releaseID":
				m.ReleaseID = vals[0]
			case "version":
				m.Version = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "projectID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "applicationID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ApplicationID = val
			}
		}
	}
	return nil
}

// ReleaseDataResponse implement urlenc.URLValuesUnmarshaler.
func (m *ReleaseDataResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				m.Data = vals[0]
			}
		}
	}
	return nil
}

// ReleaseUserDataResponse implement urlenc.URLValuesUnmarshaler.
func (m *ReleaseUserDataResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				m.Data = vals[0]
			case "userIDs":
				m.UserIDs = vals
			}
		}
	}
	return nil
}

// ReleaseUpdateResponse implement urlenc.URLValuesUnmarshaler.
func (m *ReleaseUpdateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				m.Data = vals[0]
			}
		}
	}
	return nil
}

// ReleaseReferenceUpdateRequest implement urlenc.URLValuesUnmarshaler.
func (m *ReleaseReferenceUpdateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "releaseID":
				m.ReleaseID = vals[0]
			case "increase":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Increase = val
			}
		}
	}
	return nil
}

// GetIosPlistRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetIosPlistRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "releaseID":
				m.ReleaseID = vals[0]
			}
		}
	}
	return nil
}

// GetIosPlistResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetIosPlistResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				m.Data = vals[0]
			}
		}
	}
	return nil
}

// ReleaseDeleteRequest implement urlenc.URLValuesUnmarshaler.
func (m *ReleaseDeleteRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "releaseID":
				m.ReleaseID = vals[0]
			}
		}
	}
	return nil
}

// ReleaseDeleteResponse implement urlenc.URLValuesUnmarshaler.
func (m *ReleaseDeleteResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				m.Data = vals[0]
			}
		}
	}
	return nil
}

// ReleaseGetRequest implement urlenc.URLValuesUnmarshaler.
func (m *ReleaseGetRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "releaseID":
				m.ReleaseID = vals[0]
			}
		}
	}
	return nil
}

// ReleaseGetResponse implement urlenc.URLValuesUnmarshaler.
func (m *ReleaseGetResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &ReleaseGetResponseData{}
				}
			case "data.releaseID":
				if m.Data == nil {
					m.Data = &ReleaseGetResponseData{}
				}
				m.Data.ReleaseID = vals[0]
			case "data.releaseName":
				if m.Data == nil {
					m.Data = &ReleaseGetResponseData{}
				}
				m.Data.ReleaseName = vals[0]
			case "data.diceyml":
				if m.Data == nil {
					m.Data = &ReleaseGetResponseData{}
				}
				m.Data.Diceyml = vals[0]
			case "data.desc":
				if m.Data == nil {
					m.Data = &ReleaseGetResponseData{}
				}
				m.Data.Desc = vals[0]
			case "data.addon":
				if m.Data == nil {
					m.Data = &ReleaseGetResponseData{}
				}
				m.Data.Addon = vals[0]
			case "data.images":
				if m.Data == nil {
					m.Data = &ReleaseGetResponseData{}
				}
				m.Data.Images = vals
			case "data.version":
				if m.Data == nil {
					m.Data = &ReleaseGetResponseData{}
				}
				m.Data.Version = vals[0]
			case "data.crossCluster":
				if m.Data == nil {
					m.Data = &ReleaseGetResponseData{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.CrossCluster = val
			case "data.reference":
				if m.Data == nil {
					m.Data = &ReleaseGetResponseData{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Reference = val
			case "data.orgID":
				if m.Data == nil {
					m.Data = &ReleaseGetResponseData{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.OrgID = val
			case "data.projectID":
				if m.Data == nil {
					m.Data = &ReleaseGetResponseData{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ProjectID = val
			case "data.applicationID":
				if m.Data == nil {
					m.Data = &ReleaseGetResponseData{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ApplicationID = val
			case "data.projectName":
				if m.Data == nil {
					m.Data = &ReleaseGetResponseData{}
				}
				m.Data.ProjectName = vals[0]
			case "data.applicationName":
				if m.Data == nil {
					m.Data = &ReleaseGetResponseData{}
				}
				m.Data.ApplicationName = vals[0]
			case "data.userID":
				if m.Data == nil {
					m.Data = &ReleaseGetResponseData{}
				}
				m.Data.UserID = vals[0]
			case "data.clusterName":
				if m.Data == nil {
					m.Data = &ReleaseGetResponseData{}
				}
				m.Data.ClusterName = vals[0]
			case "data.createdAt":
				if m.Data == nil {
					m.Data = &ReleaseGetResponseData{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
			case "data.createdAt.seconds":
				if m.Data == nil {
					m.Data = &ReleaseGetResponseData{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Seconds = val
			case "data.createdAt.nanos":
				if m.Data == nil {
					m.Data = &ReleaseGetResponseData{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Nanos = int32(val)
			case "data.updatedAt":
				if m.Data == nil {
					m.Data = &ReleaseGetResponseData{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "data.updatedAt.seconds":
				if m.Data == nil {
					m.Data = &ReleaseGetResponseData{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.UpdatedAt.Seconds = val
			case "data.updatedAt.nanos":
				if m.Data == nil {
					m.Data = &ReleaseGetResponseData{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.UpdatedAt.Nanos = int32(val)
			}
		}
	}
	return nil
}

// ReleaseGetResponseData implement urlenc.URLValuesUnmarshaler.
func (m *ReleaseGetResponseData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "releaseID":
				m.ReleaseID = vals[0]
			case "releaseName":
				m.ReleaseName = vals[0]
			case "diceyml":
				m.Diceyml = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "addon":
				m.Addon = vals[0]
			case "images":
				m.Images = vals
			case "version":
				m.Version = vals[0]
			case "crossCluster":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.CrossCluster = val
			case "reference":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Reference = val
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "projectID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "applicationID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ApplicationID = val
			case "projectName":
				m.ProjectName = vals[0]
			case "applicationName":
				m.ApplicationName = vals[0]
			case "userID":
				m.UserID = vals[0]
			case "clusterName":
				m.ClusterName = vals[0]
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			}
		}
	}
	return nil
}

// ReleaseListRequest implement urlenc.URLValuesUnmarshaler.
func (m *ReleaseListRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "query":
				m.Query = vals[0]
			case "releaseName":
				m.ReleaseName = vals[0]
			case "cluster":
				m.Cluster = vals[0]
			case "branch":
				m.Branch = vals[0]
			case "isVersion":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsVersion = val
			case "crossCluster":
				m.CrossCluster = vals[0]
			case "crossClusterOrSpecifyCluster":
				m.CrossClusterOrSpecifyCluster = vals[0]
			case "applicationID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ApplicationID = val
			case "projectID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "startTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.StartTime = val
			case "endTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.EndTime = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			case "pageNum":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNum = val
			}
		}
	}
	return nil
}

// ReleaseListResponse implement urlenc.URLValuesUnmarshaler.
func (m *ReleaseListResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &ReleaseListResponseData{}
				}
			case "data.total":
				if m.Data == nil {
					m.Data = &ReleaseListResponseData{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Total = val
			case "userIDs":
				m.UserIDs = vals
			}
		}
	}
	return nil
}

// ListReleaseNameRequest implement urlenc.URLValuesUnmarshaler.
func (m *ListReleaseNameRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "applicationId":
				m.ApplicationId = vals[0]
			}
		}
	}
	return nil
}

// ListReleaseNameResponse implement urlenc.URLValuesUnmarshaler.
func (m *ListReleaseNameResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				m.Data = vals
			}
		}
	}
	return nil
}

// ReleaseListResponseData implement urlenc.URLValuesUnmarshaler.
func (m *ReleaseListResponseData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// ReleaseNameListRequest implement urlenc.URLValuesUnmarshaler.
func (m *ReleaseNameListRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "applicationID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ApplicationID = val
			}
		}
	}
	return nil
}

// ReleaseNameListResponse implement urlenc.URLValuesUnmarshaler.
func (m *ReleaseNameListResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				m.Data = vals
			}
		}
	}
	return nil
}

// GetLatestReleasesRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetLatestReleasesRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectID":
				m.ProjectID = vals[0]
			case "version":
				m.Version = vals[0]
			}
		}
	}
	return nil
}

// GetLatestReleasesResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetLatestReleasesResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// GetLatestReleasesResponseData implement urlenc.URLValuesUnmarshaler.
func (m *GetLatestReleasesResponseData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "releaseID":
				m.ReleaseID = vals[0]
			case "releaseName":
				m.ReleaseName = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "dice":
				m.Dice = vals[0]
			case "addon":
				m.Addon = vals[0]
			case "labels":
				m.Labels = vals[0]
			case "version":
				m.Version = vals[0]
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "projectID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "applicationID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ApplicationID = val
			case "projectName":
				m.ProjectName = vals[0]
			case "applicationName":
				m.ApplicationName = vals[0]
			case "userID":
				m.UserID = vals[0]
			case "clusterName":
				m.ClusterName = vals[0]
			case "resources":
				m.Resources = vals[0]
			case "reference":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Reference = val
			case "crossCluster":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.CrossCluster = val
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			}
		}
	}
	return nil
}

// ReleaseGCRequest implement urlenc.URLValuesUnmarshaler.
func (m *ReleaseGCRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}
