// Code generated by protoc-gen-go-form. DO NOT EDIT.
// Source: template.proto

package pb

import (
	json "encoding/json"
	url "net/url"
	strconv "strconv"
	strings "strings"

	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
	structpb "google.golang.org/protobuf/types/known/structpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/urlenc" package it is being compiled against.
var _ urlenc.URLValuesUnmarshaler = (*PipelineTemplateCreateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineTemplateCreateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineTemplateApplyRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineTemplateQueryRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineTemplateQueryResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineTemplateQueryResponseData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineTemplateVersionGetRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineTemplateVersionGetResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineTemplateVersionQueryRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineTemplateVersionQueryResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineTemplateRenderRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineTemplateRenderSpecRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineTemplateRenderResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineTemplateSearchResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineTemplateRender)(nil)
var _ urlenc.URLValuesUnmarshaler = (*SnippetFormatOutputs)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineTemplate)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineTemplateVersion)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineTemplateSpec)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineTemplateSpecOutput)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QuerySnippetYmlRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QuerySnippetYmlResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineParam)(nil)
var _ urlenc.URLValuesUnmarshaler = (*PipelineOutput)(nil)

// PipelineTemplateCreateRequest implement urlenc.URLValuesUnmarshaler.
func (m *PipelineTemplateCreateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals[0]
			case "logoUrl":
				m.LogoUrl = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "scopeType":
				m.ScopeType = vals[0]
			case "scopeID":
				m.ScopeID = vals[0]
			case "spec":
				m.Spec = vals[0]
			case "version":
				m.Version = vals[0]
			case "readme":
				m.Readme = vals[0]
			case "defaultVersion":
				m.DefaultVersion = vals[0]
			}
		}
	}
	return nil
}

// PipelineTemplateCreateResponse implement urlenc.URLValuesUnmarshaler.
func (m *PipelineTemplateCreateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &PipelineTemplate{}
				}
			case "data.id":
				if m.Data == nil {
					m.Data = &PipelineTemplate{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Id = val
			case "data.name":
				if m.Data == nil {
					m.Data = &PipelineTemplate{}
				}
				m.Data.Name = vals[0]
			case "data.desc":
				if m.Data == nil {
					m.Data = &PipelineTemplate{}
				}
				m.Data.Desc = vals[0]
			case "data.logoUrl":
				if m.Data == nil {
					m.Data = &PipelineTemplate{}
				}
				m.Data.LogoUrl = vals[0]
			case "data.scopeType":
				if m.Data == nil {
					m.Data = &PipelineTemplate{}
				}
				m.Data.ScopeType = vals[0]
			case "data.scopeID":
				if m.Data == nil {
					m.Data = &PipelineTemplate{}
				}
				m.Data.ScopeID = vals[0]
			case "data.createdAt":
				if m.Data == nil {
					m.Data = &PipelineTemplate{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
			case "data.createdAt.seconds":
				if m.Data == nil {
					m.Data = &PipelineTemplate{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Seconds = val
			case "data.createdAt.nanos":
				if m.Data == nil {
					m.Data = &PipelineTemplate{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Nanos = int32(val)
			case "data.updatedAt":
				if m.Data == nil {
					m.Data = &PipelineTemplate{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "data.updatedAt.seconds":
				if m.Data == nil {
					m.Data = &PipelineTemplate{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.UpdatedAt.Seconds = val
			case "data.updatedAt.nanos":
				if m.Data == nil {
					m.Data = &PipelineTemplate{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.UpdatedAt.Nanos = int32(val)
			case "data.version":
				if m.Data == nil {
					m.Data = &PipelineTemplate{}
				}
				m.Data.Version = vals[0]
			}
		}
	}
	return nil
}

// PipelineTemplateApplyRequest implement urlenc.URLValuesUnmarshaler.
func (m *PipelineTemplateApplyRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "spec":
				m.Spec = vals[0]
			case "scopeType":
				m.ScopeType = vals[0]
			case "scopeID":
				m.ScopeID = vals[0]
			}
		}
	}
	return nil
}

// PipelineTemplateQueryRequest implement urlenc.URLValuesUnmarshaler.
func (m *PipelineTemplateQueryRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "scopeType":
				m.ScopeType = vals[0]
			case "scopeID":
				m.ScopeID = vals[0]
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.PageNo = int32(val)
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.PageSize = int32(val)
			case "name":
				m.Name = vals[0]
			}
		}
	}
	return nil
}

// PipelineTemplateQueryResponse implement urlenc.URLValuesUnmarshaler.
func (m *PipelineTemplateQueryResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &PipelineTemplateQueryResponseData{}
				}
			case "data.total":
				if m.Data == nil {
					m.Data = &PipelineTemplateQueryResponseData{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.Total = int32(val)
			}
		}
	}
	return nil
}

// PipelineTemplateQueryResponseData implement urlenc.URLValuesUnmarshaler.
func (m *PipelineTemplateQueryResponseData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Total = int32(val)
			}
		}
	}
	return nil
}

// PipelineTemplateVersionGetRequest implement urlenc.URLValuesUnmarshaler.
func (m *PipelineTemplateVersionGetRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "scopeType":
				m.ScopeType = vals[0]
			case "scopeID":
				m.ScopeID = vals[0]
			case "name":
				m.Name = vals[0]
			case "version":
				m.Version = vals[0]
			}
		}
	}
	return nil
}

// PipelineTemplateVersionGetResponse implement urlenc.URLValuesUnmarshaler.
func (m *PipelineTemplateVersionGetResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &PipelineTemplateVersion{}
				}
			case "data.id":
				if m.Data == nil {
					m.Data = &PipelineTemplateVersion{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Id = val
			case "data.templateId":
				if m.Data == nil {
					m.Data = &PipelineTemplateVersion{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.TemplateId = val
			case "data.name":
				if m.Data == nil {
					m.Data = &PipelineTemplateVersion{}
				}
				m.Data.Name = vals[0]
			case "data.version":
				if m.Data == nil {
					m.Data = &PipelineTemplateVersion{}
				}
				m.Data.Version = vals[0]
			case "data.spec":
				if m.Data == nil {
					m.Data = &PipelineTemplateVersion{}
				}
				m.Data.Spec = vals[0]
			case "data.readme":
				if m.Data == nil {
					m.Data = &PipelineTemplateVersion{}
				}
				m.Data.Readme = vals[0]
			case "data.createdAt":
				if m.Data == nil {
					m.Data = &PipelineTemplateVersion{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
			case "data.createdAt.seconds":
				if m.Data == nil {
					m.Data = &PipelineTemplateVersion{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Seconds = val
			case "data.createdAt.nanos":
				if m.Data == nil {
					m.Data = &PipelineTemplateVersion{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Nanos = int32(val)
			case "data.updatedAt":
				if m.Data == nil {
					m.Data = &PipelineTemplateVersion{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "data.updatedAt.seconds":
				if m.Data == nil {
					m.Data = &PipelineTemplateVersion{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.UpdatedAt.Seconds = val
			case "data.updatedAt.nanos":
				if m.Data == nil {
					m.Data = &PipelineTemplateVersion{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.UpdatedAt.Nanos = int32(val)
			}
		}
	}
	return nil
}

// PipelineTemplateVersionQueryRequest implement urlenc.URLValuesUnmarshaler.
func (m *PipelineTemplateVersionQueryRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "scopeType":
				m.ScopeType = vals[0]
			case "scopeID":
				m.ScopeID = vals[0]
			case "name":
				m.Name = vals[0]
			}
		}
	}
	return nil
}

// PipelineTemplateVersionQueryResponse implement urlenc.URLValuesUnmarshaler.
func (m *PipelineTemplateVersionQueryResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// PipelineTemplateRenderRequest implement urlenc.URLValuesUnmarshaler.
func (m *PipelineTemplateRenderRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "scopeType":
				m.ScopeType = vals[0]
			case "scopeID":
				m.ScopeID = vals[0]
			case "name":
				m.Name = vals[0]
			case "version":
				m.Version = vals[0]
			case "alias":
				m.Alias = vals[0]
			case "templateVersion":
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.TemplateVersion = int32(val)
			}
		}
	}
	return nil
}

// PipelineTemplateRenderSpecRequest implement urlenc.URLValuesUnmarshaler.
func (m *PipelineTemplateRenderSpecRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "spec":
				if m.Spec == nil {
					m.Spec = &PipelineTemplateSpec{}
				}
			case "spec.name":
				if m.Spec == nil {
					m.Spec = &PipelineTemplateSpec{}
				}
				m.Spec.Name = vals[0]
			case "spec.version":
				if m.Spec == nil {
					m.Spec = &PipelineTemplateSpec{}
				}
				m.Spec.Version = vals[0]
			case "spec.desc":
				if m.Spec == nil {
					m.Spec = &PipelineTemplateSpec{}
				}
				m.Spec.Desc = vals[0]
			case "spec.logoUrl":
				if m.Spec == nil {
					m.Spec = &PipelineTemplateSpec{}
				}
				m.Spec.LogoUrl = vals[0]
			case "spec.template":
				if m.Spec == nil {
					m.Spec = &PipelineTemplateSpec{}
				}
				m.Spec.Template = vals[0]
			case "spec.defaultVersion":
				if m.Spec == nil {
					m.Spec = &PipelineTemplateSpec{}
				}
				m.Spec.DefaultVersion = vals[0]
			case "alias":
				m.Alias = vals[0]
			case "templateVersion":
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.TemplateVersion = int32(val)
			}
		}
	}
	return nil
}

// PipelineTemplateRenderResponse implement urlenc.URLValuesUnmarshaler.
func (m *PipelineTemplateRenderResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &PipelineTemplateRender{}
				}
			case "data.pipelineYaml":
				if m.Data == nil {
					m.Data = &PipelineTemplateRender{}
				}
				m.Data.PipelineYaml = vals[0]
			case "data.version":
				if m.Data == nil {
					m.Data = &PipelineTemplateRender{}
				}
				if m.Data.Version == nil {
					m.Data.Version = &PipelineTemplateVersion{}
				}
			case "data.version.id":
				if m.Data == nil {
					m.Data = &PipelineTemplateRender{}
				}
				if m.Data.Version == nil {
					m.Data.Version = &PipelineTemplateVersion{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Version.Id = val
			case "data.version.templateId":
				if m.Data == nil {
					m.Data = &PipelineTemplateRender{}
				}
				if m.Data.Version == nil {
					m.Data.Version = &PipelineTemplateVersion{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Version.TemplateId = val
			case "data.version.name":
				if m.Data == nil {
					m.Data = &PipelineTemplateRender{}
				}
				if m.Data.Version == nil {
					m.Data.Version = &PipelineTemplateVersion{}
				}
				m.Data.Version.Name = vals[0]
			case "data.version.version":
				if m.Data == nil {
					m.Data = &PipelineTemplateRender{}
				}
				if m.Data.Version == nil {
					m.Data.Version = &PipelineTemplateVersion{}
				}
				m.Data.Version.Version = vals[0]
			case "data.version.spec":
				if m.Data == nil {
					m.Data = &PipelineTemplateRender{}
				}
				if m.Data.Version == nil {
					m.Data.Version = &PipelineTemplateVersion{}
				}
				m.Data.Version.Spec = vals[0]
			case "data.version.readme":
				if m.Data == nil {
					m.Data = &PipelineTemplateRender{}
				}
				if m.Data.Version == nil {
					m.Data.Version = &PipelineTemplateVersion{}
				}
				m.Data.Version.Readme = vals[0]
			case "data.version.createdAt":
				if m.Data == nil {
					m.Data = &PipelineTemplateRender{}
				}
				if m.Data.Version == nil {
					m.Data.Version = &PipelineTemplateVersion{}
				}
				if m.Data.Version.CreatedAt == nil {
					m.Data.Version.CreatedAt = &timestamppb.Timestamp{}
				}
			case "data.version.createdAt.seconds":
				if m.Data == nil {
					m.Data = &PipelineTemplateRender{}
				}
				if m.Data.Version == nil {
					m.Data.Version = &PipelineTemplateVersion{}
				}
				if m.Data.Version.CreatedAt == nil {
					m.Data.Version.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Version.CreatedAt.Seconds = val
			case "data.version.createdAt.nanos":
				if m.Data == nil {
					m.Data = &PipelineTemplateRender{}
				}
				if m.Data.Version == nil {
					m.Data.Version = &PipelineTemplateVersion{}
				}
				if m.Data.Version.CreatedAt == nil {
					m.Data.Version.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.Version.CreatedAt.Nanos = int32(val)
			case "data.version.updatedAt":
				if m.Data == nil {
					m.Data = &PipelineTemplateRender{}
				}
				if m.Data.Version == nil {
					m.Data.Version = &PipelineTemplateVersion{}
				}
				if m.Data.Version.UpdatedAt == nil {
					m.Data.Version.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "data.version.updatedAt.seconds":
				if m.Data == nil {
					m.Data = &PipelineTemplateRender{}
				}
				if m.Data.Version == nil {
					m.Data.Version = &PipelineTemplateVersion{}
				}
				if m.Data.Version.UpdatedAt == nil {
					m.Data.Version.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Version.UpdatedAt.Seconds = val
			case "data.version.updatedAt.nanos":
				if m.Data == nil {
					m.Data = &PipelineTemplateRender{}
				}
				if m.Data.Version == nil {
					m.Data.Version = &PipelineTemplateVersion{}
				}
				if m.Data.Version.UpdatedAt == nil {
					m.Data.Version.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.Version.UpdatedAt.Nanos = int32(val)
			}
		}
	}
	return nil
}

// PipelineTemplateSearchResponse implement urlenc.URLValuesUnmarshaler.
func (m *PipelineTemplateSearchResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// PipelineTemplateRender implement urlenc.URLValuesUnmarshaler.
func (m *PipelineTemplateRender) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pipelineYaml":
				m.PipelineYaml = vals[0]
			case "version":
				if m.Version == nil {
					m.Version = &PipelineTemplateVersion{}
				}
			case "version.id":
				if m.Version == nil {
					m.Version = &PipelineTemplateVersion{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Version.Id = val
			case "version.templateId":
				if m.Version == nil {
					m.Version = &PipelineTemplateVersion{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Version.TemplateId = val
			case "version.name":
				if m.Version == nil {
					m.Version = &PipelineTemplateVersion{}
				}
				m.Version.Name = vals[0]
			case "version.version":
				if m.Version == nil {
					m.Version = &PipelineTemplateVersion{}
				}
				m.Version.Version = vals[0]
			case "version.spec":
				if m.Version == nil {
					m.Version = &PipelineTemplateVersion{}
				}
				m.Version.Spec = vals[0]
			case "version.readme":
				if m.Version == nil {
					m.Version = &PipelineTemplateVersion{}
				}
				m.Version.Readme = vals[0]
			case "version.createdAt":
				if m.Version == nil {
					m.Version = &PipelineTemplateVersion{}
				}
				if m.Version.CreatedAt == nil {
					m.Version.CreatedAt = &timestamppb.Timestamp{}
				}
			case "version.createdAt.seconds":
				if m.Version == nil {
					m.Version = &PipelineTemplateVersion{}
				}
				if m.Version.CreatedAt == nil {
					m.Version.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Version.CreatedAt.Seconds = val
			case "version.createdAt.nanos":
				if m.Version == nil {
					m.Version = &PipelineTemplateVersion{}
				}
				if m.Version.CreatedAt == nil {
					m.Version.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Version.CreatedAt.Nanos = int32(val)
			case "version.updatedAt":
				if m.Version == nil {
					m.Version = &PipelineTemplateVersion{}
				}
				if m.Version.UpdatedAt == nil {
					m.Version.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "version.updatedAt.seconds":
				if m.Version == nil {
					m.Version = &PipelineTemplateVersion{}
				}
				if m.Version.UpdatedAt == nil {
					m.Version.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Version.UpdatedAt.Seconds = val
			case "version.updatedAt.nanos":
				if m.Version == nil {
					m.Version = &PipelineTemplateVersion{}
				}
				if m.Version.UpdatedAt == nil {
					m.Version.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Version.UpdatedAt.Nanos = int32(val)
			}
		}
	}
	return nil
}

// SnippetFormatOutputs implement urlenc.URLValuesUnmarshaler.
func (m *SnippetFormatOutputs) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "preOutputName":
				m.PreOutputName = vals[0]
			case "afterOutputName":
				m.AfterOutputName = vals[0]
			}
		}
	}
	return nil
}

// PipelineTemplate implement urlenc.URLValuesUnmarshaler.
func (m *PipelineTemplate) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "name":
				m.Name = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "logoUrl":
				m.LogoUrl = vals[0]
			case "scopeType":
				m.ScopeType = vals[0]
			case "scopeID":
				m.ScopeID = vals[0]
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			case "version":
				m.Version = vals[0]
			}
		}
	}
	return nil
}

// PipelineTemplateVersion implement urlenc.URLValuesUnmarshaler.
func (m *PipelineTemplateVersion) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "templateId":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TemplateId = val
			case "name":
				m.Name = vals[0]
			case "version":
				m.Version = vals[0]
			case "spec":
				m.Spec = vals[0]
			case "readme":
				m.Readme = vals[0]
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			}
		}
	}
	return nil
}

// PipelineTemplateSpec implement urlenc.URLValuesUnmarshaler.
func (m *PipelineTemplateSpec) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals[0]
			case "version":
				m.Version = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "logoUrl":
				m.LogoUrl = vals[0]
			case "template":
				m.Template = vals[0]
			case "defaultVersion":
				m.DefaultVersion = vals[0]
			}
		}
	}
	return nil
}

// PipelineTemplateSpecOutput implement urlenc.URLValuesUnmarshaler.
func (m *PipelineTemplateSpecOutput) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "ref":
				m.Ref = vals[0]
			}
		}
	}
	return nil
}

// QuerySnippetYmlRequest implement urlenc.URLValuesUnmarshaler.
func (m *QuerySnippetYmlRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "source":
				m.Source = vals[0]
			case "name":
				m.Name = vals[0]
			}
		}
	}
	return nil
}

// QuerySnippetYmlResponse implement urlenc.URLValuesUnmarshaler.
func (m *QuerySnippetYmlResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				m.Data = vals[0]
			}
		}
	}
	return nil
}

// PipelineParam implement urlenc.URLValuesUnmarshaler.
func (m *PipelineParam) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals[0]
			case "required":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Required = val
			case "default":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Default = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Default = val
					} else {
						m.Default = structpb.NewStringValue(vals[0])
					}
				}
			case "desc":
				m.Desc = vals[0]
			case "type":
				m.Type = vals[0]
			}
		}
	}
	return nil
}

// PipelineOutput implement urlenc.URLValuesUnmarshaler.
func (m *PipelineOutput) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "ref":
				m.Ref = vals[0]
			}
		}
	}
	return nil
}
