// Code generated by protoc-gen-go-form. DO NOT EDIT.
// Source: extension.proto

package pb

import (
	json "encoding/json"
	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
	structpb "google.golang.org/protobuf/types/known/structpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	url "net/url"
	strconv "strconv"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/urlenc" package it is being compiled against.
var _ urlenc.URLValuesUnmarshaler = (*ExtensionSearchRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ExtensionSearchResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ExtensionCreateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ExtensionCreateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryExtensionsRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryExtensionsResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryExtensionsMenuRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryExtensionsMenuResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*Spec)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ExtensionVersionCreateRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ExtensionVersionCreateResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetExtensionVersionRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetExtensionVersionResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ExtensionQueryRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ExtensionQueryResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ExtensionVersionGetRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ExtensionVersionQueryRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ExtensionVersionGetResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ExtensionVersionQueryResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ExtensionMenu)(nil)
var _ urlenc.URLValuesUnmarshaler = (*Extension)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ExtensionVersion)(nil)

// ExtensionSearchRequest implement urlenc.URLValuesUnmarshaler.
func (m *ExtensionSearchRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "yamlFormat":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.YamlFormat = val
			case "extensions":
				m.Extensions = vals
			}
		}
	}
	return nil
}

// ExtensionSearchResponse implement urlenc.URLValuesUnmarshaler.
func (m *ExtensionSearchResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// ExtensionCreateRequest implement urlenc.URLValuesUnmarshaler.
func (m *ExtensionCreateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "type":
				m.Type = vals[0]
			case "name":
				m.Name = vals[0]
			case "displayName":
				m.DisplayName = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "category":
				m.Category = vals[0]
			case "logoUrl":
				m.LogoUrl = vals[0]
			case "public":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Public = val
			case "labels":
				m.Labels = vals[0]
			}
		}
	}
	return nil
}

// ExtensionCreateResponse implement urlenc.URLValuesUnmarshaler.
func (m *ExtensionCreateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &Extension{}
				}
			case "data.id":
				if m.Data == nil {
					m.Data = &Extension{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Id = val
			case "data.type":
				if m.Data == nil {
					m.Data = &Extension{}
				}
				m.Data.Type = vals[0]
			case "data.name":
				if m.Data == nil {
					m.Data = &Extension{}
				}
				m.Data.Name = vals[0]
			case "data.desc":
				if m.Data == nil {
					m.Data = &Extension{}
				}
				m.Data.Desc = vals[0]
			case "data.displayName":
				if m.Data == nil {
					m.Data = &Extension{}
				}
				m.Data.DisplayName = vals[0]
			case "data.category":
				if m.Data == nil {
					m.Data = &Extension{}
				}
				m.Data.Category = vals[0]
			case "data.logoUrl":
				if m.Data == nil {
					m.Data = &Extension{}
				}
				m.Data.LogoUrl = vals[0]
			case "data.public":
				if m.Data == nil {
					m.Data = &Extension{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Public = val
			case "data.createdAt":
				if m.Data == nil {
					m.Data = &Extension{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
			case "data.createdAt.seconds":
				if m.Data == nil {
					m.Data = &Extension{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Seconds = val
			case "data.createdAt.nanos":
				if m.Data == nil {
					m.Data = &Extension{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Nanos = int32(val)
			case "data.updatedAt":
				if m.Data == nil {
					m.Data = &Extension{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "data.updatedAt.seconds":
				if m.Data == nil {
					m.Data = &Extension{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.UpdatedAt.Seconds = val
			case "data.updatedAt.nanos":
				if m.Data == nil {
					m.Data = &Extension{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.UpdatedAt.Nanos = int32(val)
			}
		}
	}
	return nil
}

// QueryExtensionsRequest implement urlenc.URLValuesUnmarshaler.
func (m *QueryExtensionsRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "all":
				m.All = vals[0]
			case "type":
				m.Type = vals[0]
			case "labels":
				m.Labels = vals[0]
			case "menu":
				m.Menu = vals[0]
			}
		}
	}
	return nil
}

// QueryExtensionsResponse implement urlenc.URLValuesUnmarshaler.
func (m *QueryExtensionsResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// QueryExtensionsMenuRequest implement urlenc.URLValuesUnmarshaler.
func (m *QueryExtensionsMenuRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "all":
				m.All = vals[0]
			case "type":
				m.Type = vals[0]
			case "labels":
				m.Labels = vals[0]
			}
		}
	}
	return nil
}

// QueryExtensionsMenuResponse implement urlenc.URLValuesUnmarshaler.
func (m *QueryExtensionsMenuResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// Spec implement urlenc.URLValuesUnmarshaler.
func (m *Spec) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals[0]
			case "displayName":
				m.DisplayName = vals[0]
			case "version":
				m.Version = vals[0]
			case "type":
				m.Type = vals[0]
			case "category":
				m.Category = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "logoUrl":
				m.LogoUrl = vals[0]
			case "supportedVersions":
				m.SupportedVersions = vals
			case "public":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Public = val
			case "isDefault":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsDefault = val
			}
		}
	}
	return nil
}

// ExtensionVersionCreateRequest implement urlenc.URLValuesUnmarshaler.
func (m *ExtensionVersionCreateRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals[0]
			case "version":
				m.Version = vals[0]
			case "specYml":
				m.SpecYml = vals[0]
			case "diceYml":
				m.DiceYml = vals[0]
			case "swaggerYml":
				m.SwaggerYml = vals[0]
			case "readme":
				m.Readme = vals[0]
			case "public":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Public = val
			case "forceUpdate":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.ForceUpdate = val
			case "all":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.All = val
			case "isDefault":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsDefault = val
			}
		}
	}
	return nil
}

// ExtensionVersionCreateResponse implement urlenc.URLValuesUnmarshaler.
func (m *ExtensionVersionCreateResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
			case "data.name":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				m.Data.Name = vals[0]
			case "data.version":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				m.Data.Version = vals[0]
			case "data.type":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				m.Data.Type = vals[0]
			case "data.spec":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Spec = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Spec = val
					} else {
						m.Data.Spec = structpb.NewStringValue(vals[0])
					}
				}
			case "data.spec.null_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Spec = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Spec = val
					} else {
						m.Data.Spec = structpb.NewStringValue(vals[0])
					}
				}
			case "data.spec.number_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Spec = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Spec = val
					} else {
						m.Data.Spec = structpb.NewStringValue(vals[0])
					}
				}
			case "data.spec.string_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Spec = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Spec = val
					} else {
						m.Data.Spec = structpb.NewStringValue(vals[0])
					}
				}
			case "data.spec.bool_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Spec = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Spec = val
					} else {
						m.Data.Spec = structpb.NewStringValue(vals[0])
					}
				}
			case "data.spec.struct_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Spec = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Spec = val
					} else {
						m.Data.Spec = structpb.NewStringValue(vals[0])
					}
				}
			case "data.spec.list_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Spec = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Spec = val
					} else {
						m.Data.Spec = structpb.NewStringValue(vals[0])
					}
				}
			case "data.dice":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Dice = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Dice = val
					} else {
						m.Data.Dice = structpb.NewStringValue(vals[0])
					}
				}
			case "data.dice.null_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Dice = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Dice = val
					} else {
						m.Data.Dice = structpb.NewStringValue(vals[0])
					}
				}
			case "data.dice.number_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Dice = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Dice = val
					} else {
						m.Data.Dice = structpb.NewStringValue(vals[0])
					}
				}
			case "data.dice.string_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Dice = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Dice = val
					} else {
						m.Data.Dice = structpb.NewStringValue(vals[0])
					}
				}
			case "data.dice.bool_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Dice = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Dice = val
					} else {
						m.Data.Dice = structpb.NewStringValue(vals[0])
					}
				}
			case "data.dice.struct_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Dice = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Dice = val
					} else {
						m.Data.Dice = structpb.NewStringValue(vals[0])
					}
				}
			case "data.dice.list_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Dice = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Dice = val
					} else {
						m.Data.Dice = structpb.NewStringValue(vals[0])
					}
				}
			case "data.swagger":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Swagger = val
					} else {
						m.Data.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.swagger.null_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Swagger = val
					} else {
						m.Data.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.swagger.number_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Swagger = val
					} else {
						m.Data.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.swagger.string_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Swagger = val
					} else {
						m.Data.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.swagger.bool_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Swagger = val
					} else {
						m.Data.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.swagger.struct_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Swagger = val
					} else {
						m.Data.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.swagger.list_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Swagger = val
					} else {
						m.Data.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.readme":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				m.Data.Readme = vals[0]
			case "data.createdAt":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
			case "data.createdAt.seconds":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Seconds = val
			case "data.createdAt.nanos":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Nanos = int32(val)
			case "data.updatedAt":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "data.updatedAt.seconds":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.UpdatedAt.Seconds = val
			case "data.updatedAt.nanos":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.UpdatedAt.Nanos = int32(val)
			case "data.isDefault":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.IsDefault = val
			case "data.public":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Public = val
			}
		}
	}
	return nil
}

// GetExtensionVersionRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetExtensionVersionRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals[0]
			case "version":
				m.Version = vals[0]
			case "yamlFormat":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.YamlFormat = val
			}
		}
	}
	return nil
}

// GetExtensionVersionResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetExtensionVersionResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
			case "data.name":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				m.Data.Name = vals[0]
			case "data.version":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				m.Data.Version = vals[0]
			case "data.type":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				m.Data.Type = vals[0]
			case "data.spec":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Spec = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Spec = val
					} else {
						m.Data.Spec = structpb.NewStringValue(vals[0])
					}
				}
			case "data.spec.null_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Spec = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Spec = val
					} else {
						m.Data.Spec = structpb.NewStringValue(vals[0])
					}
				}
			case "data.spec.number_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Spec = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Spec = val
					} else {
						m.Data.Spec = structpb.NewStringValue(vals[0])
					}
				}
			case "data.spec.string_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Spec = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Spec = val
					} else {
						m.Data.Spec = structpb.NewStringValue(vals[0])
					}
				}
			case "data.spec.bool_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Spec = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Spec = val
					} else {
						m.Data.Spec = structpb.NewStringValue(vals[0])
					}
				}
			case "data.spec.struct_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Spec = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Spec = val
					} else {
						m.Data.Spec = structpb.NewStringValue(vals[0])
					}
				}
			case "data.spec.list_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Spec = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Spec = val
					} else {
						m.Data.Spec = structpb.NewStringValue(vals[0])
					}
				}
			case "data.dice":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Dice = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Dice = val
					} else {
						m.Data.Dice = structpb.NewStringValue(vals[0])
					}
				}
			case "data.dice.null_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Dice = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Dice = val
					} else {
						m.Data.Dice = structpb.NewStringValue(vals[0])
					}
				}
			case "data.dice.number_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Dice = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Dice = val
					} else {
						m.Data.Dice = structpb.NewStringValue(vals[0])
					}
				}
			case "data.dice.string_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Dice = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Dice = val
					} else {
						m.Data.Dice = structpb.NewStringValue(vals[0])
					}
				}
			case "data.dice.bool_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Dice = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Dice = val
					} else {
						m.Data.Dice = structpb.NewStringValue(vals[0])
					}
				}
			case "data.dice.struct_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Dice = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Dice = val
					} else {
						m.Data.Dice = structpb.NewStringValue(vals[0])
					}
				}
			case "data.dice.list_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Dice = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Dice = val
					} else {
						m.Data.Dice = structpb.NewStringValue(vals[0])
					}
				}
			case "data.swagger":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Swagger = val
					} else {
						m.Data.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.swagger.null_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Swagger = val
					} else {
						m.Data.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.swagger.number_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Swagger = val
					} else {
						m.Data.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.swagger.string_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Swagger = val
					} else {
						m.Data.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.swagger.bool_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Swagger = val
					} else {
						m.Data.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.swagger.struct_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Swagger = val
					} else {
						m.Data.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.swagger.list_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Swagger = val
					} else {
						m.Data.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.readme":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				m.Data.Readme = vals[0]
			case "data.createdAt":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
			case "data.createdAt.seconds":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Seconds = val
			case "data.createdAt.nanos":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Nanos = int32(val)
			case "data.updatedAt":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "data.updatedAt.seconds":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.UpdatedAt.Seconds = val
			case "data.updatedAt.nanos":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.UpdatedAt.Nanos = int32(val)
			case "data.isDefault":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.IsDefault = val
			case "data.public":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Public = val
			}
		}
	}
	return nil
}

// ExtensionQueryRequest implement urlenc.URLValuesUnmarshaler.
func (m *ExtensionQueryRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "all":
				m.All = vals[0]
			case "type":
				m.Type = vals[0]
			case "labels":
				m.Labels = vals[0]
			}
		}
	}
	return nil
}

// ExtensionQueryResponse implement urlenc.URLValuesUnmarshaler.
func (m *ExtensionQueryResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// ExtensionVersionGetRequest implement urlenc.URLValuesUnmarshaler.
func (m *ExtensionVersionGetRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals[0]
			case "version":
				m.Version = vals[0]
			case "yamlFormat":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.YamlFormat = val
			}
		}
	}
	return nil
}

// ExtensionVersionQueryRequest implement urlenc.URLValuesUnmarshaler.
func (m *ExtensionVersionQueryRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals[0]
			case "yamlFormat":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.YamlFormat = val
			case "all":
				m.All = vals[0]
			}
		}
	}
	return nil
}

// ExtensionVersionGetResponse implement urlenc.URLValuesUnmarshaler.
func (m *ExtensionVersionGetResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
			case "data.name":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				m.Data.Name = vals[0]
			case "data.version":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				m.Data.Version = vals[0]
			case "data.type":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				m.Data.Type = vals[0]
			case "data.spec":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Spec = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Spec = val
					} else {
						m.Data.Spec = structpb.NewStringValue(vals[0])
					}
				}
			case "data.spec.null_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Spec = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Spec = val
					} else {
						m.Data.Spec = structpb.NewStringValue(vals[0])
					}
				}
			case "data.spec.number_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Spec = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Spec = val
					} else {
						m.Data.Spec = structpb.NewStringValue(vals[0])
					}
				}
			case "data.spec.string_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Spec = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Spec = val
					} else {
						m.Data.Spec = structpb.NewStringValue(vals[0])
					}
				}
			case "data.spec.bool_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Spec = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Spec = val
					} else {
						m.Data.Spec = structpb.NewStringValue(vals[0])
					}
				}
			case "data.spec.struct_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Spec = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Spec = val
					} else {
						m.Data.Spec = structpb.NewStringValue(vals[0])
					}
				}
			case "data.spec.list_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Spec = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Spec = val
					} else {
						m.Data.Spec = structpb.NewStringValue(vals[0])
					}
				}
			case "data.dice":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Dice = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Dice = val
					} else {
						m.Data.Dice = structpb.NewStringValue(vals[0])
					}
				}
			case "data.dice.null_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Dice = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Dice = val
					} else {
						m.Data.Dice = structpb.NewStringValue(vals[0])
					}
				}
			case "data.dice.number_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Dice = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Dice = val
					} else {
						m.Data.Dice = structpb.NewStringValue(vals[0])
					}
				}
			case "data.dice.string_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Dice = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Dice = val
					} else {
						m.Data.Dice = structpb.NewStringValue(vals[0])
					}
				}
			case "data.dice.bool_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Dice = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Dice = val
					} else {
						m.Data.Dice = structpb.NewStringValue(vals[0])
					}
				}
			case "data.dice.struct_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Dice = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Dice = val
					} else {
						m.Data.Dice = structpb.NewStringValue(vals[0])
					}
				}
			case "data.dice.list_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Dice = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Dice = val
					} else {
						m.Data.Dice = structpb.NewStringValue(vals[0])
					}
				}
			case "data.swagger":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Swagger = val
					} else {
						m.Data.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.swagger.null_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Swagger = val
					} else {
						m.Data.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.swagger.number_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Swagger = val
					} else {
						m.Data.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.swagger.string_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Swagger = val
					} else {
						m.Data.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.swagger.bool_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Swagger = val
					} else {
						m.Data.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.swagger.struct_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Swagger = val
					} else {
						m.Data.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.swagger.list_value":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Swagger = val
					} else {
						m.Data.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "data.readme":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				m.Data.Readme = vals[0]
			case "data.createdAt":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
			case "data.createdAt.seconds":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Seconds = val
			case "data.createdAt.nanos":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if m.Data.CreatedAt == nil {
					m.Data.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.CreatedAt.Nanos = int32(val)
			case "data.updatedAt":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "data.updatedAt.seconds":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.UpdatedAt.Seconds = val
			case "data.updatedAt.nanos":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				if m.Data.UpdatedAt == nil {
					m.Data.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.UpdatedAt.Nanos = int32(val)
			case "data.isDefault":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.IsDefault = val
			case "data.public":
				if m.Data == nil {
					m.Data = &ExtensionVersion{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Public = val
			}
		}
	}
	return nil
}

// ExtensionVersionQueryResponse implement urlenc.URLValuesUnmarshaler.
func (m *ExtensionVersionQueryResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// ExtensionMenu implement urlenc.URLValuesUnmarshaler.
func (m *ExtensionMenu) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals[0]
			case "displayName":
				m.DisplayName = vals[0]
			}
		}
	}
	return nil
}

// Extension implement urlenc.URLValuesUnmarshaler.
func (m *Extension) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "type":
				m.Type = vals[0]
			case "name":
				m.Name = vals[0]
			case "desc":
				m.Desc = vals[0]
			case "displayName":
				m.DisplayName = vals[0]
			case "category":
				m.Category = vals[0]
			case "logoUrl":
				m.LogoUrl = vals[0]
			case "public":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Public = val
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			}
		}
	}
	return nil
}

// ExtensionVersion implement urlenc.URLValuesUnmarshaler.
func (m *ExtensionVersion) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals[0]
			case "version":
				m.Version = vals[0]
			case "type":
				m.Type = vals[0]
			case "spec":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Spec = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Spec = val
					} else {
						m.Spec = structpb.NewStringValue(vals[0])
					}
				}
			case "dice":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Dice = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Dice = val
					} else {
						m.Dice = structpb.NewStringValue(vals[0])
					}
				}
			case "swagger":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Swagger = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Swagger = val
					} else {
						m.Swagger = structpb.NewStringValue(vals[0])
					}
				}
			case "readme":
				m.Readme = vals[0]
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "updatedAt":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
			case "updatedAt.seconds":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdatedAt.Seconds = val
			case "updatedAt.nanos":
				if m.UpdatedAt == nil {
					m.UpdatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.UpdatedAt.Nanos = int32(val)
			case "isDefault":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsDefault = val
			case "public":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Public = val
			}
		}
	}
	return nil
}
