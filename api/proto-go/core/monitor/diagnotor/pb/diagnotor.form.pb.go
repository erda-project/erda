// Code generated by protoc-gen-go-form. DO NOT EDIT.
// Source: diagnotor.proto

package pb

import (
	url "net/url"
	strconv "strconv"

	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/urlenc" package it is being compiled against.
var _ urlenc.URLValuesUnmarshaler = (*StartDiagnosisRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*StartDiagnosisResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryDiagnosisStatusRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryDiagnosisStatusResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DiagnosisInstance)(nil)
var _ urlenc.URLValuesUnmarshaler = (*StopDiagnosisRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*StopDiagnosisResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListProcessesRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListProcessesResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*HostProcessStatus)(nil)
var _ urlenc.URLValuesUnmarshaler = (*Process)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProcessRLimit)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProcessRLimitStatus)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProcessMemoryStatus)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProcessCPUStatus)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProcessIOStatus)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ProcessContextSwitches)(nil)

// StartDiagnosisRequest implement urlenc.URLValuesUnmarshaler.
func (m *StartDiagnosisRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "clusterName":
				m.ClusterName = vals[0]
			case "namespace":
				m.Namespace = vals[0]
			case "podName":
				m.PodName = vals[0]
			}
		}
	}
	return nil
}

// StartDiagnosisResponse implement urlenc.URLValuesUnmarshaler.
func (m *StartDiagnosisResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &DiagnosisInstance{}
				}
			case "data.clusterName":
				if m.Data == nil {
					m.Data = &DiagnosisInstance{}
				}
				m.Data.ClusterName = vals[0]
			case "data.namespace":
				if m.Data == nil {
					m.Data = &DiagnosisInstance{}
				}
				m.Data.Namespace = vals[0]
			case "data.podName":
				if m.Data == nil {
					m.Data = &DiagnosisInstance{}
				}
				m.Data.PodName = vals[0]
			case "data.hostIP":
				if m.Data == nil {
					m.Data = &DiagnosisInstance{}
				}
				m.Data.HostIP = vals[0]
			case "data.podIP":
				if m.Data == nil {
					m.Data = &DiagnosisInstance{}
				}
				m.Data.PodIP = vals[0]
			case "data.status":
				if m.Data == nil {
					m.Data = &DiagnosisInstance{}
				}
				m.Data.Status = vals[0]
			case "data.message":
				if m.Data == nil {
					m.Data = &DiagnosisInstance{}
				}
				m.Data.Message = vals[0]
			}
		}
	}
	return nil
}

// QueryDiagnosisStatusRequest implement urlenc.URLValuesUnmarshaler.
func (m *QueryDiagnosisStatusRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "clusterName":
				m.ClusterName = vals[0]
			case "namespace":
				m.Namespace = vals[0]
			case "podName":
				m.PodName = vals[0]
			}
		}
	}
	return nil
}

// QueryDiagnosisStatusResponse implement urlenc.URLValuesUnmarshaler.
func (m *QueryDiagnosisStatusResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &DiagnosisInstance{}
				}
			case "data.clusterName":
				if m.Data == nil {
					m.Data = &DiagnosisInstance{}
				}
				m.Data.ClusterName = vals[0]
			case "data.namespace":
				if m.Data == nil {
					m.Data = &DiagnosisInstance{}
				}
				m.Data.Namespace = vals[0]
			case "data.podName":
				if m.Data == nil {
					m.Data = &DiagnosisInstance{}
				}
				m.Data.PodName = vals[0]
			case "data.hostIP":
				if m.Data == nil {
					m.Data = &DiagnosisInstance{}
				}
				m.Data.HostIP = vals[0]
			case "data.podIP":
				if m.Data == nil {
					m.Data = &DiagnosisInstance{}
				}
				m.Data.PodIP = vals[0]
			case "data.status":
				if m.Data == nil {
					m.Data = &DiagnosisInstance{}
				}
				m.Data.Status = vals[0]
			case "data.message":
				if m.Data == nil {
					m.Data = &DiagnosisInstance{}
				}
				m.Data.Message = vals[0]
			}
		}
	}
	return nil
}

// DiagnosisInstance implement urlenc.URLValuesUnmarshaler.
func (m *DiagnosisInstance) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "clusterName":
				m.ClusterName = vals[0]
			case "namespace":
				m.Namespace = vals[0]
			case "podName":
				m.PodName = vals[0]
			case "hostIP":
				m.HostIP = vals[0]
			case "podIP":
				m.PodIP = vals[0]
			case "status":
				m.Status = vals[0]
			case "message":
				m.Message = vals[0]
			}
		}
	}
	return nil
}

// StopDiagnosisRequest implement urlenc.URLValuesUnmarshaler.
func (m *StopDiagnosisRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "clusterName":
				m.ClusterName = vals[0]
			case "namespace":
				m.Namespace = vals[0]
			case "podName":
				m.PodName = vals[0]
			}
		}
	}
	return nil
}

// StopDiagnosisResponse implement urlenc.URLValuesUnmarshaler.
func (m *StopDiagnosisResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				m.Data = vals[0]
			}
		}
	}
	return nil
}

// ListProcessesRequest implement urlenc.URLValuesUnmarshaler.
func (m *ListProcessesRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "clusterName":
				m.ClusterName = vals[0]
			case "namespace":
				m.Namespace = vals[0]
			case "podName":
				m.PodName = vals[0]
			case "podIP":
				m.PodIP = vals[0]
			}
		}
	}
	return nil
}

// ListProcessesResponse implement urlenc.URLValuesUnmarshaler.
func (m *ListProcessesResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &HostProcessStatus{}
				}
			case "data.totalMemory":
				if m.Data == nil {
					m.Data = &HostProcessStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.TotalMemory = val
			case "data.memoryUsed":
				if m.Data == nil {
					m.Data = &HostProcessStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.MemoryUsed = val
			case "data.memoryUsedPercent":
				if m.Data == nil {
					m.Data = &HostProcessStatus{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Data.MemoryUsedPercent = val
			case "data.totalCpuCores":
				if m.Data == nil {
					m.Data = &HostProcessStatus{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Data.TotalCpuCores = val
			case "data.cpuUsedCores":
				if m.Data == nil {
					m.Data = &HostProcessStatus{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Data.CpuUsedCores = val
			case "data.cpuUsedPercent":
				if m.Data == nil {
					m.Data = &HostProcessStatus{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Data.CpuUsedPercent = val
			case "data.connections":
				if m.Data == nil {
					m.Data = &HostProcessStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Connections = val
			}
		}
	}
	return nil
}

// HostProcessStatus implement urlenc.URLValuesUnmarshaler.
func (m *HostProcessStatus) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "totalMemory":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.TotalMemory = val
			case "memoryUsed":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MemoryUsed = val
			case "memoryUsedPercent":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.MemoryUsedPercent = val
			case "totalCpuCores":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.TotalCpuCores = val
			case "cpuUsedCores":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.CpuUsedCores = val
			case "cpuUsedPercent":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.CpuUsedPercent = val
			case "connections":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Connections = val
			}
		}
	}
	return nil
}

// Process implement urlenc.URLValuesUnmarshaler.
func (m *Process) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pid":
				m.Pid = vals[0]
			case "name":
				m.Name = vals[0]
			case "cmdline":
				m.Cmdline = vals[0]
			case "user":
				m.User = vals[0]
			case "createTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreateTime = val
			case "numThreads":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.NumThreads = val
			case "numFDs":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.NumFDs = val
			case "connections":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Connections = val
			case "cpu":
				if m.Cpu == nil {
					m.Cpu = &ProcessCPUStatus{}
				}
			case "cpu.user":
				if m.Cpu == nil {
					m.Cpu = &ProcessCPUStatus{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Cpu.User = val
			case "cpu.system":
				if m.Cpu == nil {
					m.Cpu = &ProcessCPUStatus{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Cpu.System = val
			case "cpu.ioWait":
				if m.Cpu == nil {
					m.Cpu = &ProcessCPUStatus{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Cpu.IoWait = val
			case "cpu.usedCores":
				if m.Cpu == nil {
					m.Cpu = &ProcessCPUStatus{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Cpu.UsedCores = val
			case "cpu.usedPercent":
				if m.Cpu == nil {
					m.Cpu = &ProcessCPUStatus{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Cpu.UsedPercent = val
			case "cpu.usedPercentInHost":
				if m.Cpu == nil {
					m.Cpu = &ProcessCPUStatus{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Cpu.UsedPercentInHost = val
			case "memory":
				if m.Memory == nil {
					m.Memory = &ProcessMemoryStatus{}
				}
			case "memory.rss":
				if m.Memory == nil {
					m.Memory = &ProcessMemoryStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Memory.Rss = val
			case "memory.vms":
				if m.Memory == nil {
					m.Memory = &ProcessMemoryStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Memory.Vms = val
			case "memory.swap":
				if m.Memory == nil {
					m.Memory = &ProcessMemoryStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Memory.Swap = val
			case "memory.data":
				if m.Memory == nil {
					m.Memory = &ProcessMemoryStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Memory.Data = val
			case "memory.stack":
				if m.Memory == nil {
					m.Memory = &ProcessMemoryStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Memory.Stack = val
			case "memory.locked":
				if m.Memory == nil {
					m.Memory = &ProcessMemoryStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Memory.Locked = val
			case "memory.usedPercent":
				if m.Memory == nil {
					m.Memory = &ProcessMemoryStatus{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Memory.UsedPercent = val
			case "io":
				if m.Io == nil {
					m.Io = &ProcessIOStatus{}
				}
			case "io.readCount":
				if m.Io == nil {
					m.Io = &ProcessIOStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Io.ReadCount = val
			case "io.readBytes":
				if m.Io == nil {
					m.Io = &ProcessIOStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Io.ReadBytes = val
			case "io.readRate":
				if m.Io == nil {
					m.Io = &ProcessIOStatus{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Io.ReadRate = val
			case "io.writeCount":
				if m.Io == nil {
					m.Io = &ProcessIOStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Io.WriteCount = val
			case "io.writeBytes":
				if m.Io == nil {
					m.Io = &ProcessIOStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Io.WriteBytes = val
			case "io.writeRate":
				if m.Io == nil {
					m.Io = &ProcessIOStatus{}
				}
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.Io.WriteRate = val
			case "contextSwitches":
				if m.ContextSwitches == nil {
					m.ContextSwitches = &ProcessContextSwitches{}
				}
			case "contextSwitches.voluntary":
				if m.ContextSwitches == nil {
					m.ContextSwitches = &ProcessContextSwitches{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ContextSwitches.Voluntary = val
			case "contextSwitches.involuntary":
				if m.ContextSwitches == nil {
					m.ContextSwitches = &ProcessContextSwitches{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ContextSwitches.Involuntary = val
			case "rlimit":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
			case "rlimit.cpuTime":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.CpuTime == nil {
					m.Rlimit.CpuTime = &ProcessRLimitStatus{}
				}
			case "rlimit.cpuTime.soft":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.CpuTime == nil {
					m.Rlimit.CpuTime = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Rlimit.CpuTime.Soft = val
			case "rlimit.cpuTime.Hard":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.CpuTime == nil {
					m.Rlimit.CpuTime = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Rlimit.CpuTime.Hard = val
			case "rlimit.cpuTime.used":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.CpuTime == nil {
					m.Rlimit.CpuTime = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Rlimit.CpuTime.Used = val
			case "rlimit.memoryData":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.MemoryData == nil {
					m.Rlimit.MemoryData = &ProcessRLimitStatus{}
				}
			case "rlimit.memoryData.soft":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.MemoryData == nil {
					m.Rlimit.MemoryData = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Rlimit.MemoryData.Soft = val
			case "rlimit.memoryData.Hard":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.MemoryData == nil {
					m.Rlimit.MemoryData = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Rlimit.MemoryData.Hard = val
			case "rlimit.memoryData.used":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.MemoryData == nil {
					m.Rlimit.MemoryData = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Rlimit.MemoryData.Used = val
			case "rlimit.memoryStack":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.MemoryStack == nil {
					m.Rlimit.MemoryStack = &ProcessRLimitStatus{}
				}
			case "rlimit.memoryStack.soft":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.MemoryStack == nil {
					m.Rlimit.MemoryStack = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Rlimit.MemoryStack.Soft = val
			case "rlimit.memoryStack.Hard":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.MemoryStack == nil {
					m.Rlimit.MemoryStack = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Rlimit.MemoryStack.Hard = val
			case "rlimit.memoryStack.used":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.MemoryStack == nil {
					m.Rlimit.MemoryStack = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Rlimit.MemoryStack.Used = val
			case "rlimit.memoryRss":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.MemoryRss == nil {
					m.Rlimit.MemoryRss = &ProcessRLimitStatus{}
				}
			case "rlimit.memoryRss.soft":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.MemoryRss == nil {
					m.Rlimit.MemoryRss = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Rlimit.MemoryRss.Soft = val
			case "rlimit.memoryRss.Hard":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.MemoryRss == nil {
					m.Rlimit.MemoryRss = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Rlimit.MemoryRss.Hard = val
			case "rlimit.memoryRss.used":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.MemoryRss == nil {
					m.Rlimit.MemoryRss = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Rlimit.MemoryRss.Used = val
			case "rlimit.memoryLocked":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.MemoryLocked == nil {
					m.Rlimit.MemoryLocked = &ProcessRLimitStatus{}
				}
			case "rlimit.memoryLocked.soft":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.MemoryLocked == nil {
					m.Rlimit.MemoryLocked = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Rlimit.MemoryLocked.Soft = val
			case "rlimit.memoryLocked.Hard":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.MemoryLocked == nil {
					m.Rlimit.MemoryLocked = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Rlimit.MemoryLocked.Hard = val
			case "rlimit.memoryLocked.used":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.MemoryLocked == nil {
					m.Rlimit.MemoryLocked = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Rlimit.MemoryLocked.Used = val
			case "rlimit.memoryVms":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.MemoryVms == nil {
					m.Rlimit.MemoryVms = &ProcessRLimitStatus{}
				}
			case "rlimit.memoryVms.soft":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.MemoryVms == nil {
					m.Rlimit.MemoryVms = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Rlimit.MemoryVms.Soft = val
			case "rlimit.memoryVms.Hard":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.MemoryVms == nil {
					m.Rlimit.MemoryVms = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Rlimit.MemoryVms.Hard = val
			case "rlimit.memoryVms.used":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.MemoryVms == nil {
					m.Rlimit.MemoryVms = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Rlimit.MemoryVms.Used = val
			case "rlimit.numFDs":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.NumFDs == nil {
					m.Rlimit.NumFDs = &ProcessRLimitStatus{}
				}
			case "rlimit.numFDs.soft":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.NumFDs == nil {
					m.Rlimit.NumFDs = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Rlimit.NumFDs.Soft = val
			case "rlimit.numFDs.Hard":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.NumFDs == nil {
					m.Rlimit.NumFDs = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Rlimit.NumFDs.Hard = val
			case "rlimit.numFDs.used":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.NumFDs == nil {
					m.Rlimit.NumFDs = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Rlimit.NumFDs.Used = val
			case "rlimit.fileLocks":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.FileLocks == nil {
					m.Rlimit.FileLocks = &ProcessRLimitStatus{}
				}
			case "rlimit.fileLocks.soft":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.FileLocks == nil {
					m.Rlimit.FileLocks = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Rlimit.FileLocks.Soft = val
			case "rlimit.fileLocks.Hard":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.FileLocks == nil {
					m.Rlimit.FileLocks = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Rlimit.FileLocks.Hard = val
			case "rlimit.fileLocks.used":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.FileLocks == nil {
					m.Rlimit.FileLocks = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Rlimit.FileLocks.Used = val
			case "rlimit.signalsPending":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.SignalsPending == nil {
					m.Rlimit.SignalsPending = &ProcessRLimitStatus{}
				}
			case "rlimit.signalsPending.soft":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.SignalsPending == nil {
					m.Rlimit.SignalsPending = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Rlimit.SignalsPending.Soft = val
			case "rlimit.signalsPending.Hard":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.SignalsPending == nil {
					m.Rlimit.SignalsPending = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Rlimit.SignalsPending.Hard = val
			case "rlimit.signalsPending.used":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.SignalsPending == nil {
					m.Rlimit.SignalsPending = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Rlimit.SignalsPending.Used = val
			case "rlimit.nicePriority":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.NicePriority == nil {
					m.Rlimit.NicePriority = &ProcessRLimitStatus{}
				}
			case "rlimit.nicePriority.soft":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.NicePriority == nil {
					m.Rlimit.NicePriority = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Rlimit.NicePriority.Soft = val
			case "rlimit.nicePriority.Hard":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.NicePriority == nil {
					m.Rlimit.NicePriority = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Rlimit.NicePriority.Hard = val
			case "rlimit.nicePriority.used":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.NicePriority == nil {
					m.Rlimit.NicePriority = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Rlimit.NicePriority.Used = val
			case "rlimit.realtimePriority":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.RealtimePriority == nil {
					m.Rlimit.RealtimePriority = &ProcessRLimitStatus{}
				}
			case "rlimit.realtimePriority.soft":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.RealtimePriority == nil {
					m.Rlimit.RealtimePriority = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Rlimit.RealtimePriority.Soft = val
			case "rlimit.realtimePriority.Hard":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.RealtimePriority == nil {
					m.Rlimit.RealtimePriority = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Rlimit.RealtimePriority.Hard = val
			case "rlimit.realtimePriority.used":
				if m.Rlimit == nil {
					m.Rlimit = &ProcessRLimit{}
				}
				if m.Rlimit.RealtimePriority == nil {
					m.Rlimit.RealtimePriority = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Rlimit.RealtimePriority.Used = val
			case "appType":
				m.AppType = vals[0]
			}
		}
	}
	return nil
}

// ProcessRLimit implement urlenc.URLValuesUnmarshaler.
func (m *ProcessRLimit) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "cpuTime":
				if m.CpuTime == nil {
					m.CpuTime = &ProcessRLimitStatus{}
				}
			case "cpuTime.soft":
				if m.CpuTime == nil {
					m.CpuTime = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CpuTime.Soft = val
			case "cpuTime.Hard":
				if m.CpuTime == nil {
					m.CpuTime = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CpuTime.Hard = val
			case "cpuTime.used":
				if m.CpuTime == nil {
					m.CpuTime = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CpuTime.Used = val
			case "memoryData":
				if m.MemoryData == nil {
					m.MemoryData = &ProcessRLimitStatus{}
				}
			case "memoryData.soft":
				if m.MemoryData == nil {
					m.MemoryData = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MemoryData.Soft = val
			case "memoryData.Hard":
				if m.MemoryData == nil {
					m.MemoryData = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MemoryData.Hard = val
			case "memoryData.used":
				if m.MemoryData == nil {
					m.MemoryData = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MemoryData.Used = val
			case "memoryStack":
				if m.MemoryStack == nil {
					m.MemoryStack = &ProcessRLimitStatus{}
				}
			case "memoryStack.soft":
				if m.MemoryStack == nil {
					m.MemoryStack = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MemoryStack.Soft = val
			case "memoryStack.Hard":
				if m.MemoryStack == nil {
					m.MemoryStack = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MemoryStack.Hard = val
			case "memoryStack.used":
				if m.MemoryStack == nil {
					m.MemoryStack = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MemoryStack.Used = val
			case "memoryRss":
				if m.MemoryRss == nil {
					m.MemoryRss = &ProcessRLimitStatus{}
				}
			case "memoryRss.soft":
				if m.MemoryRss == nil {
					m.MemoryRss = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MemoryRss.Soft = val
			case "memoryRss.Hard":
				if m.MemoryRss == nil {
					m.MemoryRss = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MemoryRss.Hard = val
			case "memoryRss.used":
				if m.MemoryRss == nil {
					m.MemoryRss = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MemoryRss.Used = val
			case "memoryLocked":
				if m.MemoryLocked == nil {
					m.MemoryLocked = &ProcessRLimitStatus{}
				}
			case "memoryLocked.soft":
				if m.MemoryLocked == nil {
					m.MemoryLocked = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MemoryLocked.Soft = val
			case "memoryLocked.Hard":
				if m.MemoryLocked == nil {
					m.MemoryLocked = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MemoryLocked.Hard = val
			case "memoryLocked.used":
				if m.MemoryLocked == nil {
					m.MemoryLocked = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MemoryLocked.Used = val
			case "memoryVms":
				if m.MemoryVms == nil {
					m.MemoryVms = &ProcessRLimitStatus{}
				}
			case "memoryVms.soft":
				if m.MemoryVms == nil {
					m.MemoryVms = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MemoryVms.Soft = val
			case "memoryVms.Hard":
				if m.MemoryVms == nil {
					m.MemoryVms = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MemoryVms.Hard = val
			case "memoryVms.used":
				if m.MemoryVms == nil {
					m.MemoryVms = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.MemoryVms.Used = val
			case "numFDs":
				if m.NumFDs == nil {
					m.NumFDs = &ProcessRLimitStatus{}
				}
			case "numFDs.soft":
				if m.NumFDs == nil {
					m.NumFDs = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.NumFDs.Soft = val
			case "numFDs.Hard":
				if m.NumFDs == nil {
					m.NumFDs = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.NumFDs.Hard = val
			case "numFDs.used":
				if m.NumFDs == nil {
					m.NumFDs = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.NumFDs.Used = val
			case "fileLocks":
				if m.FileLocks == nil {
					m.FileLocks = &ProcessRLimitStatus{}
				}
			case "fileLocks.soft":
				if m.FileLocks == nil {
					m.FileLocks = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.FileLocks.Soft = val
			case "fileLocks.Hard":
				if m.FileLocks == nil {
					m.FileLocks = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.FileLocks.Hard = val
			case "fileLocks.used":
				if m.FileLocks == nil {
					m.FileLocks = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.FileLocks.Used = val
			case "signalsPending":
				if m.SignalsPending == nil {
					m.SignalsPending = &ProcessRLimitStatus{}
				}
			case "signalsPending.soft":
				if m.SignalsPending == nil {
					m.SignalsPending = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.SignalsPending.Soft = val
			case "signalsPending.Hard":
				if m.SignalsPending == nil {
					m.SignalsPending = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.SignalsPending.Hard = val
			case "signalsPending.used":
				if m.SignalsPending == nil {
					m.SignalsPending = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.SignalsPending.Used = val
			case "nicePriority":
				if m.NicePriority == nil {
					m.NicePriority = &ProcessRLimitStatus{}
				}
			case "nicePriority.soft":
				if m.NicePriority == nil {
					m.NicePriority = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.NicePriority.Soft = val
			case "nicePriority.Hard":
				if m.NicePriority == nil {
					m.NicePriority = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.NicePriority.Hard = val
			case "nicePriority.used":
				if m.NicePriority == nil {
					m.NicePriority = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.NicePriority.Used = val
			case "realtimePriority":
				if m.RealtimePriority == nil {
					m.RealtimePriority = &ProcessRLimitStatus{}
				}
			case "realtimePriority.soft":
				if m.RealtimePriority == nil {
					m.RealtimePriority = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.RealtimePriority.Soft = val
			case "realtimePriority.Hard":
				if m.RealtimePriority == nil {
					m.RealtimePriority = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.RealtimePriority.Hard = val
			case "realtimePriority.used":
				if m.RealtimePriority == nil {
					m.RealtimePriority = &ProcessRLimitStatus{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.RealtimePriority.Used = val
			}
		}
	}
	return nil
}

// ProcessRLimitStatus implement urlenc.URLValuesUnmarshaler.
func (m *ProcessRLimitStatus) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "soft":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Soft = val
			case "Hard":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Hard = val
			case "used":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Used = val
			}
		}
	}
	return nil
}

// ProcessMemoryStatus implement urlenc.URLValuesUnmarshaler.
func (m *ProcessMemoryStatus) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "rss":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Rss = val
			case "vms":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Vms = val
			case "swap":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Swap = val
			case "data":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			case "stack":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Stack = val
			case "locked":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Locked = val
			case "usedPercent":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.UsedPercent = val
			}
		}
	}
	return nil
}

// ProcessCPUStatus implement urlenc.URLValuesUnmarshaler.
func (m *ProcessCPUStatus) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "user":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.User = val
			case "system":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.System = val
			case "ioWait":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.IoWait = val
			case "usedCores":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.UsedCores = val
			case "usedPercent":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.UsedPercent = val
			case "usedPercentInHost":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.UsedPercentInHost = val
			}
		}
	}
	return nil
}

// ProcessIOStatus implement urlenc.URLValuesUnmarshaler.
func (m *ProcessIOStatus) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "readCount":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ReadCount = val
			case "readBytes":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ReadBytes = val
			case "readRate":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.ReadRate = val
			case "writeCount":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.WriteCount = val
			case "writeBytes":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.WriteBytes = val
			case "writeRate":
				val, err := strconv.ParseFloat(vals[0], 64)
				if err != nil {
					return err
				}
				m.WriteRate = val
			}
		}
	}
	return nil
}

// ProcessContextSwitches implement urlenc.URLValuesUnmarshaler.
func (m *ProcessContextSwitches) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "voluntary":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Voluntary = val
			case "involuntary":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Involuntary = val
			}
		}
	}
	return nil
}
