// Code generated by protoc-gen-go-http. DO NOT EDIT.
// Source: alert.proto

package pb

import (
	context "context"
	http1 "net/http"
	strconv "strconv"
	strings "strings"

	transport "github.com/erda-project/erda-infra/pkg/transport"
	http "github.com/erda-project/erda-infra/pkg/transport/http"
	httprule "github.com/erda-project/erda-infra/pkg/transport/http/httprule"
	runtime "github.com/erda-project/erda-infra/pkg/transport/http/runtime"
	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/transport/http" package it is being compiled against.
const _ = http.SupportPackageIsVersion1

// AlertServiceHandler is the server API for AlertService service.
type AlertServiceHandler interface {
	// GET /api/customize/alerts/metrics
	QueryCustomizeMetric(context.Context, *QueryCustomizeMetricRequest) (*QueryCustomizeMetricResponse, error)
	// GET /api/customize/alerts/notifies/targets
	QueryCustomizeNotifyTarget(context.Context, *QueryCustomizeNotifyTargetRequest) (*QueryCustomizeNotifyTargetResponse, error)
	// GET /api/orgs/customize/alerts/notifies/targets
	QueryOrgCustomizeNotifyTarget(context.Context, *QueryOrgCustomizeNotifyTargetRequest) (*QueryOrgCustomizeNotifyTargetResponse, error)
	// GET /api/customize/alerts
	QueryCustomizeAlert(context.Context, *QueryCustomizeAlertRequest) (*QueryCustomizeAlertResponse, error)
	// GET /api/customize/alerts/{id}
	GetCustomizeAlert(context.Context, *GetCustomizeAlertRequest) (*GetCustomizeAlertResponse, error)
	// GET /api/customize/alerts/{id}/detail
	GetCustomizeAlertDetail(context.Context, *GetCustomizeAlertDetailRequest) (*GetCustomizeAlertDetailResponse, error)
	// POST /api/customize/alerts
	CreateCustomizeAlert(context.Context, *CreateCustomizeAlertRequest) (*CreateCustomizeAlertResponse, error)
	// PUT /api/customize/alerts/{id}
	UpdateCustomizeAlert(context.Context, *UpdateCustomizeAlertRequest) (*UpdateCustomizeAlertResponse, error)
	// PUT /api/customize/alerts/{id}/switch
	UpdateCustomizeAlertEnable(context.Context, *UpdateCustomizeAlertEnableRequest) (*UpdateCustomizeAlertEnableResponse, error)
	// DELETE /api/customize/alerts/{id}
	DeleteCustomizeAlert(context.Context, *DeleteCustomizeAlertRequest) (*DeleteCustomizeAlertResponse, error)
	// GET /api/orgs/customize/alerts/metrics
	QueryOrgCustomizeMetric(context.Context, *QueryOrgCustomizeMetricRequest) (*QueryOrgCustomizeMetricResponse, error)
	// GET /api/orgs/customize/alerts
	QueryOrgCustomizeAlerts(context.Context, *QueryOrgCustomizeAlertsRequest) (*QueryOrgCustomizeAlertsResponse, error)
	// GET /api/orgs/customize/alerts/{id}
	GetOrgCustomizeAlertDetail(context.Context, *GetOrgCustomizeAlertDetailRequest) (*GetOrgCustomizeAlertDetailResponse, error)
	// POST /api/orgs/customize/alerts
	CreateOrgCustomizeAlert(context.Context, *CreateOrgCustomizeAlertRequest) (*CreateOrgCustomizeAlertResponse, error)
	// PUT /api/orgs/customize/alerts/{id}
	UpdateOrgCustomizeAlert(context.Context, *UpdateOrgCustomizeAlertRequest) (*UpdateOrgCustomizeAlertResponse, error)
	// PUT /api/orgs/customize/alerts/{id}/switch
	UpdateOrgCustomizeAlertEnable(context.Context, *UpdateOrgCustomizeAlertEnableRequest) (*UpdateOrgCustomizeAlertEnableResponse, error)
	// DELETE /api/orgs/customize/alerts/{id}
	DeleteOrgCustomizeAlert(context.Context, *DeleteOrgCustomizeAlertRequest) (*DeleteOrgCustomizeAlertResponse, error)
	// POST /api/customize/alerts/dash-preview/query
	QueryDashboardByAlert(context.Context, *QueryDashboardByAlertRequest) (*QueryDashboardByAlertResponse, error)
	// POST /api/orgs/customize/alerts/dash-preview/query
	QueryOrgDashboardByAlert(context.Context, *QueryOrgDashboardByAlertRequest) (*QueryOrgDashboardByAlertResponse, error)
	// GET /api/alerts/rules
	QueryAlertRule(context.Context, *QueryAlertRuleRequest) (*QueryAlertRuleResponse, error)
	// GET /api/alerts
	QueryAlert(context.Context, *QueryAlertRequest) (*QueryAlertsResponse, error)
	// GET /api/alerts/{id}
	GetAlert(context.Context, *GetAlertRequest) (*GetAlertResponse, error)
	// GET /api/alerts/{id}/detail
	GetAlertDetail(context.Context, *GetAlertDetailRequest) (*GetAlertDetailResponse, error)
	// POST /api/alerts
	CreateAlert(context.Context, *CreateAlertRequest) (*CreateAlertResponse, error)
	// PUT /api/alerts/{id}
	UpdateAlert(context.Context, *UpdateAlertRequest) (*UpdateAlertResponse, error)
	// PUT /api/alerts/{id}/switch
	UpdateAlertEnable(context.Context, *UpdateAlertEnableRequest) (*UpdateAlertEnableResponse, error)
	// DELETE /api/alerts/{id}
	DeleteAlert(context.Context, *DeleteAlertRequest) (*DeleteAlertResponse, error)
	// GET /api/alerts/expressions/{id}
	GetRawAlertExpression(context.Context, *GetRawAlertExpressionRequest) (*GetRawAlertExpressionResponse, error)
	// GET /api/orgs/alerts/rules
	QueryOrgAlertRule(context.Context, *QueryOrgAlertRuleRequest) (*QueryOrgAlertRuleResponse, error)
	// GET /api/orgs/alerts
	QueryOrgAlert(context.Context, *QueryOrgAlertRequest) (*QueryOrgAlertResponse, error)
	// GET /api/orgs/alerts/{id}
	GetOrgAlertDetail(context.Context, *GetOrgAlertDetailRequest) (*GetOrgAlertDetailResponse, error)
	// POST /api/orgs/alerts
	CreateOrgAlert(context.Context, *CreateOrgAlertRequest) (*CreateOrgAlertResponse, error)
	// PUT /api/orgs/alerts/{id}
	UpdateOrgAlert(context.Context, *UpdateOrgAlertRequest) (*UpdateOrgAlertResponse, error)
	// PUT /api/orgs/alerts/{id}/switch
	UpdateOrgAlertEnable(context.Context, *UpdateOrgAlertEnableRequest) (*UpdateOrgAlertEnableResponse, error)
	// DELETE /api/orgs/alerts/{id}
	DeleteOrgAlert(context.Context, *DeleteOrgAlertRequest) (*DeleteOrgAlertResponse, error)
	// GET /api/alert-record-attrs
	GetAlertRecordAttr(context.Context, *GetAlertRecordAttrRequest) (*GetAlertRecordAttrResponse, error)
	// GET /api/alert-records
	QueryAlertRecord(context.Context, *QueryAlertRecordRequest) (*QueryAlertRecordResponse, error)
	// GET /api/alert-records/{groupId}
	GetAlertRecord(context.Context, *GetAlertRecordRequest) (*GetAlertRecordResponse, error)
	// GET /api/alert-records/{groupId}/histories
	QueryAlertHistory(context.Context, *QueryAlertHistoryRequest) (*QueryAlertHistoryResponse, error)
	// POST /api/alert-records/{groupId}/issues
	CreateAlertIssue(context.Context, *CreateAlertIssueRequest) (*CreateAlertIssueResponse, error)
	// PUT /api/alert-records/{groupId}/issues/{issueId}
	UpdateAlertIssue(context.Context, *UpdateAlertIssueRequest) (*UpdateAlertIssueResponse, error)
	// GET /api/org-alert-record-attrs
	GetOrgAlertRecordAttr(context.Context, *GetOrgAlertRecordAttrRequest) (*GetOrgAlertRecordAttrResponse, error)
	// GET /api/org-alert-records
	QueryOrgAlertRecord(context.Context, *QueryOrgAlertRecordRequest) (*QueryOrgAlertRecordResponse, error)
	// POST /api/org-hosts-alert-records
	QueryOrgHostsAlertRecord(context.Context, *QueryOrgHostsAlertRecordRequest) (*QueryOrgAlertRecordResponse, error)
	// GET /api/org-alert-records/{groupId}
	GetOrgAlertRecord(context.Context, *GetOrgAlertRecordRequest) (*GetOrgAlertRecordResponse, error)
	// GET /api/org-alert-records/{groupId}/histories
	QueryOrgAlertHistory(context.Context, *QueryOrgAlertHistoryRequest) (*QueryOrgAlertHistoryResponse, error)
	// POST /api/org-alert-records/{groupId}/issues
	CreateOrgAlertIssue(context.Context, *CreateOrgAlertIssueRequest) (*CreateOrgAlertIssueResponse, error)
	// PUT /api/org-alert-records/{groupId}/issues
	UpdateOrgAlertIssue(context.Context, *UpdateOrgAlertIssueRequest) (*UpdateOrgAlertIssueResponse, error)
	// GET /api/alert-events
	GetAlertEvents(context.Context, *GetAlertEventRequest) (*GetAlertEventResponse, error)
	// POST /api/alert-events/suppress
	SuppressAlertEvent(context.Context, *SuppressAlertEventRequest) (*SuppressAlertEventResponse, error)
	// POST /api/alert-events/cancel-suppress
	CancelSuppressAlertEvent(context.Context, *CancelSuppressAlertEventRequest) (*CancelSuppressAlertEventResponse, error)
	// GET /api/alert-events/stats/unrecover
	CountUnRecoverAlertEvents(context.Context, *CountUnRecoverAlertEventsRequest) (*CountUnRecoverAlertEventsResponse, error)
}

// RegisterAlertServiceHandler register AlertServiceHandler to http.Router.
func RegisterAlertServiceHandler(r http.Router, srv AlertServiceHandler, opts ...http.HandleOption) {
	h := http.DefaultHandleOptions()
	for _, op := range opts {
		op(h)
	}
	encodeFunc := func(fn func(http1.ResponseWriter, *http1.Request) (interface{}, error)) http.HandlerFunc {
		handler := func(w http1.ResponseWriter, r *http1.Request) {
			out, err := fn(w, r)
			if err != nil {
				h.Error(w, r, err)
				return
			}
			if err := h.Encode(w, r, out); err != nil {
				h.Error(w, r, err)
			}
		}
		if h.HTTPInterceptor != nil {
			handler = h.HTTPInterceptor(handler)
		}
		return handler
	}

	add_QueryCustomizeMetric := func(method, path string, fn func(context.Context, *QueryCustomizeMetricRequest) (*QueryCustomizeMetricResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QueryCustomizeMetricRequest))
		}
		var QueryCustomizeMetric_info transport.ServiceInfo
		if h.Interceptor != nil {
			QueryCustomizeMetric_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "QueryCustomizeMetric", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QueryCustomizeMetric_info)
				}
				r = r.WithContext(ctx)
				var in QueryCustomizeMetricRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QueryCustomizeNotifyTarget := func(method, path string, fn func(context.Context, *QueryCustomizeNotifyTargetRequest) (*QueryCustomizeNotifyTargetResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QueryCustomizeNotifyTargetRequest))
		}
		var QueryCustomizeNotifyTarget_info transport.ServiceInfo
		if h.Interceptor != nil {
			QueryCustomizeNotifyTarget_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "QueryCustomizeNotifyTarget", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QueryCustomizeNotifyTarget_info)
				}
				r = r.WithContext(ctx)
				var in QueryCustomizeNotifyTargetRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QueryOrgCustomizeNotifyTarget := func(method, path string, fn func(context.Context, *QueryOrgCustomizeNotifyTargetRequest) (*QueryOrgCustomizeNotifyTargetResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QueryOrgCustomizeNotifyTargetRequest))
		}
		var QueryOrgCustomizeNotifyTarget_info transport.ServiceInfo
		if h.Interceptor != nil {
			QueryOrgCustomizeNotifyTarget_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "QueryOrgCustomizeNotifyTarget", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QueryOrgCustomizeNotifyTarget_info)
				}
				r = r.WithContext(ctx)
				var in QueryOrgCustomizeNotifyTargetRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QueryCustomizeAlert := func(method, path string, fn func(context.Context, *QueryCustomizeAlertRequest) (*QueryCustomizeAlertResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QueryCustomizeAlertRequest))
		}
		var QueryCustomizeAlert_info transport.ServiceInfo
		if h.Interceptor != nil {
			QueryCustomizeAlert_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "QueryCustomizeAlert", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QueryCustomizeAlert_info)
				}
				r = r.WithContext(ctx)
				var in QueryCustomizeAlertRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetCustomizeAlert := func(method, path string, fn func(context.Context, *GetCustomizeAlertRequest) (*GetCustomizeAlertResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetCustomizeAlertRequest))
		}
		var GetCustomizeAlert_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetCustomizeAlert_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "GetCustomizeAlert", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetCustomizeAlert_info)
				}
				r = r.WithContext(ctx)
				var in GetCustomizeAlertRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							val, err := strconv.ParseUint(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetCustomizeAlertDetail := func(method, path string, fn func(context.Context, *GetCustomizeAlertDetailRequest) (*GetCustomizeAlertDetailResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetCustomizeAlertDetailRequest))
		}
		var GetCustomizeAlertDetail_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetCustomizeAlertDetail_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "GetCustomizeAlertDetail", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetCustomizeAlertDetail_info)
				}
				r = r.WithContext(ctx)
				var in GetCustomizeAlertDetailRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							val, err := strconv.ParseUint(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CreateCustomizeAlert := func(method, path string, fn func(context.Context, *CreateCustomizeAlertRequest) (*CreateCustomizeAlertResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateCustomizeAlertRequest))
		}
		var CreateCustomizeAlert_info transport.ServiceInfo
		if h.Interceptor != nil {
			CreateCustomizeAlert_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "CreateCustomizeAlert", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CreateCustomizeAlert_info)
				}
				r = r.WithContext(ctx)
				var in CreateCustomizeAlertRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_UpdateCustomizeAlert := func(method, path string, fn func(context.Context, *UpdateCustomizeAlertRequest) (*UpdateCustomizeAlertResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpdateCustomizeAlertRequest))
		}
		var UpdateCustomizeAlert_info transport.ServiceInfo
		if h.Interceptor != nil {
			UpdateCustomizeAlert_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "UpdateCustomizeAlert", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, UpdateCustomizeAlert_info)
				}
				r = r.WithContext(ctx)
				var in UpdateCustomizeAlertRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							val, err := strconv.ParseUint(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_UpdateCustomizeAlertEnable := func(method, path string, fn func(context.Context, *UpdateCustomizeAlertEnableRequest) (*UpdateCustomizeAlertEnableResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpdateCustomizeAlertEnableRequest))
		}
		var UpdateCustomizeAlertEnable_info transport.ServiceInfo
		if h.Interceptor != nil {
			UpdateCustomizeAlertEnable_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "UpdateCustomizeAlertEnable", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, UpdateCustomizeAlertEnable_info)
				}
				r = r.WithContext(ctx)
				var in UpdateCustomizeAlertEnableRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							val, err := strconv.ParseUint(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_DeleteCustomizeAlert := func(method, path string, fn func(context.Context, *DeleteCustomizeAlertRequest) (*DeleteCustomizeAlertResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DeleteCustomizeAlertRequest))
		}
		var DeleteCustomizeAlert_info transport.ServiceInfo
		if h.Interceptor != nil {
			DeleteCustomizeAlert_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "DeleteCustomizeAlert", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, DeleteCustomizeAlert_info)
				}
				r = r.WithContext(ctx)
				var in DeleteCustomizeAlertRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							val, err := strconv.ParseUint(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QueryOrgCustomizeMetric := func(method, path string, fn func(context.Context, *QueryOrgCustomizeMetricRequest) (*QueryOrgCustomizeMetricResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QueryOrgCustomizeMetricRequest))
		}
		var QueryOrgCustomizeMetric_info transport.ServiceInfo
		if h.Interceptor != nil {
			QueryOrgCustomizeMetric_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "QueryOrgCustomizeMetric", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QueryOrgCustomizeMetric_info)
				}
				r = r.WithContext(ctx)
				var in QueryOrgCustomizeMetricRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QueryOrgCustomizeAlerts := func(method, path string, fn func(context.Context, *QueryOrgCustomizeAlertsRequest) (*QueryOrgCustomizeAlertsResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QueryOrgCustomizeAlertsRequest))
		}
		var QueryOrgCustomizeAlerts_info transport.ServiceInfo
		if h.Interceptor != nil {
			QueryOrgCustomizeAlerts_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "QueryOrgCustomizeAlerts", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QueryOrgCustomizeAlerts_info)
				}
				r = r.WithContext(ctx)
				var in QueryOrgCustomizeAlertsRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetOrgCustomizeAlertDetail := func(method, path string, fn func(context.Context, *GetOrgCustomizeAlertDetailRequest) (*GetOrgCustomizeAlertDetailResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetOrgCustomizeAlertDetailRequest))
		}
		var GetOrgCustomizeAlertDetail_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetOrgCustomizeAlertDetail_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "GetOrgCustomizeAlertDetail", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetOrgCustomizeAlertDetail_info)
				}
				r = r.WithContext(ctx)
				var in GetOrgCustomizeAlertDetailRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							val, err := strconv.ParseUint(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CreateOrgCustomizeAlert := func(method, path string, fn func(context.Context, *CreateOrgCustomizeAlertRequest) (*CreateOrgCustomizeAlertResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateOrgCustomizeAlertRequest))
		}
		var CreateOrgCustomizeAlert_info transport.ServiceInfo
		if h.Interceptor != nil {
			CreateOrgCustomizeAlert_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "CreateOrgCustomizeAlert", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CreateOrgCustomizeAlert_info)
				}
				r = r.WithContext(ctx)
				var in CreateOrgCustomizeAlertRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_UpdateOrgCustomizeAlert := func(method, path string, fn func(context.Context, *UpdateOrgCustomizeAlertRequest) (*UpdateOrgCustomizeAlertResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpdateOrgCustomizeAlertRequest))
		}
		var UpdateOrgCustomizeAlert_info transport.ServiceInfo
		if h.Interceptor != nil {
			UpdateOrgCustomizeAlert_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "UpdateOrgCustomizeAlert", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, UpdateOrgCustomizeAlert_info)
				}
				r = r.WithContext(ctx)
				var in UpdateOrgCustomizeAlertRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							val, err := strconv.ParseUint(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_UpdateOrgCustomizeAlertEnable := func(method, path string, fn func(context.Context, *UpdateOrgCustomizeAlertEnableRequest) (*UpdateOrgCustomizeAlertEnableResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpdateOrgCustomizeAlertEnableRequest))
		}
		var UpdateOrgCustomizeAlertEnable_info transport.ServiceInfo
		if h.Interceptor != nil {
			UpdateOrgCustomizeAlertEnable_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "UpdateOrgCustomizeAlertEnable", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, UpdateOrgCustomizeAlertEnable_info)
				}
				r = r.WithContext(ctx)
				var in UpdateOrgCustomizeAlertEnableRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							val, err := strconv.ParseInt(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_DeleteOrgCustomizeAlert := func(method, path string, fn func(context.Context, *DeleteOrgCustomizeAlertRequest) (*DeleteOrgCustomizeAlertResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DeleteOrgCustomizeAlertRequest))
		}
		var DeleteOrgCustomizeAlert_info transport.ServiceInfo
		if h.Interceptor != nil {
			DeleteOrgCustomizeAlert_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "DeleteOrgCustomizeAlert", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, DeleteOrgCustomizeAlert_info)
				}
				r = r.WithContext(ctx)
				var in DeleteOrgCustomizeAlertRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							val, err := strconv.ParseUint(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QueryDashboardByAlert := func(method, path string, fn func(context.Context, *QueryDashboardByAlertRequest) (*QueryDashboardByAlertResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QueryDashboardByAlertRequest))
		}
		var QueryDashboardByAlert_info transport.ServiceInfo
		if h.Interceptor != nil {
			QueryDashboardByAlert_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "QueryDashboardByAlert", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QueryDashboardByAlert_info)
				}
				r = r.WithContext(ctx)
				var in QueryDashboardByAlertRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QueryOrgDashboardByAlert := func(method, path string, fn func(context.Context, *QueryOrgDashboardByAlertRequest) (*QueryOrgDashboardByAlertResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QueryOrgDashboardByAlertRequest))
		}
		var QueryOrgDashboardByAlert_info transport.ServiceInfo
		if h.Interceptor != nil {
			QueryOrgDashboardByAlert_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "QueryOrgDashboardByAlert", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QueryOrgDashboardByAlert_info)
				}
				r = r.WithContext(ctx)
				var in QueryOrgDashboardByAlertRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QueryAlertRule := func(method, path string, fn func(context.Context, *QueryAlertRuleRequest) (*QueryAlertRuleResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QueryAlertRuleRequest))
		}
		var QueryAlertRule_info transport.ServiceInfo
		if h.Interceptor != nil {
			QueryAlertRule_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "QueryAlertRule", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QueryAlertRule_info)
				}
				r = r.WithContext(ctx)
				var in QueryAlertRuleRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QueryAlert := func(method, path string, fn func(context.Context, *QueryAlertRequest) (*QueryAlertsResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QueryAlertRequest))
		}
		var QueryAlert_info transport.ServiceInfo
		if h.Interceptor != nil {
			QueryAlert_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "QueryAlert", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QueryAlert_info)
				}
				r = r.WithContext(ctx)
				var in QueryAlertRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetAlert := func(method, path string, fn func(context.Context, *GetAlertRequest) (*GetAlertResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetAlertRequest))
		}
		var GetAlert_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetAlert_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "GetAlert", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetAlert_info)
				}
				r = r.WithContext(ctx)
				var in GetAlertRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							val, err := strconv.ParseInt(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetAlertDetail := func(method, path string, fn func(context.Context, *GetAlertDetailRequest) (*GetAlertDetailResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetAlertDetailRequest))
		}
		var GetAlertDetail_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetAlertDetail_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "GetAlertDetail", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetAlertDetail_info)
				}
				r = r.WithContext(ctx)
				var in GetAlertDetailRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							val, err := strconv.ParseInt(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CreateAlert := func(method, path string, fn func(context.Context, *CreateAlertRequest) (*CreateAlertResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateAlertRequest))
		}
		var CreateAlert_info transport.ServiceInfo
		if h.Interceptor != nil {
			CreateAlert_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "CreateAlert", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CreateAlert_info)
				}
				r = r.WithContext(ctx)
				var in CreateAlertRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_UpdateAlert := func(method, path string, fn func(context.Context, *UpdateAlertRequest) (*UpdateAlertResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpdateAlertRequest))
		}
		var UpdateAlert_info transport.ServiceInfo
		if h.Interceptor != nil {
			UpdateAlert_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "UpdateAlert", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, UpdateAlert_info)
				}
				r = r.WithContext(ctx)
				var in UpdateAlertRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							val, err := strconv.ParseUint(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_UpdateAlertEnable := func(method, path string, fn func(context.Context, *UpdateAlertEnableRequest) (*UpdateAlertEnableResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpdateAlertEnableRequest))
		}
		var UpdateAlertEnable_info transport.ServiceInfo
		if h.Interceptor != nil {
			UpdateAlertEnable_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "UpdateAlertEnable", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, UpdateAlertEnable_info)
				}
				r = r.WithContext(ctx)
				var in UpdateAlertEnableRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							val, err := strconv.ParseInt(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_DeleteAlert := func(method, path string, fn func(context.Context, *DeleteAlertRequest) (*DeleteAlertResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DeleteAlertRequest))
		}
		var DeleteAlert_info transport.ServiceInfo
		if h.Interceptor != nil {
			DeleteAlert_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "DeleteAlert", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, DeleteAlert_info)
				}
				r = r.WithContext(ctx)
				var in DeleteAlertRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							val, err := strconv.ParseInt(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetRawAlertExpression := func(method, path string, fn func(context.Context, *GetRawAlertExpressionRequest) (*GetRawAlertExpressionResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetRawAlertExpressionRequest))
		}
		var GetRawAlertExpression_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetRawAlertExpression_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "GetRawAlertExpression", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetRawAlertExpression_info)
				}
				r = r.WithContext(ctx)
				var in GetRawAlertExpressionRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							val, err := strconv.ParseUint(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QueryOrgAlertRule := func(method, path string, fn func(context.Context, *QueryOrgAlertRuleRequest) (*QueryOrgAlertRuleResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QueryOrgAlertRuleRequest))
		}
		var QueryOrgAlertRule_info transport.ServiceInfo
		if h.Interceptor != nil {
			QueryOrgAlertRule_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "QueryOrgAlertRule", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QueryOrgAlertRule_info)
				}
				r = r.WithContext(ctx)
				var in QueryOrgAlertRuleRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QueryOrgAlert := func(method, path string, fn func(context.Context, *QueryOrgAlertRequest) (*QueryOrgAlertResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QueryOrgAlertRequest))
		}
		var QueryOrgAlert_info transport.ServiceInfo
		if h.Interceptor != nil {
			QueryOrgAlert_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "QueryOrgAlert", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QueryOrgAlert_info)
				}
				r = r.WithContext(ctx)
				var in QueryOrgAlertRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetOrgAlertDetail := func(method, path string, fn func(context.Context, *GetOrgAlertDetailRequest) (*GetOrgAlertDetailResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetOrgAlertDetailRequest))
		}
		var GetOrgAlertDetail_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetOrgAlertDetail_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "GetOrgAlertDetail", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetOrgAlertDetail_info)
				}
				r = r.WithContext(ctx)
				var in GetOrgAlertDetailRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							val, err := strconv.ParseInt(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CreateOrgAlert := func(method, path string, fn func(context.Context, *CreateOrgAlertRequest) (*CreateOrgAlertResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateOrgAlertRequest))
		}
		var CreateOrgAlert_info transport.ServiceInfo
		if h.Interceptor != nil {
			CreateOrgAlert_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "CreateOrgAlert", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CreateOrgAlert_info)
				}
				r = r.WithContext(ctx)
				var in CreateOrgAlertRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_UpdateOrgAlert := func(method, path string, fn func(context.Context, *UpdateOrgAlertRequest) (*UpdateOrgAlertResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpdateOrgAlertRequest))
		}
		var UpdateOrgAlert_info transport.ServiceInfo
		if h.Interceptor != nil {
			UpdateOrgAlert_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "UpdateOrgAlert", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, UpdateOrgAlert_info)
				}
				r = r.WithContext(ctx)
				var in UpdateOrgAlertRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							val, err := strconv.ParseUint(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_UpdateOrgAlertEnable := func(method, path string, fn func(context.Context, *UpdateOrgAlertEnableRequest) (*UpdateOrgAlertEnableResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpdateOrgAlertEnableRequest))
		}
		var UpdateOrgAlertEnable_info transport.ServiceInfo
		if h.Interceptor != nil {
			UpdateOrgAlertEnable_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "UpdateOrgAlertEnable", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, UpdateOrgAlertEnable_info)
				}
				r = r.WithContext(ctx)
				var in UpdateOrgAlertEnableRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							val, err := strconv.ParseInt(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_DeleteOrgAlert := func(method, path string, fn func(context.Context, *DeleteOrgAlertRequest) (*DeleteOrgAlertResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DeleteOrgAlertRequest))
		}
		var DeleteOrgAlert_info transport.ServiceInfo
		if h.Interceptor != nil {
			DeleteOrgAlert_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "DeleteOrgAlert", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, DeleteOrgAlert_info)
				}
				r = r.WithContext(ctx)
				var in DeleteOrgAlertRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "id":
							val, err := strconv.ParseInt(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.Id = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetAlertRecordAttr := func(method, path string, fn func(context.Context, *GetAlertRecordAttrRequest) (*GetAlertRecordAttrResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetAlertRecordAttrRequest))
		}
		var GetAlertRecordAttr_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetAlertRecordAttr_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "GetAlertRecordAttr", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetAlertRecordAttr_info)
				}
				r = r.WithContext(ctx)
				var in GetAlertRecordAttrRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QueryAlertRecord := func(method, path string, fn func(context.Context, *QueryAlertRecordRequest) (*QueryAlertRecordResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QueryAlertRecordRequest))
		}
		var QueryAlertRecord_info transport.ServiceInfo
		if h.Interceptor != nil {
			QueryAlertRecord_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "QueryAlertRecord", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QueryAlertRecord_info)
				}
				r = r.WithContext(ctx)
				var in QueryAlertRecordRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetAlertRecord := func(method, path string, fn func(context.Context, *GetAlertRecordRequest) (*GetAlertRecordResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetAlertRecordRequest))
		}
		var GetAlertRecord_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetAlertRecord_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "GetAlertRecord", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetAlertRecord_info)
				}
				r = r.WithContext(ctx)
				var in GetAlertRecordRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "groupId":
							in.GroupId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QueryAlertHistory := func(method, path string, fn func(context.Context, *QueryAlertHistoryRequest) (*QueryAlertHistoryResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QueryAlertHistoryRequest))
		}
		var QueryAlertHistory_info transport.ServiceInfo
		if h.Interceptor != nil {
			QueryAlertHistory_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "QueryAlertHistory", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QueryAlertHistory_info)
				}
				r = r.WithContext(ctx)
				var in QueryAlertHistoryRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "groupId":
							in.GroupId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CreateAlertIssue := func(method, path string, fn func(context.Context, *CreateAlertIssueRequest) (*CreateAlertIssueResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateAlertIssueRequest))
		}
		var CreateAlertIssue_info transport.ServiceInfo
		if h.Interceptor != nil {
			CreateAlertIssue_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "CreateAlertIssue", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CreateAlertIssue_info)
				}
				r = r.WithContext(ctx)
				var in CreateAlertIssueRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "groupId":
							in.GroupId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_UpdateAlertIssue := func(method, path string, fn func(context.Context, *UpdateAlertIssueRequest) (*UpdateAlertIssueResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpdateAlertIssueRequest))
		}
		var UpdateAlertIssue_info transport.ServiceInfo
		if h.Interceptor != nil {
			UpdateAlertIssue_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "UpdateAlertIssue", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, UpdateAlertIssue_info)
				}
				r = r.WithContext(ctx)
				var in UpdateAlertIssueRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "groupId":
							in.GroupId = val
						case "issueId":
							val, err := strconv.ParseUint(val, 10, 64)
							if err != nil {
								return nil, err
							}
							in.IssueId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetOrgAlertRecordAttr := func(method, path string, fn func(context.Context, *GetOrgAlertRecordAttrRequest) (*GetOrgAlertRecordAttrResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetOrgAlertRecordAttrRequest))
		}
		var GetOrgAlertRecordAttr_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetOrgAlertRecordAttr_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "GetOrgAlertRecordAttr", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetOrgAlertRecordAttr_info)
				}
				r = r.WithContext(ctx)
				var in GetOrgAlertRecordAttrRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QueryOrgAlertRecord := func(method, path string, fn func(context.Context, *QueryOrgAlertRecordRequest) (*QueryOrgAlertRecordResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QueryOrgAlertRecordRequest))
		}
		var QueryOrgAlertRecord_info transport.ServiceInfo
		if h.Interceptor != nil {
			QueryOrgAlertRecord_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "QueryOrgAlertRecord", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QueryOrgAlertRecord_info)
				}
				r = r.WithContext(ctx)
				var in QueryOrgAlertRecordRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QueryOrgHostsAlertRecord := func(method, path string, fn func(context.Context, *QueryOrgHostsAlertRecordRequest) (*QueryOrgAlertRecordResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QueryOrgHostsAlertRecordRequest))
		}
		var QueryOrgHostsAlertRecord_info transport.ServiceInfo
		if h.Interceptor != nil {
			QueryOrgHostsAlertRecord_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "QueryOrgHostsAlertRecord", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QueryOrgHostsAlertRecord_info)
				}
				r = r.WithContext(ctx)
				var in QueryOrgHostsAlertRecordRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetOrgAlertRecord := func(method, path string, fn func(context.Context, *GetOrgAlertRecordRequest) (*GetOrgAlertRecordResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetOrgAlertRecordRequest))
		}
		var GetOrgAlertRecord_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetOrgAlertRecord_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "GetOrgAlertRecord", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetOrgAlertRecord_info)
				}
				r = r.WithContext(ctx)
				var in GetOrgAlertRecordRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "groupId":
							in.GroupId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QueryOrgAlertHistory := func(method, path string, fn func(context.Context, *QueryOrgAlertHistoryRequest) (*QueryOrgAlertHistoryResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*QueryOrgAlertHistoryRequest))
		}
		var QueryOrgAlertHistory_info transport.ServiceInfo
		if h.Interceptor != nil {
			QueryOrgAlertHistory_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "QueryOrgAlertHistory", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, QueryOrgAlertHistory_info)
				}
				r = r.WithContext(ctx)
				var in QueryOrgAlertHistoryRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "groupId":
							in.GroupId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CreateOrgAlertIssue := func(method, path string, fn func(context.Context, *CreateOrgAlertIssueRequest) (*CreateOrgAlertIssueResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateOrgAlertIssueRequest))
		}
		var CreateOrgAlertIssue_info transport.ServiceInfo
		if h.Interceptor != nil {
			CreateOrgAlertIssue_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "CreateOrgAlertIssue", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CreateOrgAlertIssue_info)
				}
				r = r.WithContext(ctx)
				var in CreateOrgAlertIssueRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "groupId":
							in.GroupId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_UpdateOrgAlertIssue := func(method, path string, fn func(context.Context, *UpdateOrgAlertIssueRequest) (*UpdateOrgAlertIssueResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpdateOrgAlertIssueRequest))
		}
		var UpdateOrgAlertIssue_info transport.ServiceInfo
		if h.Interceptor != nil {
			UpdateOrgAlertIssue_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "UpdateOrgAlertIssue", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, UpdateOrgAlertIssue_info)
				}
				r = r.WithContext(ctx)
				var in UpdateOrgAlertIssueRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "groupId":
							in.GroupId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetAlertEvents := func(method, path string, fn func(context.Context, *GetAlertEventRequest) (*GetAlertEventResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetAlertEventRequest))
		}
		var GetAlertEvents_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetAlertEvents_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "GetAlertEvents", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetAlertEvents_info)
				}
				r = r.WithContext(ctx)
				var in GetAlertEventRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_SuppressAlertEvent := func(method, path string, fn func(context.Context, *SuppressAlertEventRequest) (*SuppressAlertEventResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*SuppressAlertEventRequest))
		}
		var SuppressAlertEvent_info transport.ServiceInfo
		if h.Interceptor != nil {
			SuppressAlertEvent_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "SuppressAlertEvent", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, SuppressAlertEvent_info)
				}
				r = r.WithContext(ctx)
				var in SuppressAlertEventRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CancelSuppressAlertEvent := func(method, path string, fn func(context.Context, *CancelSuppressAlertEventRequest) (*CancelSuppressAlertEventResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CancelSuppressAlertEventRequest))
		}
		var CancelSuppressAlertEvent_info transport.ServiceInfo
		if h.Interceptor != nil {
			CancelSuppressAlertEvent_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "CancelSuppressAlertEvent", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CancelSuppressAlertEvent_info)
				}
				r = r.WithContext(ctx)
				var in CancelSuppressAlertEventRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CountUnRecoverAlertEvents := func(method, path string, fn func(context.Context, *CountUnRecoverAlertEventsRequest) (*CountUnRecoverAlertEventsResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CountUnRecoverAlertEventsRequest))
		}
		var CountUnRecoverAlertEvents_info transport.ServiceInfo
		if h.Interceptor != nil {
			CountUnRecoverAlertEvents_info = transport.NewServiceInfo("erda.core.monitor.alert.AlertService", "CountUnRecoverAlertEvents", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CountUnRecoverAlertEvents_info)
				}
				r = r.WithContext(ctx)
				var in CountUnRecoverAlertEventsRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_QueryCustomizeMetric("GET", "/api/customize/alerts/metrics", srv.QueryCustomizeMetric)
	add_QueryCustomizeNotifyTarget("GET", "/api/customize/alerts/notifies/targets", srv.QueryCustomizeNotifyTarget)
	add_QueryOrgCustomizeNotifyTarget("GET", "/api/orgs/customize/alerts/notifies/targets", srv.QueryOrgCustomizeNotifyTarget)
	add_QueryCustomizeAlert("GET", "/api/customize/alerts", srv.QueryCustomizeAlert)
	add_GetCustomizeAlert("GET", "/api/customize/alerts/{id}", srv.GetCustomizeAlert)
	add_GetCustomizeAlertDetail("GET", "/api/customize/alerts/{id}/detail", srv.GetCustomizeAlertDetail)
	add_CreateCustomizeAlert("POST", "/api/customize/alerts", srv.CreateCustomizeAlert)
	add_UpdateCustomizeAlert("PUT", "/api/customize/alerts/{id}", srv.UpdateCustomizeAlert)
	add_UpdateCustomizeAlertEnable("PUT", "/api/customize/alerts/{id}/switch", srv.UpdateCustomizeAlertEnable)
	add_DeleteCustomizeAlert("DELETE", "/api/customize/alerts/{id}", srv.DeleteCustomizeAlert)
	add_QueryOrgCustomizeMetric("GET", "/api/orgs/customize/alerts/metrics", srv.QueryOrgCustomizeMetric)
	add_QueryOrgCustomizeAlerts("GET", "/api/orgs/customize/alerts", srv.QueryOrgCustomizeAlerts)
	add_GetOrgCustomizeAlertDetail("GET", "/api/orgs/customize/alerts/{id}", srv.GetOrgCustomizeAlertDetail)
	add_CreateOrgCustomizeAlert("POST", "/api/orgs/customize/alerts", srv.CreateOrgCustomizeAlert)
	add_UpdateOrgCustomizeAlert("PUT", "/api/orgs/customize/alerts/{id}", srv.UpdateOrgCustomizeAlert)
	add_UpdateOrgCustomizeAlertEnable("PUT", "/api/orgs/customize/alerts/{id}/switch", srv.UpdateOrgCustomizeAlertEnable)
	add_DeleteOrgCustomizeAlert("DELETE", "/api/orgs/customize/alerts/{id}", srv.DeleteOrgCustomizeAlert)
	add_QueryDashboardByAlert("POST", "/api/customize/alerts/dash-preview/query", srv.QueryDashboardByAlert)
	add_QueryOrgDashboardByAlert("POST", "/api/orgs/customize/alerts/dash-preview/query", srv.QueryOrgDashboardByAlert)
	add_QueryAlertRule("GET", "/api/alerts/rules", srv.QueryAlertRule)
	add_QueryAlert("GET", "/api/alerts", srv.QueryAlert)
	add_GetAlert("GET", "/api/alerts/{id}", srv.GetAlert)
	add_GetAlertDetail("GET", "/api/alerts/{id}/detail", srv.GetAlertDetail)
	add_CreateAlert("POST", "/api/alerts", srv.CreateAlert)
	add_UpdateAlert("PUT", "/api/alerts/{id}", srv.UpdateAlert)
	add_UpdateAlertEnable("PUT", "/api/alerts/{id}/switch", srv.UpdateAlertEnable)
	add_DeleteAlert("DELETE", "/api/alerts/{id}", srv.DeleteAlert)
	add_GetRawAlertExpression("GET", "/api/alerts/expressions/{id}", srv.GetRawAlertExpression)
	add_QueryOrgAlertRule("GET", "/api/orgs/alerts/rules", srv.QueryOrgAlertRule)
	add_QueryOrgAlert("GET", "/api/orgs/alerts", srv.QueryOrgAlert)
	add_GetOrgAlertDetail("GET", "/api/orgs/alerts/{id}", srv.GetOrgAlertDetail)
	add_CreateOrgAlert("POST", "/api/orgs/alerts", srv.CreateOrgAlert)
	add_UpdateOrgAlert("PUT", "/api/orgs/alerts/{id}", srv.UpdateOrgAlert)
	add_UpdateOrgAlertEnable("PUT", "/api/orgs/alerts/{id}/switch", srv.UpdateOrgAlertEnable)
	add_DeleteOrgAlert("DELETE", "/api/orgs/alerts/{id}", srv.DeleteOrgAlert)
	add_GetAlertRecordAttr("GET", "/api/alert-record-attrs", srv.GetAlertRecordAttr)
	add_QueryAlertRecord("GET", "/api/alert-records", srv.QueryAlertRecord)
	add_GetAlertRecord("GET", "/api/alert-records/{groupId}", srv.GetAlertRecord)
	add_QueryAlertHistory("GET", "/api/alert-records/{groupId}/histories", srv.QueryAlertHistory)
	add_CreateAlertIssue("POST", "/api/alert-records/{groupId}/issues", srv.CreateAlertIssue)
	add_UpdateAlertIssue("PUT", "/api/alert-records/{groupId}/issues/{issueId}", srv.UpdateAlertIssue)
	add_GetOrgAlertRecordAttr("GET", "/api/org-alert-record-attrs", srv.GetOrgAlertRecordAttr)
	add_QueryOrgAlertRecord("GET", "/api/org-alert-records", srv.QueryOrgAlertRecord)
	add_QueryOrgHostsAlertRecord("POST", "/api/org-hosts-alert-records", srv.QueryOrgHostsAlertRecord)
	add_GetOrgAlertRecord("GET", "/api/org-alert-records/{groupId}", srv.GetOrgAlertRecord)
	add_QueryOrgAlertHistory("GET", "/api/org-alert-records/{groupId}/histories", srv.QueryOrgAlertHistory)
	add_CreateOrgAlertIssue("POST", "/api/org-alert-records/{groupId}/issues", srv.CreateOrgAlertIssue)
	add_UpdateOrgAlertIssue("PUT", "/api/org-alert-records/{groupId}/issues", srv.UpdateOrgAlertIssue)
	add_GetAlertEvents("GET", "/api/alert-events", srv.GetAlertEvents)
	add_SuppressAlertEvent("POST", "/api/alert-events/suppress", srv.SuppressAlertEvent)
	add_CancelSuppressAlertEvent("POST", "/api/alert-events/cancel-suppress", srv.CancelSuppressAlertEvent)
	add_CountUnRecoverAlertEvents("GET", "/api/alert-events/stats/unrecover", srv.CountUnRecoverAlertEvents)
}
