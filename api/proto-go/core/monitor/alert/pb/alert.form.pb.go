// Code generated by protoc-gen-go-form. DO NOT EDIT.
// Source: alert.proto

package pb

import (
	json "encoding/json"
	url "net/url"
	strconv "strconv"
	strings "strings"

	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
	structpb "google.golang.org/protobuf/types/known/structpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/urlenc" package it is being compiled against.
var _ urlenc.URLValuesUnmarshaler = (*CountUnRecoverAlertEventsRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CountUnRecoverAlertEventsResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CountUnRecoverAlertEventsResult)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetRawAlertExpressionResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*RawAlertExpression)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetRawAlertExpressionRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AlertEventSort)(nil)
var _ urlenc.URLValuesUnmarshaler = (*SuppressAlertEventRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*SuppressAlertEventResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CancelSuppressAlertEventRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CancelSuppressAlertEventResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAlertEventRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAlertEventRequestCondition)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAlertEventResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AlertEventItem)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryCustomizeMetricRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryCustomizeMetricResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CustomizeMetrics)(nil)
var _ urlenc.URLValuesUnmarshaler = (*MetricMeta)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DisplayKey)(nil)
var _ urlenc.URLValuesUnmarshaler = (*FieldMeta)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TagMeta)(nil)
var _ urlenc.URLValuesUnmarshaler = (*Operator)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryCustomizeNotifyTargetRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryCustomizeNotifyTargetResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryCustomizeNotifyTargetData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryOrgCustomizeNotifyTargetRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryOrgCustomizeNotifyTargetResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryCustomizeAlertRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryCustomizeAlertResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryCustomizeAlertData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CustomizeAlertOverview)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetCustomizeAlertRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetCustomizeAlertResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CustomizeAlertDetail)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CustomizeAlertRule)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CustomizeAlertRuleFunction)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CustomizeAlertRuleFilter)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CustomizeAlertNotifyTemplates)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetCustomizeAlertDetailRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetCustomizeAlertDetailResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateCustomizeAlertRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateCustomizeAlertResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateCustomizeAlertRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateCustomizeAlertResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateCustomizeAlertEnableRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateCustomizeAlertEnableResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteCustomizeAlertRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteCustomizeAlertResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryOrgCustomizeMetricRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryOrgCustomizeMetricResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryOrgCustomizeAlertsRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryOrgCustomizeAlertsResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryOrgCustomizeAlertsData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetOrgCustomizeAlertDetailRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetOrgCustomizeAlertDetailResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateOrgCustomizeAlertRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateOrgCustomizeAlertResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateOrgCustomizeAlertRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateOrgCustomizeAlertResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateOrgCustomizeAlertEnableRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateOrgCustomizeAlertEnableResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteOrgCustomizeAlertRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteOrgCustomizeAlertResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryDashboardByAlertRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryDashboardByAlertResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*View)(nil)
var _ urlenc.URLValuesUnmarshaler = (*Config)(nil)
var _ urlenc.URLValuesUnmarshaler = (*API)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryOrgDashboardByAlertRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryOrgDashboardByAlertResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryAlertRuleRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryAlertRuleResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AlertTypeRuleResp)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AlertTypeRule)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AlertRule)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AlertRuleFunction)(nil)
var _ urlenc.URLValuesUnmarshaler = (*NotifySilence)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryAlertRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryAlertsResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryAlertsData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*Alert)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AlertExpression)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AlertExpressionFunction)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AlertNotify)(nil)
var _ urlenc.URLValuesUnmarshaler = (*NotifyGroup)(nil)
var _ urlenc.URLValuesUnmarshaler = (*NotifyTarget)(nil)
var _ urlenc.URLValuesUnmarshaler = (*Target)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AlertNotifySilence)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAlertRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAlertResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAlertDetailRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAlertDetailResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateAlertRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateAlertResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateAlertRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateAlertResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateAlertEnableRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateAlertEnableResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteAlertRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteAlertResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryOrgAlertRuleRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryOrgAlertRuleResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryOrgAlertRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryOrgAlertResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryOrgAlertData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetOrgAlertDetailRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetOrgAlertDetailResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateOrgAlertRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*TriggerCondition)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateOrgAlertResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateOrgAlertRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateOrgAlertResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateOrgAlertEnableRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateOrgAlertEnableResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteOrgAlertRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteOrgAlertResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAlertRecordAttrRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAlertRecordAttrResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AlertRecordAttr)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryAlertRecordRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryAlertRecordResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListResult)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AlertRecord)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAlertRecordRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAlertRecordResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryAlertHistoryRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryAlertHistoryResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AlertHistory)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateAlertIssueRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*IssueManHour)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateAlertIssueResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateAlertIssueRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateAlertIssueResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetOrgAlertRecordAttrRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetOrgAlertRecordAttrResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryOrgAlertRecordRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryOrgHostsAlertRecordRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ClusterReq)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryOrgAlertRecordResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetOrgAlertRecordRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetOrgAlertRecordResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryOrgAlertHistoryRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*QueryOrgAlertHistoryResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateOrgAlertIssueRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateOrgAlertIssueResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateOrgAlertIssueRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateOrgAlertIssueResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAlertConditionsRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAlertConditionsResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*Conditions)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAlertConditionsValueRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ConditionsValueRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetAlertConditionsValueResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*AlertConditionsValue)(nil)

// CountUnRecoverAlertEventsRequest implement urlenc.URLValuesUnmarshaler.
func (m *CountUnRecoverAlertEventsRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "scope":
				m.Scope = vals[0]
			case "scopeId":
				m.ScopeId = vals[0]
			}
		}
	}
	return nil
}

// CountUnRecoverAlertEventsResponse implement urlenc.URLValuesUnmarshaler.
func (m *CountUnRecoverAlertEventsResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &CountUnRecoverAlertEventsResult{}
				}
			case "data.count":
				if m.Data == nil {
					m.Data = &CountUnRecoverAlertEventsResult{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Count = val
			}
		}
	}
	return nil
}

// CountUnRecoverAlertEventsResult implement urlenc.URLValuesUnmarshaler.
func (m *CountUnRecoverAlertEventsResult) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "count":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Count = val
			}
		}
	}
	return nil
}

// GetRawAlertExpressionResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetRawAlertExpressionResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &RawAlertExpression{}
				}
			case "data.id":
				if m.Data == nil {
					m.Data = &RawAlertExpression{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Id = val
			case "data.alertId":
				if m.Data == nil {
					m.Data = &RawAlertExpression{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.AlertId = val
			case "data.expression":
				if m.Data == nil {
					m.Data = &RawAlertExpression{}
				}
				m.Data.Expression = vals[0]
			case "data.attributes":
				if m.Data == nil {
					m.Data = &RawAlertExpression{}
				}
				m.Data.Attributes = vals[0]
			case "data.version":
				if m.Data == nil {
					m.Data = &RawAlertExpression{}
				}
				m.Data.Version = vals[0]
			case "data.enable":
				if m.Data == nil {
					m.Data = &RawAlertExpression{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Enable = val
			}
		}
	}
	return nil
}

// RawAlertExpression implement urlenc.URLValuesUnmarshaler.
func (m *RawAlertExpression) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "alertId":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AlertId = val
			case "expression":
				m.Expression = vals[0]
			case "attributes":
				m.Attributes = vals[0]
			case "version":
				m.Version = vals[0]
			case "enable":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Enable = val
			}
		}
	}
	return nil
}

// GetRawAlertExpressionRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetRawAlertExpressionRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			}
		}
	}
	return nil
}

// AlertEventSort implement urlenc.URLValuesUnmarshaler.
func (m *AlertEventSort) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "sortField":
				m.SortField = vals[0]
			case "Descending":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Descending = val
			}
		}
	}
	return nil
}

// SuppressAlertEventRequest implement urlenc.URLValuesUnmarshaler.
func (m *SuppressAlertEventRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "orgID":
				m.OrgID = vals[0]
			case "scope":
				m.Scope = vals[0]
			case "scopeID":
				m.ScopeID = vals[0]
			case "alertEventID":
				m.AlertEventID = vals[0]
			case "suppressType":
				m.SuppressType = vals[0]
			case "expireTime":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ExpireTime = val
			}
		}
	}
	return nil
}

// SuppressAlertEventResponse implement urlenc.URLValuesUnmarshaler.
func (m *SuppressAlertEventResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "result":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Result = val
			}
		}
	}
	return nil
}

// CancelSuppressAlertEventRequest implement urlenc.URLValuesUnmarshaler.
func (m *CancelSuppressAlertEventRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "alertEventID":
				m.AlertEventID = vals[0]
			}
		}
	}
	return nil
}

// CancelSuppressAlertEventResponse implement urlenc.URLValuesUnmarshaler.
func (m *CancelSuppressAlertEventResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "result":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Result = val
			}
		}
	}
	return nil
}

// GetAlertEventRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetAlertEventRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "scope":
				m.Scope = vals[0]
			case "scopeId":
				m.ScopeId = vals[0]
			case "condition":
				if m.Condition == nil {
					m.Condition = &GetAlertEventRequestCondition{}
				}
			case "condition.name":
				if m.Condition == nil {
					m.Condition = &GetAlertEventRequestCondition{}
				}
				m.Condition.Name = vals[0]
			case "condition.ids":
				if m.Condition == nil {
					m.Condition = &GetAlertEventRequestCondition{}
				}
				m.Condition.Ids = vals
			case "condition.alertLevels":
				if m.Condition == nil {
					m.Condition = &GetAlertEventRequestCondition{}
				}
				m.Condition.AlertLevels = vals
			case "condition.alertIds":
				if m.Condition == nil {
					m.Condition = &GetAlertEventRequestCondition{}
				}
				list := make([]uint64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseUint(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.Condition.AlertIds = list
			case "condition.alertStates":
				if m.Condition == nil {
					m.Condition = &GetAlertEventRequestCondition{}
				}
				m.Condition.AlertStates = vals
			case "condition.alertSources":
				if m.Condition == nil {
					m.Condition = &GetAlertEventRequestCondition{}
				}
				m.Condition.AlertSources = vals
			case "condition.lastTriggerTimeMsMin":
				if m.Condition == nil {
					m.Condition = &GetAlertEventRequestCondition{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Condition.LastTriggerTimeMsMin = val
			case "condition.lastTriggerTimeMsMax":
				if m.Condition == nil {
					m.Condition = &GetAlertEventRequestCondition{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Condition.LastTriggerTimeMsMax = val
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			}
		}
	}
	return nil
}

// GetAlertEventRequestCondition implement urlenc.URLValuesUnmarshaler.
func (m *GetAlertEventRequestCondition) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals[0]
			case "ids":
				m.Ids = vals
			case "alertLevels":
				m.AlertLevels = vals
			case "alertIds":
				list := make([]uint64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseUint(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.AlertIds = list
			case "alertStates":
				m.AlertStates = vals
			case "alertSources":
				m.AlertSources = vals
			case "lastTriggerTimeMsMin":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.LastTriggerTimeMsMin = val
			case "lastTriggerTimeMsMax":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.LastTriggerTimeMsMax = val
			}
		}
	}
	return nil
}

// GetAlertEventResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetAlertEventResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// AlertEventItem implement urlenc.URLValuesUnmarshaler.
func (m *AlertEventItem) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				m.Id = vals[0]
			case "name":
				m.Name = vals[0]
			case "orgID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.OrgID = val
			case "alertGroupID":
				m.AlertGroupID = vals[0]
			case "alertGroup":
				m.AlertGroup = vals[0]
			case "scope":
				m.Scope = vals[0]
			case "scopeId":
				m.ScopeId = vals[0]
			case "alertID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AlertID = val
			case "alertName":
				m.AlertName = vals[0]
			case "alertType":
				m.AlertType = vals[0]
			case "alertIndex":
				m.AlertIndex = vals[0]
			case "alertLevel":
				m.AlertLevel = vals[0]
			case "alertSource":
				m.AlertSource = vals[0]
			case "alertSubject":
				m.AlertSubject = vals[0]
			case "ruleID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.RuleID = val
			case "ruleName":
				m.RuleName = vals[0]
			case "expressionID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ExpressionID = val
			case "lastTriggerTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.LastTriggerTime = val
			case "firstTriggerTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.FirstTriggerTime = val
			case "AlertState":
				m.AlertState = vals[0]
			case "suppressExpireTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.SuppressExpireTime = val
			}
		}
	}
	return nil
}

// QueryCustomizeMetricRequest implement urlenc.URLValuesUnmarshaler.
func (m *QueryCustomizeMetricRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals
			case "scope":
				m.Scope = vals[0]
			case "scopeId":
				m.ScopeId = vals[0]
			}
		}
	}
	return nil
}

// QueryCustomizeMetricResponse implement urlenc.URLValuesUnmarshaler.
func (m *QueryCustomizeMetricResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &CustomizeMetrics{}
				}
			case "data.notifySample":
				if m.Data == nil {
					m.Data = &CustomizeMetrics{}
				}
				m.Data.NotifySample = vals[0]
			}
		}
	}
	return nil
}

// CustomizeMetrics implement urlenc.URLValuesUnmarshaler.
func (m *CustomizeMetrics) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "notifySample":
				m.NotifySample = vals[0]
			}
		}
	}
	return nil
}

// MetricMeta implement urlenc.URLValuesUnmarshaler.
func (m *MetricMeta) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				if m.Name == nil {
					m.Name = &DisplayKey{}
				}
			case "name.key":
				if m.Name == nil {
					m.Name = &DisplayKey{}
				}
				m.Name.Key = vals[0]
			case "name.display":
				if m.Name == nil {
					m.Name = &DisplayKey{}
				}
				m.Name.Display = vals[0]
			}
		}
	}
	return nil
}

// DisplayKey implement urlenc.URLValuesUnmarshaler.
func (m *DisplayKey) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "key":
				m.Key = vals[0]
			case "display":
				m.Display = vals[0]
			}
		}
	}
	return nil
}

// FieldMeta implement urlenc.URLValuesUnmarshaler.
func (m *FieldMeta) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "field":
				if m.Field == nil {
					m.Field = &DisplayKey{}
				}
			case "field.key":
				if m.Field == nil {
					m.Field = &DisplayKey{}
				}
				m.Field.Key = vals[0]
			case "field.display":
				if m.Field == nil {
					m.Field = &DisplayKey{}
				}
				m.Field.Display = vals[0]
			case "dataType":
				m.DataType = vals[0]
			}
		}
	}
	return nil
}

// TagMeta implement urlenc.URLValuesUnmarshaler.
func (m *TagMeta) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "tag":
				if m.Tag == nil {
					m.Tag = &DisplayKey{}
				}
			case "tag.key":
				if m.Tag == nil {
					m.Tag = &DisplayKey{}
				}
				m.Tag.Key = vals[0]
			case "tag.display":
				if m.Tag == nil {
					m.Tag = &DisplayKey{}
				}
				m.Tag.Display = vals[0]
			case "dataType":
				m.DataType = vals[0]
			}
		}
	}
	return nil
}

// Operator implement urlenc.URLValuesUnmarshaler.
func (m *Operator) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "key":
				m.Key = vals[0]
			case "display":
				m.Display = vals[0]
			case "type":
				m.Type = vals[0]
			}
		}
	}
	return nil
}

// QueryCustomizeNotifyTargetRequest implement urlenc.URLValuesUnmarshaler.
func (m *QueryCustomizeNotifyTargetRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// QueryCustomizeNotifyTargetResponse implement urlenc.URLValuesUnmarshaler.
func (m *QueryCustomizeNotifyTargetResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &QueryCustomizeNotifyTargetData{}
				}
			}
		}
	}
	return nil
}

// QueryCustomizeNotifyTargetData implement urlenc.URLValuesUnmarshaler.
func (m *QueryCustomizeNotifyTargetData) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// QueryOrgCustomizeNotifyTargetRequest implement urlenc.URLValuesUnmarshaler.
func (m *QueryOrgCustomizeNotifyTargetRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// QueryOrgCustomizeNotifyTargetResponse implement urlenc.URLValuesUnmarshaler.
func (m *QueryOrgCustomizeNotifyTargetResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &QueryCustomizeNotifyTargetData{}
				}
			}
		}
	}
	return nil
}

// QueryCustomizeAlertRequest implement urlenc.URLValuesUnmarshaler.
func (m *QueryCustomizeAlertRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "scope":
				m.Scope = vals[0]
			case "scopeId":
				m.ScopeId = vals[0]
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			case "name":
				m.Name = vals[0]
			}
		}
	}
	return nil
}

// QueryCustomizeAlertResponse implement urlenc.URLValuesUnmarshaler.
func (m *QueryCustomizeAlertResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &QueryCustomizeAlertData{}
				}
			case "data.total":
				if m.Data == nil {
					m.Data = &QueryCustomizeAlertData{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Total = val
			case "userIDs":
				m.UserIDs = vals
			}
		}
	}
	return nil
}

// QueryCustomizeAlertData implement urlenc.URLValuesUnmarshaler.
func (m *QueryCustomizeAlertData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// CustomizeAlertOverview implement urlenc.URLValuesUnmarshaler.
func (m *CustomizeAlertOverview) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "name":
				m.Name = vals[0]
			case "metric":
				m.Metric = vals[0]
			case "window":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Window = val
			case "notifyTargets":
				m.NotifyTargets = vals
			case "dashboardId":
				m.DashboardId = vals[0]
			case "enable":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Enable = val
			case "createTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreateTime = val
			case "updateTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdateTime = val
			case "creator":
				m.Creator = vals[0]
			}
		}
	}
	return nil
}

// GetCustomizeAlertRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetCustomizeAlertRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			}
		}
	}
	return nil
}

// GetCustomizeAlertResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetCustomizeAlertResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &CustomizeAlertDetail{}
				}
			case "data.id":
				if m.Data == nil {
					m.Data = &CustomizeAlertDetail{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Id = val
			case "data.clusterName":
				if m.Data == nil {
					m.Data = &CustomizeAlertDetail{}
				}
				m.Data.ClusterName = vals[0]
			case "data.name":
				if m.Data == nil {
					m.Data = &CustomizeAlertDetail{}
				}
				m.Data.Name = vals[0]
			case "data.alertType":
				if m.Data == nil {
					m.Data = &CustomizeAlertDetail{}
				}
				m.Data.AlertType = vals[0]
			case "data.alertScope":
				if m.Data == nil {
					m.Data = &CustomizeAlertDetail{}
				}
				m.Data.AlertScope = vals[0]
			case "data.alertScopeId":
				if m.Data == nil {
					m.Data = &CustomizeAlertDetail{}
				}
				m.Data.AlertScopeId = vals[0]
			case "data.enable":
				if m.Data == nil {
					m.Data = &CustomizeAlertDetail{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Enable = val
			case "data.createTime":
				if m.Data == nil {
					m.Data = &CustomizeAlertDetail{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CreateTime = val
			case "data.updateTime":
				if m.Data == nil {
					m.Data = &CustomizeAlertDetail{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.UpdateTime = val
			}
		}
	}
	return nil
}

// CustomizeAlertDetail implement urlenc.URLValuesUnmarshaler.
func (m *CustomizeAlertDetail) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "clusterName":
				m.ClusterName = vals[0]
			case "name":
				m.Name = vals[0]
			case "alertType":
				m.AlertType = vals[0]
			case "alertScope":
				m.AlertScope = vals[0]
			case "alertScopeId":
				m.AlertScopeId = vals[0]
			case "enable":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Enable = val
			case "createTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreateTime = val
			case "updateTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdateTime = val
			}
		}
	}
	return nil
}

// CustomizeAlertRule implement urlenc.URLValuesUnmarshaler.
func (m *CustomizeAlertRule) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "name":
				m.Name = vals[0]
			case "metric":
				m.Metric = vals[0]
			case "window":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Window = val
			case "group":
				m.Group = vals
			case "outputs":
				m.Outputs = vals
			case "activedMetricGroups":
				m.ActivedMetricGroups = vals
			case "createTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreateTime = val
			case "updateTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdateTime = val
			}
		}
	}
	return nil
}

// CustomizeAlertRuleFunction implement urlenc.URLValuesUnmarshaler.
func (m *CustomizeAlertRuleFunction) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "field":
				m.Field = vals[0]
			case "alias":
				m.Alias = vals[0]
			case "aggregator":
				m.Aggregator = vals[0]
			case "operator":
				m.Operator = vals[0]
			case "value":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Value = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Value = val
					} else {
						m.Value = structpb.NewStringValue(vals[0])
					}
				}
			case "dataType":
				m.DataType = vals[0]
			case "unit":
				m.Unit = vals[0]
			}
		}
	}
	return nil
}

// CustomizeAlertRuleFilter implement urlenc.URLValuesUnmarshaler.
func (m *CustomizeAlertRuleFilter) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "tag":
				m.Tag = vals[0]
			case "operator":
				m.Operator = vals[0]
			case "value":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Value = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Value = val
					} else {
						m.Value = structpb.NewStringValue(vals[0])
					}
				}
			case "dataType":
				m.DataType = vals[0]
			}
		}
	}
	return nil
}

// CustomizeAlertNotifyTemplates implement urlenc.URLValuesUnmarshaler.
func (m *CustomizeAlertNotifyTemplates) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "name":
				m.Name = vals[0]
			case "targets":
				m.Targets = vals
			case "title":
				m.Title = vals[0]
			case "content":
				m.Content = vals[0]
			case "createTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreateTime = val
			case "updateTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdateTime = val
			}
		}
	}
	return nil
}

// GetCustomizeAlertDetailRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetCustomizeAlertDetailRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			}
		}
	}
	return nil
}

// GetCustomizeAlertDetailResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetCustomizeAlertDetailResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &CustomizeAlertDetail{}
				}
			case "data.id":
				if m.Data == nil {
					m.Data = &CustomizeAlertDetail{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Id = val
			case "data.clusterName":
				if m.Data == nil {
					m.Data = &CustomizeAlertDetail{}
				}
				m.Data.ClusterName = vals[0]
			case "data.name":
				if m.Data == nil {
					m.Data = &CustomizeAlertDetail{}
				}
				m.Data.Name = vals[0]
			case "data.alertType":
				if m.Data == nil {
					m.Data = &CustomizeAlertDetail{}
				}
				m.Data.AlertType = vals[0]
			case "data.alertScope":
				if m.Data == nil {
					m.Data = &CustomizeAlertDetail{}
				}
				m.Data.AlertScope = vals[0]
			case "data.alertScopeId":
				if m.Data == nil {
					m.Data = &CustomizeAlertDetail{}
				}
				m.Data.AlertScopeId = vals[0]
			case "data.enable":
				if m.Data == nil {
					m.Data = &CustomizeAlertDetail{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Enable = val
			case "data.createTime":
				if m.Data == nil {
					m.Data = &CustomizeAlertDetail{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CreateTime = val
			case "data.updateTime":
				if m.Data == nil {
					m.Data = &CustomizeAlertDetail{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.UpdateTime = val
			}
		}
	}
	return nil
}

// CreateCustomizeAlertRequest implement urlenc.URLValuesUnmarshaler.
func (m *CreateCustomizeAlertRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "clusterName":
				m.ClusterName = vals[0]
			case "name":
				m.Name = vals[0]
			case "alertType":
				m.AlertType = vals[0]
			case "alertScope":
				m.AlertScope = vals[0]
			case "alertScopeId":
				m.AlertScopeId = vals[0]
			case "enable":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Enable = val
			case "createTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreateTime = val
			case "updateTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdateTime = val
			}
		}
	}
	return nil
}

// CreateCustomizeAlertResponse implement urlenc.URLValuesUnmarshaler.
func (m *CreateCustomizeAlertResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// UpdateCustomizeAlertRequest implement urlenc.URLValuesUnmarshaler.
func (m *UpdateCustomizeAlertRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "clusterName":
				m.ClusterName = vals[0]
			case "name":
				m.Name = vals[0]
			case "alertType":
				m.AlertType = vals[0]
			case "alertScope":
				m.AlertScope = vals[0]
			case "alertScopeId":
				m.AlertScopeId = vals[0]
			case "enable":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Enable = val
			case "createTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreateTime = val
			case "updateTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdateTime = val
			}
		}
	}
	return nil
}

// UpdateCustomizeAlertResponse implement urlenc.URLValuesUnmarshaler.
func (m *UpdateCustomizeAlertResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// UpdateCustomizeAlertEnableRequest implement urlenc.URLValuesUnmarshaler.
func (m *UpdateCustomizeAlertEnableRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "enable":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Enable = val
			}
		}
	}
	return nil
}

// UpdateCustomizeAlertEnableResponse implement urlenc.URLValuesUnmarshaler.
func (m *UpdateCustomizeAlertEnableResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// DeleteCustomizeAlertRequest implement urlenc.URLValuesUnmarshaler.
func (m *DeleteCustomizeAlertRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			}
		}
	}
	return nil
}

// DeleteCustomizeAlertResponse implement urlenc.URLValuesUnmarshaler.
func (m *DeleteCustomizeAlertResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				m.Data = vals[0]
			}
		}
	}
	return nil
}

// QueryOrgCustomizeMetricRequest implement urlenc.URLValuesUnmarshaler.
func (m *QueryOrgCustomizeMetricRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// QueryOrgCustomizeMetricResponse implement urlenc.URLValuesUnmarshaler.
func (m *QueryOrgCustomizeMetricResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &CustomizeMetrics{}
				}
			case "data.notifySample":
				if m.Data == nil {
					m.Data = &CustomizeMetrics{}
				}
				m.Data.NotifySample = vals[0]
			}
		}
	}
	return nil
}

// QueryOrgCustomizeAlertsRequest implement urlenc.URLValuesUnmarshaler.
func (m *QueryOrgCustomizeAlertsRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			case "name":
				m.Name = vals[0]
			}
		}
	}
	return nil
}

// QueryOrgCustomizeAlertsResponse implement urlenc.URLValuesUnmarshaler.
func (m *QueryOrgCustomizeAlertsResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &QueryOrgCustomizeAlertsData{}
				}
			case "data.total":
				if m.Data == nil {
					m.Data = &QueryOrgCustomizeAlertsData{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Total = val
			case "userIDs":
				m.UserIDs = vals
			}
		}
	}
	return nil
}

// QueryOrgCustomizeAlertsData implement urlenc.URLValuesUnmarshaler.
func (m *QueryOrgCustomizeAlertsData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// GetOrgCustomizeAlertDetailRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetOrgCustomizeAlertDetailRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			}
		}
	}
	return nil
}

// GetOrgCustomizeAlertDetailResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetOrgCustomizeAlertDetailResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &CustomizeAlertDetail{}
				}
			case "data.id":
				if m.Data == nil {
					m.Data = &CustomizeAlertDetail{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Id = val
			case "data.clusterName":
				if m.Data == nil {
					m.Data = &CustomizeAlertDetail{}
				}
				m.Data.ClusterName = vals[0]
			case "data.name":
				if m.Data == nil {
					m.Data = &CustomizeAlertDetail{}
				}
				m.Data.Name = vals[0]
			case "data.alertType":
				if m.Data == nil {
					m.Data = &CustomizeAlertDetail{}
				}
				m.Data.AlertType = vals[0]
			case "data.alertScope":
				if m.Data == nil {
					m.Data = &CustomizeAlertDetail{}
				}
				m.Data.AlertScope = vals[0]
			case "data.alertScopeId":
				if m.Data == nil {
					m.Data = &CustomizeAlertDetail{}
				}
				m.Data.AlertScopeId = vals[0]
			case "data.enable":
				if m.Data == nil {
					m.Data = &CustomizeAlertDetail{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Enable = val
			case "data.createTime":
				if m.Data == nil {
					m.Data = &CustomizeAlertDetail{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CreateTime = val
			case "data.updateTime":
				if m.Data == nil {
					m.Data = &CustomizeAlertDetail{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.UpdateTime = val
			}
		}
	}
	return nil
}

// CreateOrgCustomizeAlertRequest implement urlenc.URLValuesUnmarshaler.
func (m *CreateOrgCustomizeAlertRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "clusterName":
				m.ClusterName = vals[0]
			case "name":
				m.Name = vals[0]
			case "alertType":
				m.AlertType = vals[0]
			case "alertScope":
				m.AlertScope = vals[0]
			case "alertScopeId":
				m.AlertScopeId = vals[0]
			case "enable":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Enable = val
			case "createTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreateTime = val
			case "updateTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdateTime = val
			}
		}
	}
	return nil
}

// CreateOrgCustomizeAlertResponse implement urlenc.URLValuesUnmarshaler.
func (m *CreateOrgCustomizeAlertResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			}
		}
	}
	return nil
}

// UpdateOrgCustomizeAlertRequest implement urlenc.URLValuesUnmarshaler.
func (m *UpdateOrgCustomizeAlertRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "clusterName":
				m.ClusterName = vals[0]
			case "name":
				m.Name = vals[0]
			case "alertType":
				m.AlertType = vals[0]
			case "alertScope":
				m.AlertScope = vals[0]
			case "alertScopeId":
				m.AlertScopeId = vals[0]
			case "enable":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Enable = val
			case "createTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreateTime = val
			case "updateTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdateTime = val
			}
		}
	}
	return nil
}

// UpdateOrgCustomizeAlertResponse implement urlenc.URLValuesUnmarshaler.
func (m *UpdateOrgCustomizeAlertResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// UpdateOrgCustomizeAlertEnableRequest implement urlenc.URLValuesUnmarshaler.
func (m *UpdateOrgCustomizeAlertEnableRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "enable":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Enable = val
			}
		}
	}
	return nil
}

// UpdateOrgCustomizeAlertEnableResponse implement urlenc.URLValuesUnmarshaler.
func (m *UpdateOrgCustomizeAlertEnableResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// DeleteOrgCustomizeAlertRequest implement urlenc.URLValuesUnmarshaler.
func (m *DeleteOrgCustomizeAlertRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			}
		}
	}
	return nil
}

// DeleteOrgCustomizeAlertResponse implement urlenc.URLValuesUnmarshaler.
func (m *DeleteOrgCustomizeAlertResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data = val
					} else {
						m.Data = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// QueryDashboardByAlertRequest implement urlenc.URLValuesUnmarshaler.
func (m *QueryDashboardByAlertRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "clusterName":
				m.ClusterName = vals[0]
			case "name":
				m.Name = vals[0]
			case "alertType":
				m.AlertType = vals[0]
			case "alertScope":
				m.AlertScope = vals[0]
			case "alertScopeId":
				m.AlertScopeId = vals[0]
			case "enable":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Enable = val
			case "createTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreateTime = val
			case "updateTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdateTime = val
			}
		}
	}
	return nil
}

// QueryDashboardByAlertResponse implement urlenc.URLValuesUnmarshaler.
func (m *QueryDashboardByAlertResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &View{}
				}
			case "data.title":
				if m.Data == nil {
					m.Data = &View{}
				}
				m.Data.Title = vals[0]
			case "data.description":
				if m.Data == nil {
					m.Data = &View{}
				}
				m.Data.Description = vals[0]
			case "data.chartType":
				if m.Data == nil {
					m.Data = &View{}
				}
				m.Data.ChartType = vals[0]
			case "data.dataSourceType":
				if m.Data == nil {
					m.Data = &View{}
				}
				m.Data.DataSourceType = vals[0]
			case "data.staticData":
				if m.Data == nil {
					m.Data = &View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.StaticData = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.StaticData = val
					} else {
						m.Data.StaticData = structpb.NewStringValue(vals[0])
					}
				}
			case "data.staticData.null_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.StaticData = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.StaticData = val
					} else {
						m.Data.StaticData = structpb.NewStringValue(vals[0])
					}
				}
			case "data.staticData.number_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.StaticData = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.StaticData = val
					} else {
						m.Data.StaticData = structpb.NewStringValue(vals[0])
					}
				}
			case "data.staticData.string_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.StaticData = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.StaticData = val
					} else {
						m.Data.StaticData = structpb.NewStringValue(vals[0])
					}
				}
			case "data.staticData.bool_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.StaticData = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.StaticData = val
					} else {
						m.Data.StaticData = structpb.NewStringValue(vals[0])
					}
				}
			case "data.staticData.struct_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.StaticData = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.StaticData = val
					} else {
						m.Data.StaticData = structpb.NewStringValue(vals[0])
					}
				}
			case "data.staticData.list_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.StaticData = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.StaticData = val
					} else {
						m.Data.StaticData = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config":
				if m.Data == nil {
					m.Data = &View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &Config{}
				}
			case "data.config.dataSourceConfig":
				if m.Data == nil {
					m.Data = &View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.DataSourceConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.DataSourceConfig = val
					} else {
						m.Data.Config.DataSourceConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.dataSourceConfig.null_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.DataSourceConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.DataSourceConfig = val
					} else {
						m.Data.Config.DataSourceConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.dataSourceConfig.number_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.DataSourceConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.DataSourceConfig = val
					} else {
						m.Data.Config.DataSourceConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.dataSourceConfig.string_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.DataSourceConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.DataSourceConfig = val
					} else {
						m.Data.Config.DataSourceConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.dataSourceConfig.bool_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.DataSourceConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.DataSourceConfig = val
					} else {
						m.Data.Config.DataSourceConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.dataSourceConfig.struct_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.DataSourceConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.DataSourceConfig = val
					} else {
						m.Data.Config.DataSourceConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.dataSourceConfig.list_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.DataSourceConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.DataSourceConfig = val
					} else {
						m.Data.Config.DataSourceConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.option":
				if m.Data == nil {
					m.Data = &View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.Option = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.Option = val
					} else {
						m.Data.Config.Option = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.option.null_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.Option = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.Option = val
					} else {
						m.Data.Config.Option = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.option.number_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.Option = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.Option = val
					} else {
						m.Data.Config.Option = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.option.string_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.Option = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.Option = val
					} else {
						m.Data.Config.Option = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.option.bool_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.Option = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.Option = val
					} else {
						m.Data.Config.Option = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.option.struct_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.Option = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.Option = val
					} else {
						m.Data.Config.Option = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.option.list_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.Option = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.Option = val
					} else {
						m.Data.Config.Option = structpb.NewStringValue(vals[0])
					}
				}
			case "data.api":
				if m.Data == nil {
					m.Data = &View{}
				}
				if m.Data.Api == nil {
					m.Data.Api = &API{}
				}
			case "data.api.url":
				if m.Data == nil {
					m.Data = &View{}
				}
				if m.Data.Api == nil {
					m.Data.Api = &API{}
				}
				m.Data.Api.Url = vals[0]
			case "data.api.method":
				if m.Data == nil {
					m.Data = &View{}
				}
				if m.Data.Api == nil {
					m.Data.Api = &API{}
				}
				m.Data.Api.Method = vals[0]
			case "data.controls":
				if m.Data == nil {
					m.Data = &View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Controls = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Controls = val
					} else {
						m.Data.Controls = structpb.NewStringValue(vals[0])
					}
				}
			case "data.controls.null_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Controls = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Controls = val
					} else {
						m.Data.Controls = structpb.NewStringValue(vals[0])
					}
				}
			case "data.controls.number_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Controls = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Controls = val
					} else {
						m.Data.Controls = structpb.NewStringValue(vals[0])
					}
				}
			case "data.controls.string_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Controls = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Controls = val
					} else {
						m.Data.Controls = structpb.NewStringValue(vals[0])
					}
				}
			case "data.controls.bool_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Controls = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Controls = val
					} else {
						m.Data.Controls = structpb.NewStringValue(vals[0])
					}
				}
			case "data.controls.struct_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Controls = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Controls = val
					} else {
						m.Data.Controls = structpb.NewStringValue(vals[0])
					}
				}
			case "data.controls.list_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Controls = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Controls = val
					} else {
						m.Data.Controls = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// View implement urlenc.URLValuesUnmarshaler.
func (m *View) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "title":
				m.Title = vals[0]
			case "description":
				m.Description = vals[0]
			case "chartType":
				m.ChartType = vals[0]
			case "dataSourceType":
				m.DataSourceType = vals[0]
			case "staticData":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.StaticData = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.StaticData = val
					} else {
						m.StaticData = structpb.NewStringValue(vals[0])
					}
				}
			case "config":
				if m.Config == nil {
					m.Config = &Config{}
				}
			case "config.dataSourceConfig":
				if m.Config == nil {
					m.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Config.DataSourceConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Config.DataSourceConfig = val
					} else {
						m.Config.DataSourceConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "config.dataSourceConfig.null_value":
				if m.Config == nil {
					m.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Config.DataSourceConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Config.DataSourceConfig = val
					} else {
						m.Config.DataSourceConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "config.dataSourceConfig.number_value":
				if m.Config == nil {
					m.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Config.DataSourceConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Config.DataSourceConfig = val
					} else {
						m.Config.DataSourceConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "config.dataSourceConfig.string_value":
				if m.Config == nil {
					m.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Config.DataSourceConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Config.DataSourceConfig = val
					} else {
						m.Config.DataSourceConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "config.dataSourceConfig.bool_value":
				if m.Config == nil {
					m.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Config.DataSourceConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Config.DataSourceConfig = val
					} else {
						m.Config.DataSourceConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "config.dataSourceConfig.struct_value":
				if m.Config == nil {
					m.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Config.DataSourceConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Config.DataSourceConfig = val
					} else {
						m.Config.DataSourceConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "config.dataSourceConfig.list_value":
				if m.Config == nil {
					m.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Config.DataSourceConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Config.DataSourceConfig = val
					} else {
						m.Config.DataSourceConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "config.option":
				if m.Config == nil {
					m.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Config.Option = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Config.Option = val
					} else {
						m.Config.Option = structpb.NewStringValue(vals[0])
					}
				}
			case "config.option.null_value":
				if m.Config == nil {
					m.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Config.Option = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Config.Option = val
					} else {
						m.Config.Option = structpb.NewStringValue(vals[0])
					}
				}
			case "config.option.number_value":
				if m.Config == nil {
					m.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Config.Option = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Config.Option = val
					} else {
						m.Config.Option = structpb.NewStringValue(vals[0])
					}
				}
			case "config.option.string_value":
				if m.Config == nil {
					m.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Config.Option = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Config.Option = val
					} else {
						m.Config.Option = structpb.NewStringValue(vals[0])
					}
				}
			case "config.option.bool_value":
				if m.Config == nil {
					m.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Config.Option = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Config.Option = val
					} else {
						m.Config.Option = structpb.NewStringValue(vals[0])
					}
				}
			case "config.option.struct_value":
				if m.Config == nil {
					m.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Config.Option = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Config.Option = val
					} else {
						m.Config.Option = structpb.NewStringValue(vals[0])
					}
				}
			case "config.option.list_value":
				if m.Config == nil {
					m.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Config.Option = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Config.Option = val
					} else {
						m.Config.Option = structpb.NewStringValue(vals[0])
					}
				}
			case "api":
				if m.Api == nil {
					m.Api = &API{}
				}
			case "api.url":
				if m.Api == nil {
					m.Api = &API{}
				}
				m.Api.Url = vals[0]
			case "api.method":
				if m.Api == nil {
					m.Api = &API{}
				}
				m.Api.Method = vals[0]
			case "controls":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Controls = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Controls = val
					} else {
						m.Controls = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// Config implement urlenc.URLValuesUnmarshaler.
func (m *Config) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "dataSourceConfig":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.DataSourceConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.DataSourceConfig = val
					} else {
						m.DataSourceConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "option":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Option = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Option = val
					} else {
						m.Option = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// API implement urlenc.URLValuesUnmarshaler.
func (m *API) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "url":
				m.Url = vals[0]
			case "method":
				m.Method = vals[0]
			}
		}
	}
	return nil
}

// QueryOrgDashboardByAlertRequest implement urlenc.URLValuesUnmarshaler.
func (m *QueryOrgDashboardByAlertRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "clusterName":
				m.ClusterName = vals[0]
			case "name":
				m.Name = vals[0]
			case "alertType":
				m.AlertType = vals[0]
			case "alertScope":
				m.AlertScope = vals[0]
			case "alertScopeId":
				m.AlertScopeId = vals[0]
			case "enable":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Enable = val
			case "createTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreateTime = val
			case "updateTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdateTime = val
			}
		}
	}
	return nil
}

// QueryOrgDashboardByAlertResponse implement urlenc.URLValuesUnmarshaler.
func (m *QueryOrgDashboardByAlertResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &View{}
				}
			case "data.title":
				if m.Data == nil {
					m.Data = &View{}
				}
				m.Data.Title = vals[0]
			case "data.description":
				if m.Data == nil {
					m.Data = &View{}
				}
				m.Data.Description = vals[0]
			case "data.chartType":
				if m.Data == nil {
					m.Data = &View{}
				}
				m.Data.ChartType = vals[0]
			case "data.dataSourceType":
				if m.Data == nil {
					m.Data = &View{}
				}
				m.Data.DataSourceType = vals[0]
			case "data.staticData":
				if m.Data == nil {
					m.Data = &View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.StaticData = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.StaticData = val
					} else {
						m.Data.StaticData = structpb.NewStringValue(vals[0])
					}
				}
			case "data.staticData.null_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.StaticData = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.StaticData = val
					} else {
						m.Data.StaticData = structpb.NewStringValue(vals[0])
					}
				}
			case "data.staticData.number_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.StaticData = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.StaticData = val
					} else {
						m.Data.StaticData = structpb.NewStringValue(vals[0])
					}
				}
			case "data.staticData.string_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.StaticData = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.StaticData = val
					} else {
						m.Data.StaticData = structpb.NewStringValue(vals[0])
					}
				}
			case "data.staticData.bool_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.StaticData = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.StaticData = val
					} else {
						m.Data.StaticData = structpb.NewStringValue(vals[0])
					}
				}
			case "data.staticData.struct_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.StaticData = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.StaticData = val
					} else {
						m.Data.StaticData = structpb.NewStringValue(vals[0])
					}
				}
			case "data.staticData.list_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.StaticData = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.StaticData = val
					} else {
						m.Data.StaticData = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config":
				if m.Data == nil {
					m.Data = &View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &Config{}
				}
			case "data.config.dataSourceConfig":
				if m.Data == nil {
					m.Data = &View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.DataSourceConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.DataSourceConfig = val
					} else {
						m.Data.Config.DataSourceConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.dataSourceConfig.null_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.DataSourceConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.DataSourceConfig = val
					} else {
						m.Data.Config.DataSourceConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.dataSourceConfig.number_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.DataSourceConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.DataSourceConfig = val
					} else {
						m.Data.Config.DataSourceConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.dataSourceConfig.string_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.DataSourceConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.DataSourceConfig = val
					} else {
						m.Data.Config.DataSourceConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.dataSourceConfig.bool_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.DataSourceConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.DataSourceConfig = val
					} else {
						m.Data.Config.DataSourceConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.dataSourceConfig.struct_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.DataSourceConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.DataSourceConfig = val
					} else {
						m.Data.Config.DataSourceConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.dataSourceConfig.list_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.DataSourceConfig = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.DataSourceConfig = val
					} else {
						m.Data.Config.DataSourceConfig = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.option":
				if m.Data == nil {
					m.Data = &View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.Option = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.Option = val
					} else {
						m.Data.Config.Option = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.option.null_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.Option = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.Option = val
					} else {
						m.Data.Config.Option = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.option.number_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.Option = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.Option = val
					} else {
						m.Data.Config.Option = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.option.string_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.Option = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.Option = val
					} else {
						m.Data.Config.Option = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.option.bool_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.Option = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.Option = val
					} else {
						m.Data.Config.Option = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.option.struct_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.Option = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.Option = val
					} else {
						m.Data.Config.Option = structpb.NewStringValue(vals[0])
					}
				}
			case "data.config.option.list_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if m.Data.Config == nil {
					m.Data.Config = &Config{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Config.Option = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Config.Option = val
					} else {
						m.Data.Config.Option = structpb.NewStringValue(vals[0])
					}
				}
			case "data.api":
				if m.Data == nil {
					m.Data = &View{}
				}
				if m.Data.Api == nil {
					m.Data.Api = &API{}
				}
			case "data.api.url":
				if m.Data == nil {
					m.Data = &View{}
				}
				if m.Data.Api == nil {
					m.Data.Api = &API{}
				}
				m.Data.Api.Url = vals[0]
			case "data.api.method":
				if m.Data == nil {
					m.Data = &View{}
				}
				if m.Data.Api == nil {
					m.Data.Api = &API{}
				}
				m.Data.Api.Method = vals[0]
			case "data.controls":
				if m.Data == nil {
					m.Data = &View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Controls = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Controls = val
					} else {
						m.Data.Controls = structpb.NewStringValue(vals[0])
					}
				}
			case "data.controls.null_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Controls = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Controls = val
					} else {
						m.Data.Controls = structpb.NewStringValue(vals[0])
					}
				}
			case "data.controls.number_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Controls = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Controls = val
					} else {
						m.Data.Controls = structpb.NewStringValue(vals[0])
					}
				}
			case "data.controls.string_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Controls = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Controls = val
					} else {
						m.Data.Controls = structpb.NewStringValue(vals[0])
					}
				}
			case "data.controls.bool_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Controls = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Controls = val
					} else {
						m.Data.Controls = structpb.NewStringValue(vals[0])
					}
				}
			case "data.controls.struct_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Controls = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Controls = val
					} else {
						m.Data.Controls = structpb.NewStringValue(vals[0])
					}
				}
			case "data.controls.list_value":
				if m.Data == nil {
					m.Data = &View{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Controls = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Controls = val
					} else {
						m.Data.Controls = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// QueryAlertRuleRequest implement urlenc.URLValuesUnmarshaler.
func (m *QueryAlertRuleRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "scope":
				m.Scope = vals[0]
			case "scopeId":
				m.ScopeId = vals[0]
			}
		}
	}
	return nil
}

// QueryAlertRuleResponse implement urlenc.URLValuesUnmarshaler.
func (m *QueryAlertRuleResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &AlertTypeRuleResp{}
				}
			case "data.windows":
				if m.Data == nil {
					m.Data = &AlertTypeRuleResp{}
				}
				list := make([]int64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseInt(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.Data.Windows = list
			}
		}
	}
	return nil
}

// AlertTypeRuleResp implement urlenc.URLValuesUnmarshaler.
func (m *AlertTypeRuleResp) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "windows":
				list := make([]int64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseInt(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.Windows = list
			}
		}
	}
	return nil
}

// AlertTypeRule implement urlenc.URLValuesUnmarshaler.
func (m *AlertTypeRule) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "alertType":
				if m.AlertType == nil {
					m.AlertType = &DisplayKey{}
				}
			case "alertType.key":
				if m.AlertType == nil {
					m.AlertType = &DisplayKey{}
				}
				m.AlertType.Key = vals[0]
			case "alertType.display":
				if m.AlertType == nil {
					m.AlertType = &DisplayKey{}
				}
				m.AlertType.Display = vals[0]
			}
		}
	}
	return nil
}

// AlertRule implement urlenc.URLValuesUnmarshaler.
func (m *AlertRule) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "name":
				m.Name = vals[0]
			case "alertScope":
				m.AlertScope = vals[0]
			case "alertType":
				m.AlertType = vals[0]
			case "alertIndex":
				if m.AlertIndex == nil {
					m.AlertIndex = &DisplayKey{}
				}
			case "alertIndex.key":
				if m.AlertIndex == nil {
					m.AlertIndex = &DisplayKey{}
				}
				m.AlertIndex.Key = vals[0]
			case "alertIndex.display":
				if m.AlertIndex == nil {
					m.AlertIndex = &DisplayKey{}
				}
				m.AlertIndex.Display = vals[0]
			case "window":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Window = val
			case "isRecover":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsRecover = val
			case "version":
				m.Version = vals[0]
			case "enable":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Enable = val
			case "createTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreateTime = val
			case "updateTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdateTime = val
			}
		}
	}
	return nil
}

// AlertRuleFunction implement urlenc.URLValuesUnmarshaler.
func (m *AlertRuleFunction) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "field":
				if m.Field == nil {
					m.Field = &DisplayKey{}
				}
			case "field.key":
				if m.Field == nil {
					m.Field = &DisplayKey{}
				}
				m.Field.Key = vals[0]
			case "field.display":
				if m.Field == nil {
					m.Field = &DisplayKey{}
				}
				m.Field.Display = vals[0]
			case "aggregator":
				m.Aggregator = vals[0]
			case "operator":
				m.Operator = vals[0]
			case "value":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Value = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Value = val
					} else {
						m.Value = structpb.NewStringValue(vals[0])
					}
				}
			case "dataType":
				m.DataType = vals[0]
			case "unit":
				m.Unit = vals[0]
			}
		}
	}
	return nil
}

// NotifySilence implement urlenc.URLValuesUnmarshaler.
func (m *NotifySilence) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "value":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Value = val
			case "unit":
				if m.Unit == nil {
					m.Unit = &DisplayKey{}
				}
			case "unit.key":
				if m.Unit == nil {
					m.Unit = &DisplayKey{}
				}
				m.Unit.Key = vals[0]
			case "unit.display":
				if m.Unit == nil {
					m.Unit = &DisplayKey{}
				}
				m.Unit.Display = vals[0]
			}
		}
	}
	return nil
}

// QueryAlertRequest implement urlenc.URLValuesUnmarshaler.
func (m *QueryAlertRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "scope":
				m.Scope = vals[0]
			case "scopeId":
				m.ScopeId = vals[0]
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			case "name":
				m.Name = vals[0]
			}
		}
	}
	return nil
}

// QueryAlertsResponse implement urlenc.URLValuesUnmarshaler.
func (m *QueryAlertsResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &QueryAlertsData{}
				}
			case "data.total":
				if m.Data == nil {
					m.Data = &QueryAlertsData{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Total = val
			case "userIDs":
				m.UserIDs = vals
			}
		}
	}
	return nil
}

// QueryAlertsData implement urlenc.URLValuesUnmarshaler.
func (m *QueryAlertsData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// Alert implement urlenc.URLValuesUnmarshaler.
func (m *Alert) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "name":
				m.Name = vals[0]
			case "alertScope":
				m.AlertScope = vals[0]
			case "alertScopeId":
				m.AlertScopeId = vals[0]
			case "enable":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Enable = val
			case "clusterNames":
				m.ClusterNames = vals
			case "domain":
				m.Domain = vals[0]
			case "createTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreateTime = val
			case "updateTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdateTime = val
			case "creator":
				m.Creator = vals[0]
			case "ruleCount":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.RuleCount = val
			}
		}
	}
	return nil
}

// AlertExpression implement urlenc.URLValuesUnmarshaler.
func (m *AlertExpression) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "ruleId":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.RuleId = val
			case "alertIndex":
				m.AlertIndex = vals[0]
			case "window":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Window = val
			case "isRecover":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsRecover = val
			case "createTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreateTime = val
			case "updateTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdateTime = val
			case "level":
				m.Level = vals[0]
			}
		}
	}
	return nil
}

// AlertExpressionFunction implement urlenc.URLValuesUnmarshaler.
func (m *AlertExpressionFunction) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "field":
				m.Field = vals[0]
			case "aggregator":
				m.Aggregator = vals[0]
			case "operator":
				m.Operator = vals[0]
			case "value":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Value = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Value = val
					} else {
						m.Value = structpb.NewStringValue(vals[0])
					}
				}
			}
		}
	}
	return nil
}

// AlertNotify implement urlenc.URLValuesUnmarshaler.
func (m *AlertNotify) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "type":
				m.Type = vals[0]
			case "groupId":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.GroupId = val
			case "groupType":
				m.GroupType = vals[0]
			case "notifyGroup":
				if m.NotifyGroup == nil {
					m.NotifyGroup = &NotifyGroup{}
				}
			case "notifyGroup.id":
				if m.NotifyGroup == nil {
					m.NotifyGroup = &NotifyGroup{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.NotifyGroup.Id = val
			case "notifyGroup.name":
				if m.NotifyGroup == nil {
					m.NotifyGroup = &NotifyGroup{}
				}
				m.NotifyGroup.Name = vals[0]
			case "notifyGroup.scopeType":
				if m.NotifyGroup == nil {
					m.NotifyGroup = &NotifyGroup{}
				}
				m.NotifyGroup.ScopeType = vals[0]
			case "notifyGroup.scopeId":
				if m.NotifyGroup == nil {
					m.NotifyGroup = &NotifyGroup{}
				}
				m.NotifyGroup.ScopeId = vals[0]
			case "notifyGroup.createdAt":
				if m.NotifyGroup == nil {
					m.NotifyGroup = &NotifyGroup{}
				}
				if m.NotifyGroup.CreatedAt == nil {
					m.NotifyGroup.CreatedAt = &timestamppb.Timestamp{}
				}
			case "notifyGroup.createdAt.seconds":
				if m.NotifyGroup == nil {
					m.NotifyGroup = &NotifyGroup{}
				}
				if m.NotifyGroup.CreatedAt == nil {
					m.NotifyGroup.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.NotifyGroup.CreatedAt.Seconds = val
			case "notifyGroup.createdAt.nanos":
				if m.NotifyGroup == nil {
					m.NotifyGroup = &NotifyGroup{}
				}
				if m.NotifyGroup.CreatedAt == nil {
					m.NotifyGroup.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.NotifyGroup.CreatedAt.Nanos = int32(val)
			case "notifyGroup.creator":
				if m.NotifyGroup == nil {
					m.NotifyGroup = &NotifyGroup{}
				}
				m.NotifyGroup.Creator = vals[0]
			case "dingdingUrl":
				m.DingdingUrl = vals[0]
			case "silence":
				if m.Silence == nil {
					m.Silence = &AlertNotifySilence{}
				}
			case "silence.value":
				if m.Silence == nil {
					m.Silence = &AlertNotifySilence{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Silence.Value = val
			case "silence.unit":
				if m.Silence == nil {
					m.Silence = &AlertNotifySilence{}
				}
				m.Silence.Unit = vals[0]
			case "silence.policy":
				if m.Silence == nil {
					m.Silence = &AlertNotifySilence{}
				}
				m.Silence.Policy = vals[0]
			case "createTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreateTime = val
			case "updateTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdateTime = val
			case "level":
				m.Level = vals[0]
			}
		}
	}
	return nil
}

// NotifyGroup implement urlenc.URLValuesUnmarshaler.
func (m *NotifyGroup) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "name":
				m.Name = vals[0]
			case "scopeType":
				m.ScopeType = vals[0]
			case "scopeId":
				m.ScopeId = vals[0]
			case "createdAt":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
			case "createdAt.seconds":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt.Seconds = val
			case "createdAt.nanos":
				if m.CreatedAt == nil {
					m.CreatedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.CreatedAt.Nanos = int32(val)
			case "creator":
				m.Creator = vals[0]
			}
		}
	}
	return nil
}

// NotifyTarget implement urlenc.URLValuesUnmarshaler.
func (m *NotifyTarget) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "type":
				m.Type = vals[0]
			}
		}
	}
	return nil
}

// Target implement urlenc.URLValuesUnmarshaler.
func (m *Target) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "receiver":
				m.Receiver = vals[0]
			case "secret":
				m.Secret = vals[0]
			}
		}
	}
	return nil
}

// AlertNotifySilence implement urlenc.URLValuesUnmarshaler.
func (m *AlertNotifySilence) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "value":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Value = val
			case "unit":
				m.Unit = vals[0]
			case "policy":
				m.Policy = vals[0]
			}
		}
	}
	return nil
}

// GetAlertRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetAlertRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			}
		}
	}
	return nil
}

// GetAlertResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetAlertResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &Alert{}
				}
			case "data.id":
				if m.Data == nil {
					m.Data = &Alert{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Id = val
			case "data.name":
				if m.Data == nil {
					m.Data = &Alert{}
				}
				m.Data.Name = vals[0]
			case "data.alertScope":
				if m.Data == nil {
					m.Data = &Alert{}
				}
				m.Data.AlertScope = vals[0]
			case "data.alertScopeId":
				if m.Data == nil {
					m.Data = &Alert{}
				}
				m.Data.AlertScopeId = vals[0]
			case "data.enable":
				if m.Data == nil {
					m.Data = &Alert{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Enable = val
			case "data.clusterNames":
				if m.Data == nil {
					m.Data = &Alert{}
				}
				m.Data.ClusterNames = vals
			case "data.domain":
				if m.Data == nil {
					m.Data = &Alert{}
				}
				m.Data.Domain = vals[0]
			case "data.createTime":
				if m.Data == nil {
					m.Data = &Alert{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CreateTime = val
			case "data.updateTime":
				if m.Data == nil {
					m.Data = &Alert{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.UpdateTime = val
			case "data.creator":
				if m.Data == nil {
					m.Data = &Alert{}
				}
				m.Data.Creator = vals[0]
			case "data.ruleCount":
				if m.Data == nil {
					m.Data = &Alert{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.RuleCount = val
			}
		}
	}
	return nil
}

// GetAlertDetailRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetAlertDetailRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			}
		}
	}
	return nil
}

// GetAlertDetailResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetAlertDetailResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &Alert{}
				}
			case "data.id":
				if m.Data == nil {
					m.Data = &Alert{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Id = val
			case "data.name":
				if m.Data == nil {
					m.Data = &Alert{}
				}
				m.Data.Name = vals[0]
			case "data.alertScope":
				if m.Data == nil {
					m.Data = &Alert{}
				}
				m.Data.AlertScope = vals[0]
			case "data.alertScopeId":
				if m.Data == nil {
					m.Data = &Alert{}
				}
				m.Data.AlertScopeId = vals[0]
			case "data.enable":
				if m.Data == nil {
					m.Data = &Alert{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Enable = val
			case "data.clusterNames":
				if m.Data == nil {
					m.Data = &Alert{}
				}
				m.Data.ClusterNames = vals
			case "data.domain":
				if m.Data == nil {
					m.Data = &Alert{}
				}
				m.Data.Domain = vals[0]
			case "data.createTime":
				if m.Data == nil {
					m.Data = &Alert{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CreateTime = val
			case "data.updateTime":
				if m.Data == nil {
					m.Data = &Alert{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.UpdateTime = val
			case "data.creator":
				if m.Data == nil {
					m.Data = &Alert{}
				}
				m.Data.Creator = vals[0]
			case "data.ruleCount":
				if m.Data == nil {
					m.Data = &Alert{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.RuleCount = val
			}
		}
	}
	return nil
}

// CreateAlertRequest implement urlenc.URLValuesUnmarshaler.
func (m *CreateAlertRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "name":
				m.Name = vals[0]
			case "alertScope":
				m.AlertScope = vals[0]
			case "alertScopeId":
				m.AlertScopeId = vals[0]
			case "enable":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Enable = val
			case "clusterNames":
				m.ClusterNames = vals
			case "domain":
				m.Domain = vals[0]
			case "createTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreateTime = val
			case "updateTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdateTime = val
			}
		}
	}
	return nil
}

// CreateAlertResponse implement urlenc.URLValuesUnmarshaler.
func (m *CreateAlertResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// UpdateAlertRequest implement urlenc.URLValuesUnmarshaler.
func (m *UpdateAlertRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "name":
				m.Name = vals[0]
			case "alertScope":
				m.AlertScope = vals[0]
			case "alertScopeId":
				m.AlertScopeId = vals[0]
			case "enable":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Enable = val
			case "clusterNames":
				m.ClusterNames = vals
			case "domain":
				m.Domain = vals[0]
			case "createTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreateTime = val
			case "updateTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdateTime = val
			}
		}
	}
	return nil
}

// UpdateAlertResponse implement urlenc.URLValuesUnmarshaler.
func (m *UpdateAlertResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// UpdateAlertEnableRequest implement urlenc.URLValuesUnmarshaler.
func (m *UpdateAlertEnableRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "enable":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Enable = val
			}
		}
	}
	return nil
}

// UpdateAlertEnableResponse implement urlenc.URLValuesUnmarshaler.
func (m *UpdateAlertEnableResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// DeleteAlertRequest implement urlenc.URLValuesUnmarshaler.
func (m *DeleteAlertRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			}
		}
	}
	return nil
}

// DeleteAlertResponse implement urlenc.URLValuesUnmarshaler.
func (m *DeleteAlertResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// QueryOrgAlertRuleRequest implement urlenc.URLValuesUnmarshaler.
func (m *QueryOrgAlertRuleRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// QueryOrgAlertRuleResponse implement urlenc.URLValuesUnmarshaler.
func (m *QueryOrgAlertRuleResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &AlertTypeRuleResp{}
				}
			case "data.windows":
				if m.Data == nil {
					m.Data = &AlertTypeRuleResp{}
				}
				list := make([]int64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseInt(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.Data.Windows = list
			}
		}
	}
	return nil
}

// QueryOrgAlertRequest implement urlenc.URLValuesUnmarshaler.
func (m *QueryOrgAlertRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			case "name":
				m.Name = vals[0]
			}
		}
	}
	return nil
}

// QueryOrgAlertResponse implement urlenc.URLValuesUnmarshaler.
func (m *QueryOrgAlertResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &QueryOrgAlertData{}
				}
			case "data.total":
				if m.Data == nil {
					m.Data = &QueryOrgAlertData{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Total = val
			case "userIDs":
				m.UserIDs = vals
			}
		}
	}
	return nil
}

// QueryOrgAlertData implement urlenc.URLValuesUnmarshaler.
func (m *QueryOrgAlertData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// GetOrgAlertDetailRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetOrgAlertDetailRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			}
		}
	}
	return nil
}

// GetOrgAlertDetailResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetOrgAlertDetailResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &Alert{}
				}
			case "data.id":
				if m.Data == nil {
					m.Data = &Alert{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Id = val
			case "data.name":
				if m.Data == nil {
					m.Data = &Alert{}
				}
				m.Data.Name = vals[0]
			case "data.alertScope":
				if m.Data == nil {
					m.Data = &Alert{}
				}
				m.Data.AlertScope = vals[0]
			case "data.alertScopeId":
				if m.Data == nil {
					m.Data = &Alert{}
				}
				m.Data.AlertScopeId = vals[0]
			case "data.enable":
				if m.Data == nil {
					m.Data = &Alert{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Enable = val
			case "data.clusterNames":
				if m.Data == nil {
					m.Data = &Alert{}
				}
				m.Data.ClusterNames = vals
			case "data.domain":
				if m.Data == nil {
					m.Data = &Alert{}
				}
				m.Data.Domain = vals[0]
			case "data.createTime":
				if m.Data == nil {
					m.Data = &Alert{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CreateTime = val
			case "data.updateTime":
				if m.Data == nil {
					m.Data = &Alert{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.UpdateTime = val
			case "data.creator":
				if m.Data == nil {
					m.Data = &Alert{}
				}
				m.Data.Creator = vals[0]
			case "data.ruleCount":
				if m.Data == nil {
					m.Data = &Alert{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.RuleCount = val
			}
		}
	}
	return nil
}

// CreateOrgAlertRequest implement urlenc.URLValuesUnmarshaler.
func (m *CreateOrgAlertRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "name":
				m.Name = vals[0]
			case "alertScope":
				m.AlertScope = vals[0]
			case "alertScopeId":
				m.AlertScopeId = vals[0]
			case "enable":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Enable = val
			case "clusterNames":
				m.ClusterNames = vals
			case "domain":
				m.Domain = vals[0]
			case "createTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreateTime = val
			case "updateTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdateTime = val
			}
		}
	}
	return nil
}

// TriggerCondition implement urlenc.URLValuesUnmarshaler.
func (m *TriggerCondition) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "condition":
				m.Condition = vals[0]
			case "operator":
				m.Operator = vals[0]
			case "values":
				m.Values = vals[0]
			}
		}
	}
	return nil
}

// CreateOrgAlertResponse implement urlenc.URLValuesUnmarshaler.
func (m *CreateOrgAlertResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			}
		}
	}
	return nil
}

// UpdateOrgAlertRequest implement urlenc.URLValuesUnmarshaler.
func (m *UpdateOrgAlertRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "name":
				m.Name = vals[0]
			case "alertScope":
				m.AlertScope = vals[0]
			case "alertScopeId":
				m.AlertScopeId = vals[0]
			case "enable":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Enable = val
			case "clusterNames":
				m.ClusterNames = vals
			case "domain":
				m.Domain = vals[0]
			case "createTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreateTime = val
			case "updateTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdateTime = val
			}
		}
	}
	return nil
}

// UpdateOrgAlertResponse implement urlenc.URLValuesUnmarshaler.
func (m *UpdateOrgAlertResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// UpdateOrgAlertEnableRequest implement urlenc.URLValuesUnmarshaler.
func (m *UpdateOrgAlertEnableRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "enable":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Enable = val
			}
		}
	}
	return nil
}

// UpdateOrgAlertEnableResponse implement urlenc.URLValuesUnmarshaler.
func (m *UpdateOrgAlertEnableResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// DeleteOrgAlertRequest implement urlenc.URLValuesUnmarshaler.
func (m *DeleteOrgAlertRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			}
		}
	}
	return nil
}

// DeleteOrgAlertResponse implement urlenc.URLValuesUnmarshaler.
func (m *DeleteOrgAlertResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// GetAlertRecordAttrRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetAlertRecordAttrRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "scope":
				m.Scope = vals[0]
			}
		}
	}
	return nil
}

// GetAlertRecordAttrResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetAlertRecordAttrResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &AlertRecordAttr{}
				}
			}
		}
	}
	return nil
}

// AlertRecordAttr implement urlenc.URLValuesUnmarshaler.
func (m *AlertRecordAttr) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// QueryAlertRecordRequest implement urlenc.URLValuesUnmarshaler.
func (m *QueryAlertRecordRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "scope":
				m.Scope = vals[0]
			case "scopeKey":
				m.ScopeKey = vals[0]
			case "alertGroup":
				m.AlertGroup = vals
			case "alertState":
				m.AlertState = vals
			case "alertType":
				m.AlertType = vals
			case "handleState":
				m.HandleState = vals
			case "handlerId":
				m.HandlerId = vals
			case "pageNo":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			}
		}
	}
	return nil
}

// QueryAlertRecordResponse implement urlenc.URLValuesUnmarshaler.
func (m *QueryAlertRecordResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &ListResult{}
				}
			case "data.total":
				if m.Data == nil {
					m.Data = &ListResult{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Total = val
			}
		}
	}
	return nil
}

// ListResult implement urlenc.URLValuesUnmarshaler.
func (m *ListResult) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// AlertRecord implement urlenc.URLValuesUnmarshaler.
func (m *AlertRecord) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "groupId":
				m.GroupId = vals[0]
			case "scope":
				m.Scope = vals[0]
			case "scopeKey":
				m.ScopeKey = vals[0]
			case "alertGroup":
				m.AlertGroup = vals[0]
			case "title":
				m.Title = vals[0]
			case "alertState":
				m.AlertState = vals[0]
			case "alertType":
				m.AlertType = vals[0]
			case "alertIndex":
				m.AlertIndex = vals[0]
			case "expressionKey":
				m.ExpressionKey = vals[0]
			case "alertId":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AlertId = val
			case "alertName":
				m.AlertName = vals[0]
			case "ruleId":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.RuleId = val
			case "projectId":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectId = val
			case "issueId":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueId = val
			case "handleState":
				m.HandleState = vals[0]
			case "handlerId":
				m.HandlerId = vals[0]
			case "alertTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AlertTime = val
			case "handleTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.HandleTime = val
			case "createTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreateTime = val
			case "updateTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.UpdateTime = val
			}
		}
	}
	return nil
}

// GetAlertRecordRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetAlertRecordRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "groupId":
				m.GroupId = vals[0]
			}
		}
	}
	return nil
}

// GetAlertRecordResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetAlertRecordResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
			case "data.groupId":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				m.Data.GroupId = vals[0]
			case "data.scope":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				m.Data.Scope = vals[0]
			case "data.scopeKey":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				m.Data.ScopeKey = vals[0]
			case "data.alertGroup":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				m.Data.AlertGroup = vals[0]
			case "data.title":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				m.Data.Title = vals[0]
			case "data.alertState":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				m.Data.AlertState = vals[0]
			case "data.alertType":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				m.Data.AlertType = vals[0]
			case "data.alertIndex":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				m.Data.AlertIndex = vals[0]
			case "data.expressionKey":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				m.Data.ExpressionKey = vals[0]
			case "data.alertId":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.AlertId = val
			case "data.alertName":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				m.Data.AlertName = vals[0]
			case "data.ruleId":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.RuleId = val
			case "data.projectId":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ProjectId = val
			case "data.issueId":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.IssueId = val
			case "data.handleState":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				m.Data.HandleState = vals[0]
			case "data.handlerId":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				m.Data.HandlerId = vals[0]
			case "data.alertTime":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.AlertTime = val
			case "data.handleTime":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.HandleTime = val
			case "data.createTime":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CreateTime = val
			case "data.updateTime":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.UpdateTime = val
			}
		}
	}
	return nil
}

// QueryAlertHistoryRequest implement urlenc.URLValuesUnmarshaler.
func (m *QueryAlertHistoryRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "groupId":
				m.GroupId = vals[0]
			case "start":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Start = val
			case "end":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.End = val
			case "limit":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Limit = val
			}
		}
	}
	return nil
}

// QueryAlertHistoryResponse implement urlenc.URLValuesUnmarshaler.
func (m *QueryAlertHistoryResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// AlertHistory implement urlenc.URLValuesUnmarshaler.
func (m *AlertHistory) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "groupId":
				m.GroupId = vals[0]
			case "timestamp":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Timestamp = val
			case "alertState":
				m.AlertState = vals[0]
			case "title":
				m.Title = vals[0]
			case "content":
				m.Content = vals[0]
			case "displayUrl":
				m.DisplayUrl = vals[0]
			}
		}
	}
	return nil
}

// CreateAlertIssueRequest implement urlenc.URLValuesUnmarshaler.
func (m *CreateAlertIssueRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "groupId":
				m.GroupId = vals[0]
			case "planStartedAt":
				if m.PlanStartedAt == nil {
					m.PlanStartedAt = &timestamppb.Timestamp{}
				}
			case "planStartedAt.seconds":
				if m.PlanStartedAt == nil {
					m.PlanStartedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PlanStartedAt.Seconds = val
			case "planStartedAt.nanos":
				if m.PlanStartedAt == nil {
					m.PlanStartedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.PlanStartedAt.Nanos = int32(val)
			case "planFinishedAt":
				if m.PlanFinishedAt == nil {
					m.PlanFinishedAt = &timestamppb.Timestamp{}
				}
			case "planFinishedAt.seconds":
				if m.PlanFinishedAt == nil {
					m.PlanFinishedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PlanFinishedAt.Seconds = val
			case "planFinishedAt.nanos":
				if m.PlanFinishedAt == nil {
					m.PlanFinishedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.PlanFinishedAt.Nanos = int32(val)
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "iterationID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IterationID = val
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			case "testPlanCaseRelIDs":
				list := make([]uint64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseUint(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.TestPlanCaseRelIDs = list
			case "type":
				m.Type = vals[0]
			case "title":
				m.Title = vals[0]
			case "content":
				m.Content = vals[0]
			case "priority":
				m.Priority = vals[0]
			case "complexity":
				m.Complexity = vals[0]
			case "severity":
				m.Severity = vals[0]
			case "assignee":
				m.Assignee = vals[0]
			case "creator":
				m.Creator = vals[0]
			case "labels":
				m.Labels = vals
			case "source":
				m.Source = vals[0]
			case "issueManHour":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
			case "issueManHour.estimateTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueManHour.EstimateTime = val
			case "issueManHour.thisElapsedTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueManHour.ThisElapsedTime = val
			case "issueManHour.elapsedTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueManHour.ElapsedTime = val
			case "issueManHour.remainingTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueManHour.RemainingTime = val
			case "issueManHour.startTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				m.IssueManHour.StartTime = vals[0]
			case "issueManHour.workContent":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				m.IssueManHour.WorkContent = vals[0]
			case "issueManHour.isModifiedRemainingTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IssueManHour.IsModifiedRemainingTime = val
			case "taskType":
				m.TaskType = vals[0]
			case "bugStage":
				m.BugStage = vals[0]
			case "owner":
				m.Owner = vals[0]
			case "userID":
				m.UserID = vals[0]
			case "internalClient":
				m.InternalClient = vals[0]
			case "external":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.External = val
			}
		}
	}
	return nil
}

// IssueManHour implement urlenc.URLValuesUnmarshaler.
func (m *IssueManHour) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "estimateTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.EstimateTime = val
			case "thisElapsedTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ThisElapsedTime = val
			case "elapsedTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ElapsedTime = val
			case "remainingTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.RemainingTime = val
			case "startTime":
				m.StartTime = vals[0]
			case "workContent":
				m.WorkContent = vals[0]
			case "isModifiedRemainingTime":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsModifiedRemainingTime = val
			}
		}
	}
	return nil
}

// CreateAlertIssueResponse implement urlenc.URLValuesUnmarshaler.
func (m *CreateAlertIssueResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// UpdateAlertIssueRequest implement urlenc.URLValuesUnmarshaler.
func (m *UpdateAlertIssueRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "groupId":
				m.GroupId = vals[0]
			case "title":
				m.Title = vals[0]
			case "content":
				m.Content = vals[0]
			case "state":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.State = val
			case "priority":
				m.Priority = vals[0]
			case "complexity":
				m.Complexity = vals[0]
			case "severity":
				m.Severity = vals[0]
			case "planStartedAt":
				if m.PlanStartedAt == nil {
					m.PlanStartedAt = &timestamppb.Timestamp{}
				}
			case "planStartedAt.seconds":
				if m.PlanStartedAt == nil {
					m.PlanStartedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PlanStartedAt.Seconds = val
			case "planStartedAt.nanos":
				if m.PlanStartedAt == nil {
					m.PlanStartedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.PlanStartedAt.Nanos = int32(val)
			case "planFinishedAt":
				if m.PlanFinishedAt == nil {
					m.PlanFinishedAt = &timestamppb.Timestamp{}
				}
			case "planFinishedAt.seconds":
				if m.PlanFinishedAt == nil {
					m.PlanFinishedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PlanFinishedAt.Seconds = val
			case "planFinishedAt.nanos":
				if m.PlanFinishedAt == nil {
					m.PlanFinishedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.PlanFinishedAt.Nanos = int32(val)
			case "assignee":
				m.Assignee = vals[0]
			case "iterationID":
				m.IterationID = vals[0]
			case "source":
				m.Source = vals[0]
			case "labels":
				m.Labels = vals
			case "relatedIssues":
				list := make([]int64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseInt(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.RelatedIssues = list
			case "taskType":
				m.TaskType = vals[0]
			case "bugStage":
				m.BugStage = vals[0]
			case "owner":
				m.Owner = vals[0]
			case "issueManHour":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
			case "issueManHour.estimateTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueManHour.EstimateTime = val
			case "issueManHour.thisElapsedTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueManHour.ThisElapsedTime = val
			case "issueManHour.elapsedTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueManHour.ElapsedTime = val
			case "issueManHour.remainingTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueManHour.RemainingTime = val
			case "issueManHour.startTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				m.IssueManHour.StartTime = vals[0]
			case "issueManHour.workContent":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				m.IssueManHour.WorkContent = vals[0]
			case "issueManHour.isModifiedRemainingTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IssueManHour.IsModifiedRemainingTime = val
			case "testPlanCaseRelIDs":
				list := make([]uint64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseUint(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.TestPlanCaseRelIDs = list
			case "removeTestPlanCaseRelIDs":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.RemoveTestPlanCaseRelIDs = val
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "userID":
				m.UserID = vals[0]
			case "internalClient":
				m.InternalClient = vals[0]
			case "issueId":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueId = val
			}
		}
	}
	return nil
}

// UpdateAlertIssueResponse implement urlenc.URLValuesUnmarshaler.
func (m *UpdateAlertIssueResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// GetOrgAlertRecordAttrRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetOrgAlertRecordAttrRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// GetOrgAlertRecordAttrResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetOrgAlertRecordAttrResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &AlertRecordAttr{}
				}
			}
		}
	}
	return nil
}

// QueryOrgAlertRecordRequest implement urlenc.URLValuesUnmarshaler.
func (m *QueryOrgAlertRecordRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "alertGroup":
				m.AlertGroup = vals
			case "alertState":
				m.AlertState = vals
			case "alertType":
				m.AlertType = vals
			case "handleState":
				m.HandleState = vals
			case "handlerId":
				m.HandlerId = vals
			case "pageNo":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			}
		}
	}
	return nil
}

// QueryOrgHostsAlertRecordRequest implement urlenc.URLValuesUnmarshaler.
func (m *QueryOrgHostsAlertRecordRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "alertGroup":
				m.AlertGroup = vals
			case "alertState":
				m.AlertState = vals
			case "alertType":
				m.AlertType = vals
			case "handleState":
				m.HandleState = vals
			case "handlerId":
				m.HandlerId = vals
			case "pageNo":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			}
		}
	}
	return nil
}

// ClusterReq implement urlenc.URLValuesUnmarshaler.
func (m *ClusterReq) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "clusterName":
				m.ClusterName = vals[0]
			case "hostIPs":
				m.HostIPs = vals
			}
		}
	}
	return nil
}

// QueryOrgAlertRecordResponse implement urlenc.URLValuesUnmarshaler.
func (m *QueryOrgAlertRecordResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &ListResult{}
				}
			case "data.total":
				if m.Data == nil {
					m.Data = &ListResult{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Total = val
			}
		}
	}
	return nil
}

// GetOrgAlertRecordRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetOrgAlertRecordRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "groupId":
				m.GroupId = vals[0]
			}
		}
	}
	return nil
}

// GetOrgAlertRecordResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetOrgAlertRecordResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
			case "data.groupId":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				m.Data.GroupId = vals[0]
			case "data.scope":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				m.Data.Scope = vals[0]
			case "data.scopeKey":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				m.Data.ScopeKey = vals[0]
			case "data.alertGroup":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				m.Data.AlertGroup = vals[0]
			case "data.title":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				m.Data.Title = vals[0]
			case "data.alertState":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				m.Data.AlertState = vals[0]
			case "data.alertType":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				m.Data.AlertType = vals[0]
			case "data.alertIndex":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				m.Data.AlertIndex = vals[0]
			case "data.expressionKey":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				m.Data.ExpressionKey = vals[0]
			case "data.alertId":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.AlertId = val
			case "data.alertName":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				m.Data.AlertName = vals[0]
			case "data.ruleId":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.RuleId = val
			case "data.projectId":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.ProjectId = val
			case "data.issueId":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.IssueId = val
			case "data.handleState":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				m.Data.HandleState = vals[0]
			case "data.handlerId":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				m.Data.HandlerId = vals[0]
			case "data.alertTime":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.AlertTime = val
			case "data.handleTime":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.HandleTime = val
			case "data.createTime":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.CreateTime = val
			case "data.updateTime":
				if m.Data == nil {
					m.Data = &AlertRecord{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.UpdateTime = val
			}
		}
	}
	return nil
}

// QueryOrgAlertHistoryRequest implement urlenc.URLValuesUnmarshaler.
func (m *QueryOrgAlertHistoryRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "groupId":
				m.GroupId = vals[0]
			case "start":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Start = val
			case "end":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.End = val
			case "limit":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Limit = val
			}
		}
	}
	return nil
}

// QueryOrgAlertHistoryResponse implement urlenc.URLValuesUnmarshaler.
func (m *QueryOrgAlertHistoryResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// CreateOrgAlertIssueRequest implement urlenc.URLValuesUnmarshaler.
func (m *CreateOrgAlertIssueRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "groupId":
				m.GroupId = vals[0]
			case "planStartedAt":
				if m.PlanStartedAt == nil {
					m.PlanStartedAt = &timestamppb.Timestamp{}
				}
			case "planStartedAt.seconds":
				if m.PlanStartedAt == nil {
					m.PlanStartedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PlanStartedAt.Seconds = val
			case "planStartedAt.nanos":
				if m.PlanStartedAt == nil {
					m.PlanStartedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.PlanStartedAt.Nanos = int32(val)
			case "planFinishedAt":
				if m.PlanFinishedAt == nil {
					m.PlanFinishedAt = &timestamppb.Timestamp{}
				}
			case "planFinishedAt.seconds":
				if m.PlanFinishedAt == nil {
					m.PlanFinishedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PlanFinishedAt.Seconds = val
			case "planFinishedAt.nanos":
				if m.PlanFinishedAt == nil {
					m.PlanFinishedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.PlanFinishedAt.Nanos = int32(val)
			case "projectID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ProjectID = val
			case "iterationID":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IterationID = val
			case "appID":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AppID = val
			case "testPlanCaseRelIDs":
				list := make([]uint64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseUint(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.TestPlanCaseRelIDs = list
			case "type":
				m.Type = vals[0]
			case "title":
				m.Title = vals[0]
			case "content":
				m.Content = vals[0]
			case "priority":
				m.Priority = vals[0]
			case "complexity":
				m.Complexity = vals[0]
			case "severity":
				m.Severity = vals[0]
			case "assignee":
				m.Assignee = vals[0]
			case "creator":
				m.Creator = vals[0]
			case "labels":
				m.Labels = vals
			case "source":
				m.Source = vals[0]
			case "issueManHour":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
			case "issueManHour.estimateTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueManHour.EstimateTime = val
			case "issueManHour.thisElapsedTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueManHour.ThisElapsedTime = val
			case "issueManHour.elapsedTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueManHour.ElapsedTime = val
			case "issueManHour.remainingTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueManHour.RemainingTime = val
			case "issueManHour.startTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				m.IssueManHour.StartTime = vals[0]
			case "issueManHour.workContent":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				m.IssueManHour.WorkContent = vals[0]
			case "issueManHour.isModifiedRemainingTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IssueManHour.IsModifiedRemainingTime = val
			case "taskType":
				m.TaskType = vals[0]
			case "bugStage":
				m.BugStage = vals[0]
			case "owner":
				m.Owner = vals[0]
			case "userID":
				m.UserID = vals[0]
			case "internalClient":
				m.InternalClient = vals[0]
			case "external":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.External = val
			}
		}
	}
	return nil
}

// CreateOrgAlertIssueResponse implement urlenc.URLValuesUnmarshaler.
func (m *CreateOrgAlertIssueResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// UpdateOrgAlertIssueRequest implement urlenc.URLValuesUnmarshaler.
func (m *UpdateOrgAlertIssueRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "groupId":
				m.GroupId = vals[0]
			case "title":
				m.Title = vals[0]
			case "content":
				m.Content = vals[0]
			case "state":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.State = val
			case "priority":
				m.Priority = vals[0]
			case "complexity":
				m.Complexity = vals[0]
			case "severity":
				m.Severity = vals[0]
			case "planStartedAt":
				if m.PlanStartedAt == nil {
					m.PlanStartedAt = &timestamppb.Timestamp{}
				}
			case "planStartedAt.seconds":
				if m.PlanStartedAt == nil {
					m.PlanStartedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PlanStartedAt.Seconds = val
			case "planStartedAt.nanos":
				if m.PlanStartedAt == nil {
					m.PlanStartedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.PlanStartedAt.Nanos = int32(val)
			case "planFinishedAt":
				if m.PlanFinishedAt == nil {
					m.PlanFinishedAt = &timestamppb.Timestamp{}
				}
			case "planFinishedAt.seconds":
				if m.PlanFinishedAt == nil {
					m.PlanFinishedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PlanFinishedAt.Seconds = val
			case "planFinishedAt.nanos":
				if m.PlanFinishedAt == nil {
					m.PlanFinishedAt = &timestamppb.Timestamp{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.PlanFinishedAt.Nanos = int32(val)
			case "assignee":
				m.Assignee = vals[0]
			case "iterationID":
				m.IterationID = vals[0]
			case "source":
				m.Source = vals[0]
			case "labels":
				m.Labels = vals
			case "relatedIssues":
				list := make([]int64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseInt(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.RelatedIssues = list
			case "taskType":
				m.TaskType = vals[0]
			case "bugStage":
				m.BugStage = vals[0]
			case "owner":
				m.Owner = vals[0]
			case "issueManHour":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
			case "issueManHour.estimateTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueManHour.EstimateTime = val
			case "issueManHour.thisElapsedTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueManHour.ThisElapsedTime = val
			case "issueManHour.elapsedTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueManHour.ElapsedTime = val
			case "issueManHour.remainingTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.IssueManHour.RemainingTime = val
			case "issueManHour.startTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				m.IssueManHour.StartTime = vals[0]
			case "issueManHour.workContent":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				m.IssueManHour.WorkContent = vals[0]
			case "issueManHour.isModifiedRemainingTime":
				if m.IssueManHour == nil {
					m.IssueManHour = &IssueManHour{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IssueManHour.IsModifiedRemainingTime = val
			case "testPlanCaseRelIDs":
				list := make([]uint64, 0, len(vals))
				for _, text := range vals {
					val, err := strconv.ParseUint(text, 10, 64)
					if err != nil {
						return err
					}
					list = append(list, val)
				}
				m.TestPlanCaseRelIDs = list
			case "removeTestPlanCaseRelIDs":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.RemoveTestPlanCaseRelIDs = val
			case "id":
				val, err := strconv.ParseUint(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Id = val
			case "userID":
				m.UserID = vals[0]
			case "internalClient":
				m.InternalClient = vals[0]
			}
		}
	}
	return nil
}

// UpdateOrgAlertIssueResponse implement urlenc.URLValuesUnmarshaler.
func (m *UpdateOrgAlertIssueResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// GetAlertConditionsRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetAlertConditionsRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "scopeType":
				m.ScopeType = vals[0]
			}
		}
	}
	return nil
}

// GetAlertConditionsResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetAlertConditionsResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// Conditions implement urlenc.URLValuesUnmarshaler.
func (m *Conditions) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "key":
				m.Key = vals[0]
			case "filters":
				m.Filters = vals
			case "displayName":
				m.DisplayName = vals[0]
			case "index":
				m.Index = vals[0]
			}
		}
	}
	return nil
}

// GetAlertConditionsValueRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetAlertConditionsValueRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// ConditionsValueRequest implement urlenc.URLValuesUnmarshaler.
func (m *ConditionsValueRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "condition":
				m.Condition = vals[0]
			case "index":
				m.Index = vals[0]
			}
		}
	}
	return nil
}

// GetAlertConditionsValueResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetAlertConditionsValueResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// AlertConditionsValue implement urlenc.URLValuesUnmarshaler.
func (m *AlertConditionsValue) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "key":
				m.Key = vals[0]
			}
		}
	}
	return nil
}
