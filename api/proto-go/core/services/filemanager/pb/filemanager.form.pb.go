// Code generated by protoc-gen-go-form. DO NOT EDIT.
// Source: filemanager.proto

package pb

import (
	url "net/url"
	strconv "strconv"

	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/urlenc" package it is being compiled against.
var _ urlenc.URLValuesUnmarshaler = (*ListFilesRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ListFilesResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*FileDirectory)(nil)
var _ urlenc.URLValuesUnmarshaler = (*FileInfo)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ReadFileRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ReadFileResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*FileData)(nil)
var _ urlenc.URLValuesUnmarshaler = (*WriteFileRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*WriteFileResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*MakeDirectoryRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*MakeDirectoryResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*MoveFileRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*MoveFileResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteFileRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteFileResponse)(nil)

// ListFilesRequest implement urlenc.URLValuesUnmarshaler.
func (m *ListFilesRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "containerID":
				m.ContainerID = vals[0]
			case "hostIP":
				m.HostIP = vals[0]
			case "scope":
				m.Scope = vals[0]
			case "path":
				m.Path = vals[0]
			}
		}
	}
	return nil
}

// ListFilesResponse implement urlenc.URLValuesUnmarshaler.
func (m *ListFilesResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &FileDirectory{}
				}
			case "data.directory":
				if m.Data == nil {
					m.Data = &FileDirectory{}
				}
				m.Data.Directory = vals[0]
			}
		}
	}
	return nil
}

// FileDirectory implement urlenc.URLValuesUnmarshaler.
func (m *FileDirectory) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "directory":
				m.Directory = vals[0]
			}
		}
	}
	return nil
}

// FileInfo implement urlenc.URLValuesUnmarshaler.
func (m *FileInfo) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "name":
				m.Name = vals[0]
			case "mode":
				m.Mode = vals[0]
			case "size":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Size = val
			case "hardLinks":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.HardLinks = val
			case "modTime":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.ModTime = val
			case "user":
				m.User = vals[0]
			case "userGroup":
				m.UserGroup = vals[0]
			case "isDir":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.IsDir = val
			}
		}
	}
	return nil
}

// ReadFileRequest implement urlenc.URLValuesUnmarshaler.
func (m *ReadFileRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "containerID":
				m.ContainerID = vals[0]
			case "hostIP":
				m.HostIP = vals[0]
			case "scope":
				m.Scope = vals[0]
			case "path":
				m.Path = vals[0]
			}
		}
	}
	return nil
}

// ReadFileResponse implement urlenc.URLValuesUnmarshaler.
func (m *ReadFileResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &FileData{}
				}
			case "data.path":
				if m.Data == nil {
					m.Data = &FileData{}
				}
				m.Data.Path = vals[0]
			case "data.mode":
				if m.Data == nil {
					m.Data = &FileData{}
				}
				m.Data.Mode = vals[0]
			case "data.encoding":
				if m.Data == nil {
					m.Data = &FileData{}
				}
				m.Data.Encoding = vals[0]
			case "data.content":
				if m.Data == nil {
					m.Data = &FileData{}
				}
				m.Data.Content = vals[0]
			case "data.size":
				if m.Data == nil {
					m.Data = &FileData{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Size = val
			}
		}
	}
	return nil
}

// FileData implement urlenc.URLValuesUnmarshaler.
func (m *FileData) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "path":
				m.Path = vals[0]
			case "mode":
				m.Mode = vals[0]
			case "encoding":
				m.Encoding = vals[0]
			case "content":
				m.Content = vals[0]
			case "size":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Size = val
			}
		}
	}
	return nil
}

// WriteFileRequest implement urlenc.URLValuesUnmarshaler.
func (m *WriteFileRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "containerID":
				m.ContainerID = vals[0]
			case "hostIP":
				m.HostIP = vals[0]
			case "scope":
				m.Scope = vals[0]
			case "path":
				m.Path = vals[0]
			case "encoding":
				m.Encoding = vals[0]
			case "content":
				m.Content = vals[0]
			case "action":
				m.Action = vals[0]
			}
		}
	}
	return nil
}

// WriteFileResponse implement urlenc.URLValuesUnmarshaler.
func (m *WriteFileResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				m.Data = vals[0]
			}
		}
	}
	return nil
}

// MakeDirectoryRequest implement urlenc.URLValuesUnmarshaler.
func (m *MakeDirectoryRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "containerID":
				m.ContainerID = vals[0]
			case "hostIP":
				m.HostIP = vals[0]
			case "scope":
				m.Scope = vals[0]
			case "all":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.All = val
			case "path":
				m.Path = vals[0]
			}
		}
	}
	return nil
}

// MakeDirectoryResponse implement urlenc.URLValuesUnmarshaler.
func (m *MakeDirectoryResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				m.Data = vals[0]
			}
		}
	}
	return nil
}

// MoveFileRequest implement urlenc.URLValuesUnmarshaler.
func (m *MoveFileRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "containerID":
				m.ContainerID = vals[0]
			case "hostIP":
				m.HostIP = vals[0]
			case "scope":
				m.Scope = vals[0]
			case "source":
				m.Source = vals[0]
			case "destination":
				m.Destination = vals[0]
			}
		}
	}
	return nil
}

// MoveFileResponse implement urlenc.URLValuesUnmarshaler.
func (m *MoveFileResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				m.Data = vals[0]
			}
		}
	}
	return nil
}

// DeleteFileRequest implement urlenc.URLValuesUnmarshaler.
func (m *DeleteFileRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "containerID":
				m.ContainerID = vals[0]
			case "hostIP":
				m.HostIP = vals[0]
			case "scope":
				m.Scope = vals[0]
			case "path":
				m.Path = vals[0]
			}
		}
	}
	return nil
}

// DeleteFileResponse implement urlenc.URLValuesUnmarshaler.
func (m *DeleteFileResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				m.Data = vals[0]
			}
		}
	}
	return nil
}
