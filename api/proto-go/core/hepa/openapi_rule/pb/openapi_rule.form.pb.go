// Code generated by protoc-gen-go-form. DO NOT EDIT.
// Source: openapi_rule.proto

package pb

import (
	json "encoding/json"
	url "net/url"
	strconv "strconv"
	strings "strings"

	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
	pb "github.com/erda-project/erda-proto-go/core/hepa/pb"
	structpb "google.golang.org/protobuf/types/known/structpb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/urlenc" package it is being compiled against.
var _ urlenc.URLValuesUnmarshaler = (*DeleteLimitResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteLimitRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*LimitRuleInfo)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateLimitResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateLimitRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateLimitResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*LimitType)(nil)
var _ urlenc.URLValuesUnmarshaler = (*LimitRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateLimitRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetLimitsRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetLimitsResponse)(nil)

// DeleteLimitResponse implement urlenc.URLValuesUnmarshaler.
func (m *DeleteLimitResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// DeleteLimitRequest implement urlenc.URLValuesUnmarshaler.
func (m *DeleteLimitRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ruleId":
				m.RuleId = vals[0]
			}
		}
	}
	return nil
}

// LimitRuleInfo implement urlenc.URLValuesUnmarshaler.
func (m *LimitRuleInfo) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "consumerId":
				m.ConsumerId = vals[0]
			case "packageId":
				m.PackageId = vals[0]
			case "method":
				m.Method = vals[0]
			case "apiPath":
				m.ApiPath = vals[0]
			case "limit":
				if m.Limit == nil {
					m.Limit = &LimitType{}
				}
			case "limit.qpd":
				if m.Limit == nil {
					m.Limit = &LimitType{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Limit.Qpd = int32(val)
			case "limit.qph":
				if m.Limit == nil {
					m.Limit = &LimitType{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Limit.Qph = int32(val)
			case "limit.qpm":
				if m.Limit == nil {
					m.Limit = &LimitType{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Limit.Qpm = int32(val)
			case "limit.qps":
				if m.Limit == nil {
					m.Limit = &LimitType{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Limit.Qps = int32(val)
			case "id":
				m.Id = vals[0]
			case "createAt":
				m.CreateAt = vals[0]
			case "consumerName":
				m.ConsumerName = vals[0]
			case "packageName":
				m.PackageName = vals[0]
			}
		}
	}
	return nil
}

// UpdateLimitResponse implement urlenc.URLValuesUnmarshaler.
func (m *UpdateLimitResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &LimitRuleInfo{}
				}
			case "data.consumerId":
				if m.Data == nil {
					m.Data = &LimitRuleInfo{}
				}
				m.Data.ConsumerId = vals[0]
			case "data.packageId":
				if m.Data == nil {
					m.Data = &LimitRuleInfo{}
				}
				m.Data.PackageId = vals[0]
			case "data.method":
				if m.Data == nil {
					m.Data = &LimitRuleInfo{}
				}
				m.Data.Method = vals[0]
			case "data.apiPath":
				if m.Data == nil {
					m.Data = &LimitRuleInfo{}
				}
				m.Data.ApiPath = vals[0]
			case "data.limit":
				if m.Data == nil {
					m.Data = &LimitRuleInfo{}
				}
				if m.Data.Limit == nil {
					m.Data.Limit = &LimitType{}
				}
			case "data.limit.qpd":
				if m.Data == nil {
					m.Data = &LimitRuleInfo{}
				}
				if m.Data.Limit == nil {
					m.Data.Limit = &LimitType{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.Limit.Qpd = int32(val)
			case "data.limit.qph":
				if m.Data == nil {
					m.Data = &LimitRuleInfo{}
				}
				if m.Data.Limit == nil {
					m.Data.Limit = &LimitType{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.Limit.Qph = int32(val)
			case "data.limit.qpm":
				if m.Data == nil {
					m.Data = &LimitRuleInfo{}
				}
				if m.Data.Limit == nil {
					m.Data.Limit = &LimitType{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.Limit.Qpm = int32(val)
			case "data.limit.qps":
				if m.Data == nil {
					m.Data = &LimitRuleInfo{}
				}
				if m.Data.Limit == nil {
					m.Data.Limit = &LimitType{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Data.Limit.Qps = int32(val)
			case "data.id":
				if m.Data == nil {
					m.Data = &LimitRuleInfo{}
				}
				m.Data.Id = vals[0]
			case "data.createAt":
				if m.Data == nil {
					m.Data = &LimitRuleInfo{}
				}
				m.Data.CreateAt = vals[0]
			case "data.consumerName":
				if m.Data == nil {
					m.Data = &LimitRuleInfo{}
				}
				m.Data.ConsumerName = vals[0]
			case "data.packageName":
				if m.Data == nil {
					m.Data = &LimitRuleInfo{}
				}
				m.Data.PackageName = vals[0]
			}
		}
	}
	return nil
}

// UpdateLimitRequest implement urlenc.URLValuesUnmarshaler.
func (m *UpdateLimitRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "ruleId":
				m.RuleId = vals[0]
			case "limitRequest":
				if m.LimitRequest == nil {
					m.LimitRequest = &LimitRequest{}
				}
			case "limitRequest.consumerId":
				if m.LimitRequest == nil {
					m.LimitRequest = &LimitRequest{}
				}
				m.LimitRequest.ConsumerId = vals[0]
			case "limitRequest.packageId":
				if m.LimitRequest == nil {
					m.LimitRequest = &LimitRequest{}
				}
				m.LimitRequest.PackageId = vals[0]
			case "limitRequest.method":
				if m.LimitRequest == nil {
					m.LimitRequest = &LimitRequest{}
				}
				m.LimitRequest.Method = vals[0]
			case "limitRequest.apiPath":
				if m.LimitRequest == nil {
					m.LimitRequest = &LimitRequest{}
				}
				m.LimitRequest.ApiPath = vals[0]
			case "limitRequest.limit":
				if m.LimitRequest == nil {
					m.LimitRequest = &LimitRequest{}
				}
				if m.LimitRequest.Limit == nil {
					m.LimitRequest.Limit = &LimitType{}
				}
			case "limitRequest.limit.qpd":
				if m.LimitRequest == nil {
					m.LimitRequest = &LimitRequest{}
				}
				if m.LimitRequest.Limit == nil {
					m.LimitRequest.Limit = &LimitType{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.LimitRequest.Limit.Qpd = int32(val)
			case "limitRequest.limit.qph":
				if m.LimitRequest == nil {
					m.LimitRequest = &LimitRequest{}
				}
				if m.LimitRequest.Limit == nil {
					m.LimitRequest.Limit = &LimitType{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.LimitRequest.Limit.Qph = int32(val)
			case "limitRequest.limit.qpm":
				if m.LimitRequest == nil {
					m.LimitRequest = &LimitRequest{}
				}
				if m.LimitRequest.Limit == nil {
					m.LimitRequest.Limit = &LimitType{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.LimitRequest.Limit.Qpm = int32(val)
			case "limitRequest.limit.qps":
				if m.LimitRequest == nil {
					m.LimitRequest = &LimitRequest{}
				}
				if m.LimitRequest.Limit == nil {
					m.LimitRequest.Limit = &LimitType{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.LimitRequest.Limit.Qps = int32(val)
			}
		}
	}
	return nil
}

// CreateLimitResponse implement urlenc.URLValuesUnmarshaler.
func (m *CreateLimitResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// LimitType implement urlenc.URLValuesUnmarshaler.
func (m *LimitType) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "qpd":
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Qpd = int32(val)
			case "qph":
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Qph = int32(val)
			case "qpm":
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Qpm = int32(val)
			case "qps":
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Qps = int32(val)
			}
		}
	}
	return nil
}

// LimitRequest implement urlenc.URLValuesUnmarshaler.
func (m *LimitRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "consumerId":
				m.ConsumerId = vals[0]
			case "packageId":
				m.PackageId = vals[0]
			case "method":
				m.Method = vals[0]
			case "apiPath":
				m.ApiPath = vals[0]
			case "limit":
				if m.Limit == nil {
					m.Limit = &LimitType{}
				}
			case "limit.qpd":
				if m.Limit == nil {
					m.Limit = &LimitType{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Limit.Qpd = int32(val)
			case "limit.qph":
				if m.Limit == nil {
					m.Limit = &LimitType{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Limit.Qph = int32(val)
			case "limit.qpm":
				if m.Limit == nil {
					m.Limit = &LimitType{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Limit.Qpm = int32(val)
			case "limit.qps":
				if m.Limit == nil {
					m.Limit = &LimitType{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.Limit.Qps = int32(val)
			}
		}
	}
	return nil
}

// CreateLimitRequest implement urlenc.URLValuesUnmarshaler.
func (m *CreateLimitRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectId":
				m.ProjectId = vals[0]
			case "env":
				m.Env = vals[0]
			case "limitRequest":
				if m.LimitRequest == nil {
					m.LimitRequest = &LimitRequest{}
				}
			case "limitRequest.consumerId":
				if m.LimitRequest == nil {
					m.LimitRequest = &LimitRequest{}
				}
				m.LimitRequest.ConsumerId = vals[0]
			case "limitRequest.packageId":
				if m.LimitRequest == nil {
					m.LimitRequest = &LimitRequest{}
				}
				m.LimitRequest.PackageId = vals[0]
			case "limitRequest.method":
				if m.LimitRequest == nil {
					m.LimitRequest = &LimitRequest{}
				}
				m.LimitRequest.Method = vals[0]
			case "limitRequest.apiPath":
				if m.LimitRequest == nil {
					m.LimitRequest = &LimitRequest{}
				}
				m.LimitRequest.ApiPath = vals[0]
			case "limitRequest.limit":
				if m.LimitRequest == nil {
					m.LimitRequest = &LimitRequest{}
				}
				if m.LimitRequest.Limit == nil {
					m.LimitRequest.Limit = &LimitType{}
				}
			case "limitRequest.limit.qpd":
				if m.LimitRequest == nil {
					m.LimitRequest = &LimitRequest{}
				}
				if m.LimitRequest.Limit == nil {
					m.LimitRequest.Limit = &LimitType{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.LimitRequest.Limit.Qpd = int32(val)
			case "limitRequest.limit.qph":
				if m.LimitRequest == nil {
					m.LimitRequest = &LimitRequest{}
				}
				if m.LimitRequest.Limit == nil {
					m.LimitRequest.Limit = &LimitType{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.LimitRequest.Limit.Qph = int32(val)
			case "limitRequest.limit.qpm":
				if m.LimitRequest == nil {
					m.LimitRequest = &LimitRequest{}
				}
				if m.LimitRequest.Limit == nil {
					m.LimitRequest.Limit = &LimitType{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.LimitRequest.Limit.Qpm = int32(val)
			case "limitRequest.limit.qps":
				if m.LimitRequest == nil {
					m.LimitRequest = &LimitRequest{}
				}
				if m.LimitRequest.Limit == nil {
					m.LimitRequest.Limit = &LimitType{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 32)
				if err != nil {
					return err
				}
				m.LimitRequest.Limit.Qps = int32(val)
			}
		}
	}
	return nil
}

// GetLimitsRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetLimitsRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "consumerId":
				m.ConsumerId = vals[0]
			case "packageId":
				m.PackageId = vals[0]
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			}
		}
	}
	return nil
}

// GetLimitsResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetLimitsResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &pb.NewPageResult{}
				}
			case "data.list":
				if m.Data == nil {
					m.Data = &pb.NewPageResult{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.List = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.List = val
					} else {
						m.Data.List = structpb.NewStringValue(vals[0])
					}
				}
			case "data.list.null_value":
				if m.Data == nil {
					m.Data = &pb.NewPageResult{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.List = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.List = val
					} else {
						m.Data.List = structpb.NewStringValue(vals[0])
					}
				}
			case "data.list.number_value":
				if m.Data == nil {
					m.Data = &pb.NewPageResult{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.List = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.List = val
					} else {
						m.Data.List = structpb.NewStringValue(vals[0])
					}
				}
			case "data.list.string_value":
				if m.Data == nil {
					m.Data = &pb.NewPageResult{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.List = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.List = val
					} else {
						m.Data.List = structpb.NewStringValue(vals[0])
					}
				}
			case "data.list.bool_value":
				if m.Data == nil {
					m.Data = &pb.NewPageResult{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.List = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.List = val
					} else {
						m.Data.List = structpb.NewStringValue(vals[0])
					}
				}
			case "data.list.struct_value":
				if m.Data == nil {
					m.Data = &pb.NewPageResult{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.List = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.List = val
					} else {
						m.Data.List = structpb.NewStringValue(vals[0])
					}
				}
			case "data.list.list_value":
				if m.Data == nil {
					m.Data = &pb.NewPageResult{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.List = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.List = val
					} else {
						m.Data.List = structpb.NewStringValue(vals[0])
					}
				}
			case "data.total":
				if m.Data == nil {
					m.Data = &pb.NewPageResult{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Total = val
			}
		}
	}
	return nil
}
