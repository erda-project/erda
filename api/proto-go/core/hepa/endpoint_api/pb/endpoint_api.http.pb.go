// Code generated by protoc-gen-go-http. DO NOT EDIT.
// Source: endpoint_api.proto

package pb

import (
	context "context"
	http1 "net/http"
	strconv "strconv"
	strings "strings"

	transport "github.com/erda-project/erda-infra/pkg/transport"
	http "github.com/erda-project/erda-infra/pkg/transport/http"
	httprule "github.com/erda-project/erda-infra/pkg/transport/http/httprule"
	runtime "github.com/erda-project/erda-infra/pkg/transport/http/runtime"
	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/transport/http" package it is being compiled against.
const _ = http.SupportPackageIsVersion1

// EndpointApiServiceHandler is the server API for EndpointApiService service.
type EndpointApiServiceHandler interface {
	// +publish path: "/api/gateway/openapi/packages-name"
	// GET /api/gateway/openapi/packages-name
	GetEndpointsName(context.Context, *GetEndpointsNameRequest) (*GetEndpointsNameResponse, error)
	// +publish path: "/api/gateway/openapi/packages"
	// GET /api/gateway/openapi/packages
	GetEndpoints(context.Context, *GetEndpointsRequest) (*GetEndpointsResponse, error)
	// +publish path: "/api/gateway/openapi/packages/{packageId}"
	// GET /api/gateway/openapi/packages/{packageId}
	GetEndpoint(context.Context, *GetEndpointRequest) (*GetEndpointResponse, error)
	// +publish path: "/api/gateway/openapi/packages"
	// POST /api/gateway/openapi/packages
	CreateEndpoint(context.Context, *CreateEndpointRequest) (*CreateEndpointResponse, error)
	// +publish path: "/api/gateway/openapi/packages/{packageId}"
	// PATCH /api/gateway/openapi/packages/{packageId}
	UpdateEndpoint(context.Context, *UpdateEndpointRequest) (*UpdateEndpointResponse, error)
	// +publish path: "/api/gateway/openapi/packages/{packageId}"
	// DELETE /api/gateway/openapi/packages/{packageId}
	DeleteEndpoint(context.Context, *DeleteEndpointRequest) (*DeleteEndpointResponse, error)
	// +publish path: "/api/gateway/openapi/packages/{packageId}/apis"
	// GET /api/gateway/openapi/packages/{packageId}/apis
	GetEndpointApis(context.Context, *GetEndpointApisRequest) (*GetEndpointApisResponse, error)
	// +publish path: "/api/gateway/openapi/packages/{packageId}/apis"
	// POST /api/gateway/openapi/packages/{packageId}/apis
	CreateEndpointApi(context.Context, *CreateEndpointApiRequest) (*CreateEndpointApiResponse, error)
	// +publish path: "/api/gateway/openapi/packages/{packageId}/apis/{apiId}"
	// PATCH /api/gateway/openapi/packages/{packageId}/apis/{apiId}
	UpdateEndpointApi(context.Context, *UpdateEndpointApiRequest) (*UpdateEndpointApiResponse, error)
	// +publish path: "/api/gateway/openapi/packages/{packageId}/apis/{apiId}"
	// DELETE /api/gateway/openapi/packages/{packageId}/apis/{apiId}
	DeleteEndpointApi(context.Context, *DeleteEndpointApiRequest) (*DeleteEndpointApiResponse, error)
	// +publish path: "/api/gateway/openapi/packages/{packageId}/root-api"
	// PUT /api/gateway/openapi/packages/{packageId}/root-api
	ChangeEndpointRoot(context.Context, *ChangeEndpointRootRequest) (*ChangeEndpointRootResponse, error)
}

// RegisterEndpointApiServiceHandler register EndpointApiServiceHandler to http.Router.
func RegisterEndpointApiServiceHandler(r http.Router, srv EndpointApiServiceHandler, opts ...http.HandleOption) {
	h := http.DefaultHandleOptions()
	for _, op := range opts {
		op(h)
	}
	encodeFunc := func(fn func(http1.ResponseWriter, *http1.Request) (interface{}, error)) http.HandlerFunc {
		handler := func(w http1.ResponseWriter, r *http1.Request) {
			out, err := fn(w, r)
			if err != nil {
				h.Error(w, r, err)
				return
			}
			if err := h.Encode(w, r, out); err != nil {
				h.Error(w, r, err)
			}
		}
		if h.HTTPInterceptor != nil {
			handler = h.HTTPInterceptor(handler)
		}
		return handler
	}

	add_GetEndpointsName := func(method, path string, fn func(context.Context, *GetEndpointsNameRequest) (*GetEndpointsNameResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetEndpointsNameRequest))
		}
		var GetEndpointsName_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetEndpointsName_info = transport.NewServiceInfo("erda.core.hepa.endpoint_api.EndpointApiService", "GetEndpointsName", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetEndpointsName_info)
				}
				r = r.WithContext(ctx)
				var in GetEndpointsNameRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				params := r.URL.Query()
				if vals := params["env"]; len(vals) > 0 {
					in.Env = vals[0]
				}
				if vals := params["projectId"]; len(vals) > 0 {
					in.ProjectId = vals[0]
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetEndpoints := func(method, path string, fn func(context.Context, *GetEndpointsRequest) (*GetEndpointsResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetEndpointsRequest))
		}
		var GetEndpoints_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetEndpoints_info = transport.NewServiceInfo("erda.core.hepa.endpoint_api.EndpointApiService", "GetEndpoints", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetEndpoints_info)
				}
				r = r.WithContext(ctx)
				var in GetEndpointsRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				params := r.URL.Query()
				if vals := params["domain"]; len(vals) > 0 {
					in.Domain = vals[0]
				}
				if vals := params["env"]; len(vals) > 0 {
					in.Env = vals[0]
				}
				if vals := params["pageNo"]; len(vals) > 0 {
					val, err := strconv.ParseInt(vals[0], 10, 64)
					if err != nil {
						return nil, err
					}
					in.PageNo = val
				}
				if vals := params["pageSize"]; len(vals) > 0 {
					val, err := strconv.ParseInt(vals[0], 10, 64)
					if err != nil {
						return nil, err
					}
					in.PageSize = val
				}
				if vals := params["projectId"]; len(vals) > 0 {
					in.ProjectId = vals[0]
				}
				if vals := params["sortField"]; len(vals) > 0 {
					in.SortField = vals[0]
				}
				if vals := params["sortType"]; len(vals) > 0 {
					in.SortType = vals[0]
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetEndpoint := func(method, path string, fn func(context.Context, *GetEndpointRequest) (*GetEndpointResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetEndpointRequest))
		}
		var GetEndpoint_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetEndpoint_info = transport.NewServiceInfo("erda.core.hepa.endpoint_api.EndpointApiService", "GetEndpoint", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetEndpoint_info)
				}
				r = r.WithContext(ctx)
				var in GetEndpointRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "packageId":
							in.PackageId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CreateEndpoint := func(method, path string, fn func(context.Context, *CreateEndpointRequest) (*CreateEndpointResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateEndpointRequest))
		}
		var CreateEndpoint_info transport.ServiceInfo
		if h.Interceptor != nil {
			CreateEndpoint_info = transport.NewServiceInfo("erda.core.hepa.endpoint_api.EndpointApiService", "CreateEndpoint", srv)
			handler = h.Interceptor(handler)
		}
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CreateEndpoint_info)
				}
				r = r.WithContext(ctx)
				var in CreateEndpointRequest
				if err := h.Decode(r, &in.Endpoint); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				params := r.URL.Query()
				if vals := params["env"]; len(vals) > 0 {
					in.Env = vals[0]
				}
				if vals := params["projectId"]; len(vals) > 0 {
					in.ProjectId = vals[0]
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_UpdateEndpoint := func(method, path string, fn func(context.Context, *UpdateEndpointRequest) (*UpdateEndpointResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpdateEndpointRequest))
		}
		var UpdateEndpoint_info transport.ServiceInfo
		if h.Interceptor != nil {
			UpdateEndpoint_info = transport.NewServiceInfo("erda.core.hepa.endpoint_api.EndpointApiService", "UpdateEndpoint", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, UpdateEndpoint_info)
				}
				r = r.WithContext(ctx)
				var in UpdateEndpointRequest
				if err := h.Decode(r, &in.Endpoint); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "packageId":
							in.PackageId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_DeleteEndpoint := func(method, path string, fn func(context.Context, *DeleteEndpointRequest) (*DeleteEndpointResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DeleteEndpointRequest))
		}
		var DeleteEndpoint_info transport.ServiceInfo
		if h.Interceptor != nil {
			DeleteEndpoint_info = transport.NewServiceInfo("erda.core.hepa.endpoint_api.EndpointApiService", "DeleteEndpoint", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, DeleteEndpoint_info)
				}
				r = r.WithContext(ctx)
				var in DeleteEndpointRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "packageId":
							in.PackageId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetEndpointApis := func(method, path string, fn func(context.Context, *GetEndpointApisRequest) (*GetEndpointApisResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*GetEndpointApisRequest))
		}
		var GetEndpointApis_info transport.ServiceInfo
		if h.Interceptor != nil {
			GetEndpointApis_info = transport.NewServiceInfo("erda.core.hepa.endpoint_api.EndpointApiService", "GetEndpointApis", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, GetEndpointApis_info)
				}
				r = r.WithContext(ctx)
				var in GetEndpointApisRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				params := r.URL.Query()
				if vals := params["apiPath"]; len(vals) > 0 {
					in.ApiPath = vals[0]
				}
				if vals := params["diceApp"]; len(vals) > 0 {
					in.DiceApp = vals[0]
				}
				if vals := params["diceService"]; len(vals) > 0 {
					in.DiceService = vals[0]
				}
				if vals := params["method"]; len(vals) > 0 {
					in.Method = vals[0]
				}
				if vals := params["origin"]; len(vals) > 0 {
					in.Origin = vals[0]
				}
				if vals := params["pageNo"]; len(vals) > 0 {
					val, err := strconv.ParseInt(vals[0], 10, 64)
					if err != nil {
						return nil, err
					}
					in.PageNo = val
				}
				if vals := params["pageSize"]; len(vals) > 0 {
					val, err := strconv.ParseInt(vals[0], 10, 64)
					if err != nil {
						return nil, err
					}
					in.PageSize = val
				}
				if vals := params["sortField"]; len(vals) > 0 {
					in.SortField = vals[0]
				}
				if vals := params["sortType"]; len(vals) > 0 {
					in.SortType = vals[0]
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "packageId":
							in.PackageId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_CreateEndpointApi := func(method, path string, fn func(context.Context, *CreateEndpointApiRequest) (*CreateEndpointApiResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*CreateEndpointApiRequest))
		}
		var CreateEndpointApi_info transport.ServiceInfo
		if h.Interceptor != nil {
			CreateEndpointApi_info = transport.NewServiceInfo("erda.core.hepa.endpoint_api.EndpointApiService", "CreateEndpointApi", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, CreateEndpointApi_info)
				}
				r = r.WithContext(ctx)
				var in CreateEndpointApiRequest
				if err := h.Decode(r, &in.EndpointApi); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "packageId":
							in.PackageId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_UpdateEndpointApi := func(method, path string, fn func(context.Context, *UpdateEndpointApiRequest) (*UpdateEndpointApiResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*UpdateEndpointApiRequest))
		}
		var UpdateEndpointApi_info transport.ServiceInfo
		if h.Interceptor != nil {
			UpdateEndpointApi_info = transport.NewServiceInfo("erda.core.hepa.endpoint_api.EndpointApiService", "UpdateEndpointApi", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, UpdateEndpointApi_info)
				}
				r = r.WithContext(ctx)
				var in UpdateEndpointApiRequest
				if err := h.Decode(r, &in.EndpointApi); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "packageId":
							in.PackageId = val
						case "apiId":
							in.ApiId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_DeleteEndpointApi := func(method, path string, fn func(context.Context, *DeleteEndpointApiRequest) (*DeleteEndpointApiResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*DeleteEndpointApiRequest))
		}
		var DeleteEndpointApi_info transport.ServiceInfo
		if h.Interceptor != nil {
			DeleteEndpointApi_info = transport.NewServiceInfo("erda.core.hepa.endpoint_api.EndpointApiService", "DeleteEndpointApi", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, DeleteEndpointApi_info)
				}
				r = r.WithContext(ctx)
				var in DeleteEndpointApiRequest
				if err := h.Decode(r, &in); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "packageId":
							in.PackageId = val
						case "apiId":
							in.ApiId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_ChangeEndpointRoot := func(method, path string, fn func(context.Context, *ChangeEndpointRootRequest) (*ChangeEndpointRootResponse, error)) {
		handler := func(ctx context.Context, req interface{}) (interface{}, error) {
			return fn(ctx, req.(*ChangeEndpointRootRequest))
		}
		var ChangeEndpointRoot_info transport.ServiceInfo
		if h.Interceptor != nil {
			ChangeEndpointRoot_info = transport.NewServiceInfo("erda.core.hepa.endpoint_api.EndpointApiService", "ChangeEndpointRoot", srv)
			handler = h.Interceptor(handler)
		}
		compiler, _ := httprule.Parse(path)
		temp := compiler.Compile()
		pattern, _ := runtime.NewPattern(httprule.SupportPackageIsVersion1, temp.OpCodes, temp.Pool, temp.Verb)
		r.Add(method, path, encodeFunc(
			func(w http1.ResponseWriter, r *http1.Request) (interface{}, error) {
				ctx := http.WithRequest(r.Context(), r)
				ctx = transport.WithHTTPHeaderForServer(ctx, r.Header)
				if h.Interceptor != nil {
					ctx = context.WithValue(ctx, transport.ServiceInfoContextKey, ChangeEndpointRoot_info)
				}
				r = r.WithContext(ctx)
				var in ChangeEndpointRootRequest
				if err := h.Decode(r, &in.EndpointApi); err != nil {
					return nil, err
				}
				var input interface{} = &in
				if u, ok := (input).(urlenc.URLValuesUnmarshaler); ok {
					if err := u.UnmarshalURLValues("", r.URL.Query()); err != nil {
						return nil, err
					}
				}
				path := r.URL.Path
				if len(path) > 0 {
					components := strings.Split(path[1:], "/")
					last := len(components) - 1
					var verb string
					if idx := strings.LastIndex(components[last], ":"); idx >= 0 {
						c := components[last]
						components[last], verb = c[:idx], c[idx+1:]
					}
					vars, err := pattern.Match(components, verb)
					if err != nil {
						return nil, err
					}
					for k, val := range vars {
						switch k {
						case "packageId":
							in.PackageId = val
						}
					}
				}
				out, err := handler(ctx, &in)
				if err != nil {
					return out, err
				}
				return out, nil
			}),
		)
	}

	add_GetEndpointsName("GET", "/api/gateway/openapi/packages-name", srv.GetEndpointsName)
	add_GetEndpoints("GET", "/api/gateway/openapi/packages", srv.GetEndpoints)
	add_GetEndpoint("GET", "/api/gateway/openapi/packages/{packageId}", srv.GetEndpoint)
	add_CreateEndpoint("POST", "/api/gateway/openapi/packages", srv.CreateEndpoint)
	add_UpdateEndpoint("PATCH", "/api/gateway/openapi/packages/{packageId}", srv.UpdateEndpoint)
	add_DeleteEndpoint("DELETE", "/api/gateway/openapi/packages/{packageId}", srv.DeleteEndpoint)
	add_GetEndpointApis("GET", "/api/gateway/openapi/packages/{packageId}/apis", srv.GetEndpointApis)
	add_CreateEndpointApi("POST", "/api/gateway/openapi/packages/{packageId}/apis", srv.CreateEndpointApi)
	add_UpdateEndpointApi("PATCH", "/api/gateway/openapi/packages/{packageId}/apis/{apiId}", srv.UpdateEndpointApi)
	add_DeleteEndpointApi("DELETE", "/api/gateway/openapi/packages/{packageId}/apis/{apiId}", srv.DeleteEndpointApi)
	add_ChangeEndpointRoot("PUT", "/api/gateway/openapi/packages/{packageId}/root-api", srv.ChangeEndpointRoot)
}
