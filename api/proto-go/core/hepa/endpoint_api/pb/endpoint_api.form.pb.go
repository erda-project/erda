// Code generated by protoc-gen-go-form. DO NOT EDIT.
// Source: endpoint_api.proto

package pb

import (
	json "encoding/json"
	url "net/url"
	strconv "strconv"
	strings "strings"

	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
	pb "github.com/erda-project/erda-proto-go/core/hepa/pb"
	structpb "google.golang.org/protobuf/types/known/structpb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/urlenc" package it is being compiled against.
var _ urlenc.URLValuesUnmarshaler = (*ChangeEndpointRootResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ChangeEndpointRootRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteEndpointApiRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteEndpointApiResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateEndpointApiResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateEndpointApiRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateEndpointApiResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*EndpointApi)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateEndpointApiRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetEndpointApisRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetEndpointApisResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteEndpointRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteEndpointResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateEndpointResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateEndpointRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateEndpointResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateEndpointRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetEndpointsNameRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*Endpoint)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetEndpointsNameResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetEndpointsRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetEndpointsResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetEndpointRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetEndpointResponse)(nil)

// ChangeEndpointRootResponse implement urlenc.URLValuesUnmarshaler.
func (m *ChangeEndpointRootResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// ChangeEndpointRootRequest implement urlenc.URLValuesUnmarshaler.
func (m *ChangeEndpointRootRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "packageId":
				m.PackageId = vals[0]
			case "endpointApi":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
			case "endpointApi.apiPath":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.ApiPath = vals[0]
			case "endpointApi.redirectType":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.RedirectType = vals[0]
			case "endpointApi.redirectAddr":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.RedirectAddr = vals[0]
			case "endpointApi.redirectPath":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.RedirectPath = vals[0]
			case "endpointApi.redirectApp":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.RedirectApp = vals[0]
			case "endpointApi.redirectService":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.RedirectService = vals[0]
			case "endpointApi.redirectRuntimeId":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.RedirectRuntimeId = vals[0]
			case "endpointApi.redirectRuntimeName":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.RedirectRuntimeName = vals[0]
			case "endpointApi.method":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.EndpointApi.Method = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.EndpointApi.Method = val
					} else {
						m.EndpointApi.Method = structpb.NewStringValue(vals[0])
					}
				}
			case "endpointApi.method.null_value":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.EndpointApi.Method = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.EndpointApi.Method = val
					} else {
						m.EndpointApi.Method = structpb.NewStringValue(vals[0])
					}
				}
			case "endpointApi.method.number_value":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.EndpointApi.Method = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.EndpointApi.Method = val
					} else {
						m.EndpointApi.Method = structpb.NewStringValue(vals[0])
					}
				}
			case "endpointApi.method.string_value":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.EndpointApi.Method = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.EndpointApi.Method = val
					} else {
						m.EndpointApi.Method = structpb.NewStringValue(vals[0])
					}
				}
			case "endpointApi.method.bool_value":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.EndpointApi.Method = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.EndpointApi.Method = val
					} else {
						m.EndpointApi.Method = structpb.NewStringValue(vals[0])
					}
				}
			case "endpointApi.method.struct_value":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.EndpointApi.Method = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.EndpointApi.Method = val
					} else {
						m.EndpointApi.Method = structpb.NewStringValue(vals[0])
					}
				}
			case "endpointApi.method.list_value":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.EndpointApi.Method = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.EndpointApi.Method = val
					} else {
						m.EndpointApi.Method = structpb.NewStringValue(vals[0])
					}
				}
			case "endpointApi.allowPassAuth":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.EndpointApi.AllowPassAuth = val
			case "endpointApi.description":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.Description = vals[0]
			case "endpointApi.hosts":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.Hosts = vals
			case "endpointApi.apiId":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.ApiId = vals[0]
			case "endpointApi.createAt":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.CreateAt = vals[0]
			case "endpointApi.diceApp":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.DiceApp = vals[0]
			case "endpointApi.diceService":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.DiceService = vals[0]
			case "endpointApi.origin":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.Origin = vals[0]
			case "endpointApi.mutable":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.EndpointApi.Mutable = val
			}
		}
	}
	return nil
}

// DeleteEndpointApiRequest implement urlenc.URLValuesUnmarshaler.
func (m *DeleteEndpointApiRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "packageId":
				m.PackageId = vals[0]
			case "apiId":
				m.ApiId = vals[0]
			}
		}
	}
	return nil
}

// DeleteEndpointApiResponse implement urlenc.URLValuesUnmarshaler.
func (m *DeleteEndpointApiResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// UpdateEndpointApiResponse implement urlenc.URLValuesUnmarshaler.
func (m *UpdateEndpointApiResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &EndpointApi{}
				}
			case "data.apiPath":
				if m.Data == nil {
					m.Data = &EndpointApi{}
				}
				m.Data.ApiPath = vals[0]
			case "data.redirectType":
				if m.Data == nil {
					m.Data = &EndpointApi{}
				}
				m.Data.RedirectType = vals[0]
			case "data.redirectAddr":
				if m.Data == nil {
					m.Data = &EndpointApi{}
				}
				m.Data.RedirectAddr = vals[0]
			case "data.redirectPath":
				if m.Data == nil {
					m.Data = &EndpointApi{}
				}
				m.Data.RedirectPath = vals[0]
			case "data.redirectApp":
				if m.Data == nil {
					m.Data = &EndpointApi{}
				}
				m.Data.RedirectApp = vals[0]
			case "data.redirectService":
				if m.Data == nil {
					m.Data = &EndpointApi{}
				}
				m.Data.RedirectService = vals[0]
			case "data.redirectRuntimeId":
				if m.Data == nil {
					m.Data = &EndpointApi{}
				}
				m.Data.RedirectRuntimeId = vals[0]
			case "data.redirectRuntimeName":
				if m.Data == nil {
					m.Data = &EndpointApi{}
				}
				m.Data.RedirectRuntimeName = vals[0]
			case "data.method":
				if m.Data == nil {
					m.Data = &EndpointApi{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Method = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Method = val
					} else {
						m.Data.Method = structpb.NewStringValue(vals[0])
					}
				}
			case "data.method.null_value":
				if m.Data == nil {
					m.Data = &EndpointApi{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Method = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Method = val
					} else {
						m.Data.Method = structpb.NewStringValue(vals[0])
					}
				}
			case "data.method.number_value":
				if m.Data == nil {
					m.Data = &EndpointApi{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Method = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Method = val
					} else {
						m.Data.Method = structpb.NewStringValue(vals[0])
					}
				}
			case "data.method.string_value":
				if m.Data == nil {
					m.Data = &EndpointApi{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Method = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Method = val
					} else {
						m.Data.Method = structpb.NewStringValue(vals[0])
					}
				}
			case "data.method.bool_value":
				if m.Data == nil {
					m.Data = &EndpointApi{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Method = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Method = val
					} else {
						m.Data.Method = structpb.NewStringValue(vals[0])
					}
				}
			case "data.method.struct_value":
				if m.Data == nil {
					m.Data = &EndpointApi{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Method = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Method = val
					} else {
						m.Data.Method = structpb.NewStringValue(vals[0])
					}
				}
			case "data.method.list_value":
				if m.Data == nil {
					m.Data = &EndpointApi{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.Method = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.Method = val
					} else {
						m.Data.Method = structpb.NewStringValue(vals[0])
					}
				}
			case "data.allowPassAuth":
				if m.Data == nil {
					m.Data = &EndpointApi{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.AllowPassAuth = val
			case "data.description":
				if m.Data == nil {
					m.Data = &EndpointApi{}
				}
				m.Data.Description = vals[0]
			case "data.hosts":
				if m.Data == nil {
					m.Data = &EndpointApi{}
				}
				m.Data.Hosts = vals
			case "data.apiId":
				if m.Data == nil {
					m.Data = &EndpointApi{}
				}
				m.Data.ApiId = vals[0]
			case "data.createAt":
				if m.Data == nil {
					m.Data = &EndpointApi{}
				}
				m.Data.CreateAt = vals[0]
			case "data.diceApp":
				if m.Data == nil {
					m.Data = &EndpointApi{}
				}
				m.Data.DiceApp = vals[0]
			case "data.diceService":
				if m.Data == nil {
					m.Data = &EndpointApi{}
				}
				m.Data.DiceService = vals[0]
			case "data.origin":
				if m.Data == nil {
					m.Data = &EndpointApi{}
				}
				m.Data.Origin = vals[0]
			case "data.mutable":
				if m.Data == nil {
					m.Data = &EndpointApi{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data.Mutable = val
			}
		}
	}
	return nil
}

// UpdateEndpointApiRequest implement urlenc.URLValuesUnmarshaler.
func (m *UpdateEndpointApiRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "packageId":
				m.PackageId = vals[0]
			case "apiId":
				m.ApiId = vals[0]
			case "endpointApi":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
			case "endpointApi.apiPath":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.ApiPath = vals[0]
			case "endpointApi.redirectType":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.RedirectType = vals[0]
			case "endpointApi.redirectAddr":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.RedirectAddr = vals[0]
			case "endpointApi.redirectPath":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.RedirectPath = vals[0]
			case "endpointApi.redirectApp":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.RedirectApp = vals[0]
			case "endpointApi.redirectService":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.RedirectService = vals[0]
			case "endpointApi.redirectRuntimeId":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.RedirectRuntimeId = vals[0]
			case "endpointApi.redirectRuntimeName":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.RedirectRuntimeName = vals[0]
			case "endpointApi.method":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.EndpointApi.Method = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.EndpointApi.Method = val
					} else {
						m.EndpointApi.Method = structpb.NewStringValue(vals[0])
					}
				}
			case "endpointApi.method.null_value":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.EndpointApi.Method = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.EndpointApi.Method = val
					} else {
						m.EndpointApi.Method = structpb.NewStringValue(vals[0])
					}
				}
			case "endpointApi.method.number_value":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.EndpointApi.Method = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.EndpointApi.Method = val
					} else {
						m.EndpointApi.Method = structpb.NewStringValue(vals[0])
					}
				}
			case "endpointApi.method.string_value":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.EndpointApi.Method = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.EndpointApi.Method = val
					} else {
						m.EndpointApi.Method = structpb.NewStringValue(vals[0])
					}
				}
			case "endpointApi.method.bool_value":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.EndpointApi.Method = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.EndpointApi.Method = val
					} else {
						m.EndpointApi.Method = structpb.NewStringValue(vals[0])
					}
				}
			case "endpointApi.method.struct_value":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.EndpointApi.Method = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.EndpointApi.Method = val
					} else {
						m.EndpointApi.Method = structpb.NewStringValue(vals[0])
					}
				}
			case "endpointApi.method.list_value":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.EndpointApi.Method = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.EndpointApi.Method = val
					} else {
						m.EndpointApi.Method = structpb.NewStringValue(vals[0])
					}
				}
			case "endpointApi.allowPassAuth":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.EndpointApi.AllowPassAuth = val
			case "endpointApi.description":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.Description = vals[0]
			case "endpointApi.hosts":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.Hosts = vals
			case "endpointApi.apiId":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.ApiId = vals[0]
			case "endpointApi.createAt":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.CreateAt = vals[0]
			case "endpointApi.diceApp":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.DiceApp = vals[0]
			case "endpointApi.diceService":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.DiceService = vals[0]
			case "endpointApi.origin":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.Origin = vals[0]
			case "endpointApi.mutable":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.EndpointApi.Mutable = val
			}
		}
	}
	return nil
}

// CreateEndpointApiResponse implement urlenc.URLValuesUnmarshaler.
func (m *CreateEndpointApiResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				m.Data = vals[0]
			}
		}
	}
	return nil
}

// EndpointApi implement urlenc.URLValuesUnmarshaler.
func (m *EndpointApi) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "apiPath":
				m.ApiPath = vals[0]
			case "redirectType":
				m.RedirectType = vals[0]
			case "redirectAddr":
				m.RedirectAddr = vals[0]
			case "redirectPath":
				m.RedirectPath = vals[0]
			case "redirectApp":
				m.RedirectApp = vals[0]
			case "redirectService":
				m.RedirectService = vals[0]
			case "redirectRuntimeId":
				m.RedirectRuntimeId = vals[0]
			case "redirectRuntimeName":
				m.RedirectRuntimeName = vals[0]
			case "method":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Method = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Method = val
					} else {
						m.Method = structpb.NewStringValue(vals[0])
					}
				}
			case "allowPassAuth":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.AllowPassAuth = val
			case "description":
				m.Description = vals[0]
			case "hosts":
				m.Hosts = vals
			case "apiId":
				m.ApiId = vals[0]
			case "createAt":
				m.CreateAt = vals[0]
			case "diceApp":
				m.DiceApp = vals[0]
			case "diceService":
				m.DiceService = vals[0]
			case "origin":
				m.Origin = vals[0]
			case "mutable":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Mutable = val
			}
		}
	}
	return nil
}

// CreateEndpointApiRequest implement urlenc.URLValuesUnmarshaler.
func (m *CreateEndpointApiRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "packageId":
				m.PackageId = vals[0]
			case "endpointApi":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
			case "endpointApi.apiPath":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.ApiPath = vals[0]
			case "endpointApi.redirectType":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.RedirectType = vals[0]
			case "endpointApi.redirectAddr":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.RedirectAddr = vals[0]
			case "endpointApi.redirectPath":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.RedirectPath = vals[0]
			case "endpointApi.redirectApp":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.RedirectApp = vals[0]
			case "endpointApi.redirectService":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.RedirectService = vals[0]
			case "endpointApi.redirectRuntimeId":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.RedirectRuntimeId = vals[0]
			case "endpointApi.redirectRuntimeName":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.RedirectRuntimeName = vals[0]
			case "endpointApi.method":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.EndpointApi.Method = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.EndpointApi.Method = val
					} else {
						m.EndpointApi.Method = structpb.NewStringValue(vals[0])
					}
				}
			case "endpointApi.method.null_value":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.EndpointApi.Method = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.EndpointApi.Method = val
					} else {
						m.EndpointApi.Method = structpb.NewStringValue(vals[0])
					}
				}
			case "endpointApi.method.number_value":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.EndpointApi.Method = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.EndpointApi.Method = val
					} else {
						m.EndpointApi.Method = structpb.NewStringValue(vals[0])
					}
				}
			case "endpointApi.method.string_value":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.EndpointApi.Method = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.EndpointApi.Method = val
					} else {
						m.EndpointApi.Method = structpb.NewStringValue(vals[0])
					}
				}
			case "endpointApi.method.bool_value":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.EndpointApi.Method = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.EndpointApi.Method = val
					} else {
						m.EndpointApi.Method = structpb.NewStringValue(vals[0])
					}
				}
			case "endpointApi.method.struct_value":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.EndpointApi.Method = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.EndpointApi.Method = val
					} else {
						m.EndpointApi.Method = structpb.NewStringValue(vals[0])
					}
				}
			case "endpointApi.method.list_value":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.EndpointApi.Method = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.EndpointApi.Method = val
					} else {
						m.EndpointApi.Method = structpb.NewStringValue(vals[0])
					}
				}
			case "endpointApi.allowPassAuth":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.EndpointApi.AllowPassAuth = val
			case "endpointApi.description":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.Description = vals[0]
			case "endpointApi.hosts":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.Hosts = vals
			case "endpointApi.apiId":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.ApiId = vals[0]
			case "endpointApi.createAt":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.CreateAt = vals[0]
			case "endpointApi.diceApp":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.DiceApp = vals[0]
			case "endpointApi.diceService":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.DiceService = vals[0]
			case "endpointApi.origin":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				m.EndpointApi.Origin = vals[0]
			case "endpointApi.mutable":
				if m.EndpointApi == nil {
					m.EndpointApi = &EndpointApi{}
				}
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.EndpointApi.Mutable = val
			}
		}
	}
	return nil
}

// GetEndpointApisRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetEndpointApisRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "packageId":
				m.PackageId = vals[0]
			case "apiPath":
				m.ApiPath = vals[0]
			case "method":
				m.Method = vals[0]
			case "origin":
				m.Origin = vals[0]
			case "diceApp":
				m.DiceApp = vals[0]
			case "diceService":
				m.DiceService = vals[0]
			case "sortField":
				m.SortField = vals[0]
			case "sortType":
				m.SortType = vals[0]
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			}
		}
	}
	return nil
}

// GetEndpointApisResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetEndpointApisResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &pb.NewPageResult{}
				}
			case "data.list":
				if m.Data == nil {
					m.Data = &pb.NewPageResult{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.List = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.List = val
					} else {
						m.Data.List = structpb.NewStringValue(vals[0])
					}
				}
			case "data.list.null_value":
				if m.Data == nil {
					m.Data = &pb.NewPageResult{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.List = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.List = val
					} else {
						m.Data.List = structpb.NewStringValue(vals[0])
					}
				}
			case "data.list.number_value":
				if m.Data == nil {
					m.Data = &pb.NewPageResult{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.List = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.List = val
					} else {
						m.Data.List = structpb.NewStringValue(vals[0])
					}
				}
			case "data.list.string_value":
				if m.Data == nil {
					m.Data = &pb.NewPageResult{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.List = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.List = val
					} else {
						m.Data.List = structpb.NewStringValue(vals[0])
					}
				}
			case "data.list.bool_value":
				if m.Data == nil {
					m.Data = &pb.NewPageResult{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.List = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.List = val
					} else {
						m.Data.List = structpb.NewStringValue(vals[0])
					}
				}
			case "data.list.struct_value":
				if m.Data == nil {
					m.Data = &pb.NewPageResult{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.List = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.List = val
					} else {
						m.Data.List = structpb.NewStringValue(vals[0])
					}
				}
			case "data.list.list_value":
				if m.Data == nil {
					m.Data = &pb.NewPageResult{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.List = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.List = val
					} else {
						m.Data.List = structpb.NewStringValue(vals[0])
					}
				}
			case "data.total":
				if m.Data == nil {
					m.Data = &pb.NewPageResult{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Total = val
			}
		}
	}
	return nil
}

// DeleteEndpointRequest implement urlenc.URLValuesUnmarshaler.
func (m *DeleteEndpointRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "packageId":
				m.PackageId = vals[0]
			}
		}
	}
	return nil
}

// DeleteEndpointResponse implement urlenc.URLValuesUnmarshaler.
func (m *DeleteEndpointResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// UpdateEndpointResponse implement urlenc.URLValuesUnmarshaler.
func (m *UpdateEndpointResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &Endpoint{}
				}
			case "data.id":
				if m.Data == nil {
					m.Data = &Endpoint{}
				}
				m.Data.Id = vals[0]
			case "data.createAt":
				if m.Data == nil {
					m.Data = &Endpoint{}
				}
				m.Data.CreateAt = vals[0]
			case "data.name":
				if m.Data == nil {
					m.Data = &Endpoint{}
				}
				m.Data.Name = vals[0]
			case "data.bindDomain":
				if m.Data == nil {
					m.Data = &Endpoint{}
				}
				m.Data.BindDomain = vals
			case "data.authType":
				if m.Data == nil {
					m.Data = &Endpoint{}
				}
				m.Data.AuthType = vals[0]
			case "data.aclType":
				if m.Data == nil {
					m.Data = &Endpoint{}
				}
				m.Data.AclType = vals[0]
			case "data.scene":
				if m.Data == nil {
					m.Data = &Endpoint{}
				}
				m.Data.Scene = vals[0]
			case "data.description":
				if m.Data == nil {
					m.Data = &Endpoint{}
				}
				m.Data.Description = vals[0]
			}
		}
	}
	return nil
}

// UpdateEndpointRequest implement urlenc.URLValuesUnmarshaler.
func (m *UpdateEndpointRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "packageId":
				m.PackageId = vals[0]
			case "endpoint":
				if m.Endpoint == nil {
					m.Endpoint = &Endpoint{}
				}
			case "endpoint.id":
				if m.Endpoint == nil {
					m.Endpoint = &Endpoint{}
				}
				m.Endpoint.Id = vals[0]
			case "endpoint.createAt":
				if m.Endpoint == nil {
					m.Endpoint = &Endpoint{}
				}
				m.Endpoint.CreateAt = vals[0]
			case "endpoint.name":
				if m.Endpoint == nil {
					m.Endpoint = &Endpoint{}
				}
				m.Endpoint.Name = vals[0]
			case "endpoint.bindDomain":
				if m.Endpoint == nil {
					m.Endpoint = &Endpoint{}
				}
				m.Endpoint.BindDomain = vals
			case "endpoint.authType":
				if m.Endpoint == nil {
					m.Endpoint = &Endpoint{}
				}
				m.Endpoint.AuthType = vals[0]
			case "endpoint.aclType":
				if m.Endpoint == nil {
					m.Endpoint = &Endpoint{}
				}
				m.Endpoint.AclType = vals[0]
			case "endpoint.scene":
				if m.Endpoint == nil {
					m.Endpoint = &Endpoint{}
				}
				m.Endpoint.Scene = vals[0]
			case "endpoint.description":
				if m.Endpoint == nil {
					m.Endpoint = &Endpoint{}
				}
				m.Endpoint.Description = vals[0]
			}
		}
	}
	return nil
}

// CreateEndpointResponse implement urlenc.URLValuesUnmarshaler.
func (m *CreateEndpointResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &Endpoint{}
				}
			case "data.id":
				if m.Data == nil {
					m.Data = &Endpoint{}
				}
				m.Data.Id = vals[0]
			case "data.createAt":
				if m.Data == nil {
					m.Data = &Endpoint{}
				}
				m.Data.CreateAt = vals[0]
			case "data.name":
				if m.Data == nil {
					m.Data = &Endpoint{}
				}
				m.Data.Name = vals[0]
			case "data.bindDomain":
				if m.Data == nil {
					m.Data = &Endpoint{}
				}
				m.Data.BindDomain = vals
			case "data.authType":
				if m.Data == nil {
					m.Data = &Endpoint{}
				}
				m.Data.AuthType = vals[0]
			case "data.aclType":
				if m.Data == nil {
					m.Data = &Endpoint{}
				}
				m.Data.AclType = vals[0]
			case "data.scene":
				if m.Data == nil {
					m.Data = &Endpoint{}
				}
				m.Data.Scene = vals[0]
			case "data.description":
				if m.Data == nil {
					m.Data = &Endpoint{}
				}
				m.Data.Description = vals[0]
			}
		}
	}
	return nil
}

// CreateEndpointRequest implement urlenc.URLValuesUnmarshaler.
func (m *CreateEndpointRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectId":
				m.ProjectId = vals[0]
			case "env":
				m.Env = vals[0]
			case "endpoint":
				if m.Endpoint == nil {
					m.Endpoint = &Endpoint{}
				}
			case "endpoint.id":
				if m.Endpoint == nil {
					m.Endpoint = &Endpoint{}
				}
				m.Endpoint.Id = vals[0]
			case "endpoint.createAt":
				if m.Endpoint == nil {
					m.Endpoint = &Endpoint{}
				}
				m.Endpoint.CreateAt = vals[0]
			case "endpoint.name":
				if m.Endpoint == nil {
					m.Endpoint = &Endpoint{}
				}
				m.Endpoint.Name = vals[0]
			case "endpoint.bindDomain":
				if m.Endpoint == nil {
					m.Endpoint = &Endpoint{}
				}
				m.Endpoint.BindDomain = vals
			case "endpoint.authType":
				if m.Endpoint == nil {
					m.Endpoint = &Endpoint{}
				}
				m.Endpoint.AuthType = vals[0]
			case "endpoint.aclType":
				if m.Endpoint == nil {
					m.Endpoint = &Endpoint{}
				}
				m.Endpoint.AclType = vals[0]
			case "endpoint.scene":
				if m.Endpoint == nil {
					m.Endpoint = &Endpoint{}
				}
				m.Endpoint.Scene = vals[0]
			case "endpoint.description":
				if m.Endpoint == nil {
					m.Endpoint = &Endpoint{}
				}
				m.Endpoint.Description = vals[0]
			}
		}
	}
	return nil
}

// GetEndpointsNameRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetEndpointsNameRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "env":
				m.Env = vals[0]
			case "projectId":
				m.ProjectId = vals[0]
			}
		}
	}
	return nil
}

// Endpoint implement urlenc.URLValuesUnmarshaler.
func (m *Endpoint) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				m.Id = vals[0]
			case "createAt":
				m.CreateAt = vals[0]
			case "name":
				m.Name = vals[0]
			case "bindDomain":
				m.BindDomain = vals
			case "authType":
				m.AuthType = vals[0]
			case "aclType":
				m.AclType = vals[0]
			case "scene":
				m.Scene = vals[0]
			case "description":
				m.Description = vals[0]
			}
		}
	}
	return nil
}

// GetEndpointsNameResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetEndpointsNameResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// GetEndpointsRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetEndpointsRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectId":
				m.ProjectId = vals[0]
			case "env":
				m.Env = vals[0]
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			case "sortField":
				m.SortField = vals[0]
			case "sortType":
				m.SortType = vals[0]
			case "domain":
				m.Domain = vals[0]
			}
		}
	}
	return nil
}

// GetEndpointsResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetEndpointsResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &pb.NewPageResult{}
				}
			case "data.list":
				if m.Data == nil {
					m.Data = &pb.NewPageResult{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.List = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.List = val
					} else {
						m.Data.List = structpb.NewStringValue(vals[0])
					}
				}
			case "data.list.null_value":
				if m.Data == nil {
					m.Data = &pb.NewPageResult{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.List = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.List = val
					} else {
						m.Data.List = structpb.NewStringValue(vals[0])
					}
				}
			case "data.list.number_value":
				if m.Data == nil {
					m.Data = &pb.NewPageResult{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.List = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.List = val
					} else {
						m.Data.List = structpb.NewStringValue(vals[0])
					}
				}
			case "data.list.string_value":
				if m.Data == nil {
					m.Data = &pb.NewPageResult{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.List = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.List = val
					} else {
						m.Data.List = structpb.NewStringValue(vals[0])
					}
				}
			case "data.list.bool_value":
				if m.Data == nil {
					m.Data = &pb.NewPageResult{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.List = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.List = val
					} else {
						m.Data.List = structpb.NewStringValue(vals[0])
					}
				}
			case "data.list.struct_value":
				if m.Data == nil {
					m.Data = &pb.NewPageResult{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.List = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.List = val
					} else {
						m.Data.List = structpb.NewStringValue(vals[0])
					}
				}
			case "data.list.list_value":
				if m.Data == nil {
					m.Data = &pb.NewPageResult{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.List = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.List = val
					} else {
						m.Data.List = structpb.NewStringValue(vals[0])
					}
				}
			case "data.total":
				if m.Data == nil {
					m.Data = &pb.NewPageResult{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Total = val
			}
		}
	}
	return nil
}

// GetEndpointRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetEndpointRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "packageId":
				m.PackageId = vals[0]
			}
		}
	}
	return nil
}

// GetEndpointResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetEndpointResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &Endpoint{}
				}
			case "data.id":
				if m.Data == nil {
					m.Data = &Endpoint{}
				}
				m.Data.Id = vals[0]
			case "data.createAt":
				if m.Data == nil {
					m.Data = &Endpoint{}
				}
				m.Data.CreateAt = vals[0]
			case "data.name":
				if m.Data == nil {
					m.Data = &Endpoint{}
				}
				m.Data.Name = vals[0]
			case "data.bindDomain":
				if m.Data == nil {
					m.Data = &Endpoint{}
				}
				m.Data.BindDomain = vals
			case "data.authType":
				if m.Data == nil {
					m.Data = &Endpoint{}
				}
				m.Data.AuthType = vals[0]
			case "data.aclType":
				if m.Data == nil {
					m.Data = &Endpoint{}
				}
				m.Data.AclType = vals[0]
			case "data.scene":
				if m.Data == nil {
					m.Data = &Endpoint{}
				}
				m.Data.Scene = vals[0]
			case "data.description":
				if m.Data == nil {
					m.Data = &Endpoint{}
				}
				m.Data.Description = vals[0]
			}
		}
	}
	return nil
}
