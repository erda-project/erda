// Code generated by protoc-gen-go-form. DO NOT EDIT.
// Source: openapi_consumer.proto

package pb

import (
	json "encoding/json"
	url "net/url"
	strconv "strconv"
	strings "strings"

	urlenc "github.com/erda-project/erda-infra/pkg/urlenc"
	pb "github.com/erda-project/erda-proto-go/core/hepa/pb"
	structpb "google.golang.org/protobuf/types/known/structpb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the "github.com/erda-project/erda-infra/pkg/urlenc" package it is being compiled against.
var _ urlenc.URLValuesUnmarshaler = (*UpdateEndpointApiAclResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateEndpointApiAclRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetEndpointApiAclResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetEndpointApiAclRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateEndpointAclResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateEndpointAclRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetEndpointAclRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetEndpointAclResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateConsumerAuthResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateConsumerAuthRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*Credential)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CredentialList)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ConsumerAuthItem)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ConsumerAuthConfig)(nil)
var _ urlenc.URLValuesUnmarshaler = (*ConsumerCredentials)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetConsumerAuthResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetConsumerAuthRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateConsumerAclResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateConsumerAclRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetConsumerAclResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*Acl)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetConsumerAclRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetConsumersNameResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetConsumersNameRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteConsumerResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*DeleteConsumerRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateConsumerResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*UpdateConsumerRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateConsumerResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*Consumer)(nil)
var _ urlenc.URLValuesUnmarshaler = (*CreateConsumerRequest)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetConsumersResponse)(nil)
var _ urlenc.URLValuesUnmarshaler = (*GetConsumersRequest)(nil)

// UpdateEndpointApiAclResponse implement urlenc.URLValuesUnmarshaler.
func (m *UpdateEndpointApiAclResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// UpdateEndpointApiAclRequest implement urlenc.URLValuesUnmarshaler.
func (m *UpdateEndpointApiAclRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "packageId":
				m.PackageId = vals[0]
			case "apiId":
				m.ApiId = vals[0]
			case "consumers":
				m.Consumers = vals
			}
		}
	}
	return nil
}

// GetEndpointApiAclResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetEndpointApiAclResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// GetEndpointApiAclRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetEndpointApiAclRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "packageId":
				m.PackageId = vals[0]
			case "apiId":
				m.ApiId = vals[0]
			}
		}
	}
	return nil
}

// UpdateEndpointAclResponse implement urlenc.URLValuesUnmarshaler.
func (m *UpdateEndpointAclResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// UpdateEndpointAclRequest implement urlenc.URLValuesUnmarshaler.
func (m *UpdateEndpointAclRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "packageId":
				m.PackageId = vals[0]
			case "consumers":
				m.Consumers = vals
			}
		}
	}
	return nil
}

// GetEndpointAclRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetEndpointAclRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "packageId":
				m.PackageId = vals[0]
			}
		}
	}
	return nil
}

// GetEndpointAclResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetEndpointAclResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// UpdateConsumerAuthResponse implement urlenc.URLValuesUnmarshaler.
func (m *UpdateConsumerAuthResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &ConsumerCredentials{}
				}
			case "data.consumerName":
				if m.Data == nil {
					m.Data = &ConsumerCredentials{}
				}
				m.Data.ConsumerName = vals[0]
			case "data.consumerId":
				if m.Data == nil {
					m.Data = &ConsumerCredentials{}
				}
				m.Data.ConsumerId = vals[0]
			case "data.authConfig":
				if m.Data == nil {
					m.Data = &ConsumerCredentials{}
				}
				if m.Data.AuthConfig == nil {
					m.Data.AuthConfig = &ConsumerAuthConfig{}
				}
			}
		}
	}
	return nil
}

// UpdateConsumerAuthRequest implement urlenc.URLValuesUnmarshaler.
func (m *UpdateConsumerAuthRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "consumerId":
				m.ConsumerId = vals[0]
			case "credentials":
				if m.Credentials == nil {
					m.Credentials = &ConsumerCredentials{}
				}
			case "credentials.consumerName":
				if m.Credentials == nil {
					m.Credentials = &ConsumerCredentials{}
				}
				m.Credentials.ConsumerName = vals[0]
			case "credentials.consumerId":
				if m.Credentials == nil {
					m.Credentials = &ConsumerCredentials{}
				}
				m.Credentials.ConsumerId = vals[0]
			case "credentials.authConfig":
				if m.Credentials == nil {
					m.Credentials = &ConsumerCredentials{}
				}
				if m.Credentials.AuthConfig == nil {
					m.Credentials.AuthConfig = &ConsumerAuthConfig{}
				}
			}
		}
	}
	return nil
}

// Credential implement urlenc.URLValuesUnmarshaler.
func (m *Credential) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "consumerId":
				m.ConsumerId = vals[0]
			case "createdAt":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.CreatedAt = val
			case "id":
				m.Id = vals[0]
			case "key":
				m.Key = vals[0]
			case "redirectUrl":
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.RedirectUrl = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.RedirectUrl = val
					} else {
						m.RedirectUrl = structpb.NewStringValue(vals[0])
					}
				}
			case "redirectUrls":
				m.RedirectUrls = vals
			case "name":
				m.Name = vals[0]
			case "clientId":
				m.ClientId = vals[0]
			case "clientSecret":
				m.ClientSecret = vals[0]
			case "secret":
				m.Secret = vals[0]
			case "username":
				m.Username = vals[0]
			}
		}
	}
	return nil
}

// CredentialList implement urlenc.URLValuesUnmarshaler.
func (m *CredentialList) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "total":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Total = val
			}
		}
	}
	return nil
}

// ConsumerAuthItem implement urlenc.URLValuesUnmarshaler.
func (m *ConsumerAuthItem) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "authType":
				m.AuthType = vals[0]
			case "authData":
				if m.AuthData == nil {
					m.AuthData = &CredentialList{}
				}
			case "authData.total":
				if m.AuthData == nil {
					m.AuthData = &CredentialList{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.AuthData.Total = val
			case "authTips":
				m.AuthTips = vals[0]
			}
		}
	}
	return nil
}

// ConsumerAuthConfig implement urlenc.URLValuesUnmarshaler.
func (m *ConsumerAuthConfig) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// ConsumerCredentials implement urlenc.URLValuesUnmarshaler.
func (m *ConsumerCredentials) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "consumerName":
				m.ConsumerName = vals[0]
			case "consumerId":
				m.ConsumerId = vals[0]
			case "authConfig":
				if m.AuthConfig == nil {
					m.AuthConfig = &ConsumerAuthConfig{}
				}
			}
		}
	}
	return nil
}

// GetConsumerAuthResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetConsumerAuthResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &ConsumerCredentials{}
				}
			case "data.consumerName":
				if m.Data == nil {
					m.Data = &ConsumerCredentials{}
				}
				m.Data.ConsumerName = vals[0]
			case "data.consumerId":
				if m.Data == nil {
					m.Data = &ConsumerCredentials{}
				}
				m.Data.ConsumerId = vals[0]
			case "data.authConfig":
				if m.Data == nil {
					m.Data = &ConsumerCredentials{}
				}
				if m.Data.AuthConfig == nil {
					m.Data.AuthConfig = &ConsumerAuthConfig{}
				}
			}
		}
	}
	return nil
}

// GetConsumerAuthRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetConsumerAuthRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "consumerId":
				m.ConsumerId = vals[0]
			}
		}
	}
	return nil
}

// UpdateConsumerAclResponse implement urlenc.URLValuesUnmarshaler.
func (m *UpdateConsumerAclResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// UpdateConsumerAclRequest implement urlenc.URLValuesUnmarshaler.
func (m *UpdateConsumerAclRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "consumerId":
				m.ConsumerId = vals[0]
			case "packages":
				m.Packages = vals
			}
		}
	}
	return nil
}

// GetConsumerAclResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetConsumerAclResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// Acl implement urlenc.URLValuesUnmarshaler.
func (m *Acl) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				m.Id = vals[0]
			case "name":
				m.Name = vals[0]
			case "description":
				m.Description = vals[0]
			case "selected":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Selected = val
			}
		}
	}
	return nil
}

// GetConsumerAclRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetConsumerAclRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "consumerId":
				m.ConsumerId = vals[0]
			}
		}
	}
	return nil
}

// GetConsumersNameResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetConsumersNameResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	return nil
}

// GetConsumersNameRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetConsumersNameRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectId":
				m.ProjectId = vals[0]
			case "env":
				m.Env = vals[0]
			}
		}
	}
	return nil
}

// DeleteConsumerResponse implement urlenc.URLValuesUnmarshaler.
func (m *DeleteConsumerResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				val, err := strconv.ParseBool(vals[0])
				if err != nil {
					return err
				}
				m.Data = val
			}
		}
	}
	return nil
}

// DeleteConsumerRequest implement urlenc.URLValuesUnmarshaler.
func (m *DeleteConsumerRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "consumerId":
				m.ConsumerId = vals[0]
			}
		}
	}
	return nil
}

// UpdateConsumerResponse implement urlenc.URLValuesUnmarshaler.
func (m *UpdateConsumerResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &Consumer{}
				}
			case "data.id":
				if m.Data == nil {
					m.Data = &Consumer{}
				}
				m.Data.Id = vals[0]
			case "data.createAt":
				if m.Data == nil {
					m.Data = &Consumer{}
				}
				m.Data.CreateAt = vals[0]
			case "data.name":
				if m.Data == nil {
					m.Data = &Consumer{}
				}
				m.Data.Name = vals[0]
			case "data.description":
				if m.Data == nil {
					m.Data = &Consumer{}
				}
				m.Data.Description = vals[0]
			}
		}
	}
	return nil
}

// UpdateConsumerRequest implement urlenc.URLValuesUnmarshaler.
func (m *UpdateConsumerRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "consumerId":
				m.ConsumerId = vals[0]
			case "consumer":
				if m.Consumer == nil {
					m.Consumer = &Consumer{}
				}
			case "consumer.id":
				if m.Consumer == nil {
					m.Consumer = &Consumer{}
				}
				m.Consumer.Id = vals[0]
			case "consumer.createAt":
				if m.Consumer == nil {
					m.Consumer = &Consumer{}
				}
				m.Consumer.CreateAt = vals[0]
			case "consumer.name":
				if m.Consumer == nil {
					m.Consumer = &Consumer{}
				}
				m.Consumer.Name = vals[0]
			case "consumer.description":
				if m.Consumer == nil {
					m.Consumer = &Consumer{}
				}
				m.Consumer.Description = vals[0]
			}
		}
	}
	return nil
}

// CreateConsumerResponse implement urlenc.URLValuesUnmarshaler.
func (m *CreateConsumerResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				m.Data = vals[0]
			}
		}
	}
	return nil
}

// Consumer implement urlenc.URLValuesUnmarshaler.
func (m *Consumer) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "id":
				m.Id = vals[0]
			case "createAt":
				m.CreateAt = vals[0]
			case "name":
				m.Name = vals[0]
			case "description":
				m.Description = vals[0]
			}
		}
	}
	return nil
}

// CreateConsumerRequest implement urlenc.URLValuesUnmarshaler.
func (m *CreateConsumerRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectId":
				m.ProjectId = vals[0]
			case "env":
				m.Env = vals[0]
			case "consumer":
				if m.Consumer == nil {
					m.Consumer = &Consumer{}
				}
			case "consumer.id":
				if m.Consumer == nil {
					m.Consumer = &Consumer{}
				}
				m.Consumer.Id = vals[0]
			case "consumer.createAt":
				if m.Consumer == nil {
					m.Consumer = &Consumer{}
				}
				m.Consumer.CreateAt = vals[0]
			case "consumer.name":
				if m.Consumer == nil {
					m.Consumer = &Consumer{}
				}
				m.Consumer.Name = vals[0]
			case "consumer.description":
				if m.Consumer == nil {
					m.Consumer = &Consumer{}
				}
				m.Consumer.Description = vals[0]
			}
		}
	}
	return nil
}

// GetConsumersResponse implement urlenc.URLValuesUnmarshaler.
func (m *GetConsumersResponse) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "data":
				if m.Data == nil {
					m.Data = &pb.NewPageResult{}
				}
			case "data.list":
				if m.Data == nil {
					m.Data = &pb.NewPageResult{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.List = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.List = val
					} else {
						m.Data.List = structpb.NewStringValue(vals[0])
					}
				}
			case "data.list.null_value":
				if m.Data == nil {
					m.Data = &pb.NewPageResult{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.List = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.List = val
					} else {
						m.Data.List = structpb.NewStringValue(vals[0])
					}
				}
			case "data.list.number_value":
				if m.Data == nil {
					m.Data = &pb.NewPageResult{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.List = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.List = val
					} else {
						m.Data.List = structpb.NewStringValue(vals[0])
					}
				}
			case "data.list.string_value":
				if m.Data == nil {
					m.Data = &pb.NewPageResult{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.List = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.List = val
					} else {
						m.Data.List = structpb.NewStringValue(vals[0])
					}
				}
			case "data.list.bool_value":
				if m.Data == nil {
					m.Data = &pb.NewPageResult{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.List = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.List = val
					} else {
						m.Data.List = structpb.NewStringValue(vals[0])
					}
				}
			case "data.list.struct_value":
				if m.Data == nil {
					m.Data = &pb.NewPageResult{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.List = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.List = val
					} else {
						m.Data.List = structpb.NewStringValue(vals[0])
					}
				}
			case "data.list.list_value":
				if m.Data == nil {
					m.Data = &pb.NewPageResult{}
				}
				if len(vals) > 1 {
					var list []interface{}
					for _, text := range vals {
						var v interface{}
						err := json.NewDecoder(strings.NewReader(text)).Decode(&v)
						if err != nil {
							list = append(list, v)
						} else {
							list = append(list, text)
						}
					}
					val, _ := structpb.NewList(list)
					m.Data.List = structpb.NewListValue(val)
				} else {
					var v interface{}
					err := json.NewDecoder(strings.NewReader(vals[0])).Decode(&v)
					if err != nil {
						val, _ := structpb.NewValue(v)
						m.Data.List = val
					} else {
						m.Data.List = structpb.NewStringValue(vals[0])
					}
				}
			case "data.total":
				if m.Data == nil {
					m.Data = &pb.NewPageResult{}
				}
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.Data.Total = val
			}
		}
	}
	return nil
}

// GetConsumersRequest implement urlenc.URLValuesUnmarshaler.
func (m *GetConsumersRequest) UnmarshalURLValues(prefix string, values url.Values) error {
	for key, vals := range values {
		if len(vals) > 0 {
			switch prefix + key {
			case "projectId":
				m.ProjectId = vals[0]
			case "env":
				m.Env = vals[0]
			case "pageNo":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageNo = val
			case "pageSize":
				val, err := strconv.ParseInt(vals[0], 10, 64)
				if err != nil {
					return err
				}
				m.PageSize = val
			case "sortField":
				m.SortField = vals[0]
			case "sortType":
				m.SortType = vals[0]
			}
		}
	}
	return nil
}
